<html>
<head>
<title>Understanding JavaScript’s Array.Group and Array.GroupToMap - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>理解 JavaScript 的数组。组和数组。GroupToMap - LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/javascript-array-group-array-grouptomap/#0001-01-01">https://blog.logrocket.com/javascript-array-group-array-grouptomap/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong> </em> <em>这本理解 JavaScript 的<code>Array.Group</code>和<code>Array.GroupToMap</code>的指南最后一次更新是在 2023 年 1 月 9 日，以反映 API 的提议的变化。此更新还包括对这两种方法进行比较的部分、它们的优点以及有关最有效的阵列分组方式的更多信息。</em></p>
<p>JavaScript 规范继续发展，以满足使用该语言的开发人员的需求。ECMAScript  (ES)是定义不同的<a href="https://blog.logrocket.com/top-5-web-apis-performance-based-analysis/">API 的标准，在用 JavaScript </a>编码时可以使用这些 API。</p>
<p>多年来已经有了几个不同的 ES 版本，每个版本都旨在添加更多的 API，改进现有的 API，并确保语言保持相关性。向语言添加新 API 的过程包括从零阶段开始的提议和多个批准阶段，在零阶段，提议计划由 TC39 拥护者提交给 EMCA 委员会，或者提交给委员会并且没有被最终拒绝，到第四阶段，提议将被包括在下一个 es 版本中。</p>
<p>2021 年 6 月，<a href="https://github.com/jridgewell/"> Justin Ridgewell </a>提出在<code>Array</code> API 中增加<code>group</code>的提案。分组数据很常见，但目前在标准的 JavaScript <code>Array</code> API 中不可用。以前，开发人员必须构建自己的解决方案或使用第三方库。</p>
<p>然而，这个提案，其前身是<code>Array.GroupBy</code>，目前正处于<a href="https://github.com/tc39/proposal-array-grouping">阶段三</a>。这意味着它被认为是完整的，如果没有实现经验、大量使用和外部反馈，就不可能进行进一步的工作。</p>
<p>这意味着它应该很快成为标准。因此，让我们看看<code>group</code>和<code>groupToMap</code>以及我们如何构建自己的实现。</p>
<p><em>向前跳转:</em></p>

<h2 id="grouping-data-group">用组对数据进行分组</h2>
<p>此外，由于<code>group</code>和<code>groupToMap</code>数组方法仍处于提议阶段，我们不能在 JavaScript 项目中使用它们。然而，如果我们使用<a href="https://blog.logrocket.com/use-polyfills-react-app/"> polyfill </a>，浏览器将理解这些方法做什么，并为我们运行它们，而不会在我们使用它们时抛出错误。</p>
<p>简而言之，聚合填充是在本身不支持某个功能的 web 浏览器上实现该功能的代码。<a href="https://github.com/zloirock/core-js#array-grouping"> core-js </a>是一个健壮的聚合填充，我们可以用它来使<code>group</code>和<code>groupToMap</code>在浏览器中可用。</p>
<p>为了开始使用<a href="https://github.com/zloirock/core-js"> core-js </a>，我们可以在项目中运行以下代码来安装这个库:</p>
<pre class="language-shell hljs">// Terminal
npm install --save <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="42212d30276f283102716c70746c73">[email protected]</a>
</pre>
<p>接下来，我们应该将它导入到我们想要使用<code>group</code>和<code>groupToMap</code>方法的文件中:</p>
<pre class="language-javascript hljs">// JavaScript
// polyfill all `core-js` features, including early-stage proposals:
import "core-js";
</pre>
<p>作为快速入门，您可以查看下面的示例:</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>bonarhyme 使用 core-js、react、react-dom、react-scripts 的数组分组方法示例</p>
</blockquote>
<p>创建要分组的数组</p>
<h3 id="creating-array-group">在开始使用<code>group</code>之前，我们需要一些数据来分组。当您想要对数据进行分组时，您通常想要获取该数据的一个或多个属性，并按该属性对其进行组织。</h3>
<p>在我们的例子中，让我们以一组狗为例:</p>
<p>我们的狗数组由每只狗的一个对象组成，每只狗有一个<code>name</code>、<code>breed</code>和<code>age</code>。<code>breed</code>是最常见的属性，因此我们将使用它来对数据进行分组。你也可以用<code>age</code>来得到同龄的狗。</p>
<pre class="language-javascript hljs">// Javascript 
const DOGS = [
 {
  name: 'Groucho Barks',
  breed: 'German Shepherd',
  age: 1
 },
 {
  name: 'Pepper',
  breed: 'Shih Tzu',
  age: 3
 },
 {
  name: 'Bark Twain',
  breed: 'Dachshund',
  age: 5
 },
 {
  name: 'Jimmy Chew',
  breed: 'Shih Tzu',
  age: 10
 },
 {
  name: 'Pup Tar',
  breed: 'Dachshund',
  age: 2
 },
]
</pre>
<p>也可以用<code>name</code>。但是，在大多数情况下，这些名称不会匹配或分组任何内容。那么，让我们看看如何使用建议对数据进行分组:</p>
<p>我们可以通过在数组实例上调用新的<code>group</code>函数来使用它，就像一个<code>map</code>、<code>filter</code>或<code>reduce</code>函数一样。<code>group</code>按照升序对数组中的每个元素调用<code>callback</code>函数。</p>
<pre class="language-javascript hljs">const byBreed = DOGS.group(dog =&gt; {
 return dog.breed;
});
</pre>
<p><code>group</code>函数返回一个新对象，其中每个键代表不同的品种，值是所有匹配狗的数组。如果我们要记录<code>byBreed</code>变量，它看起来像下面的代码:</p>
<p>下面是 React 项目中使用的分组方法:</p>
<pre class="language-javascript hljs">// Javascript
// Value in console

{
    "German Shepherd": [
        {
            "name": "Groucho Barks",
            "breed": "German Shepherd",
            "age": 1
        }
    ],
    "Shih Tzu": [
        {
            "name": "Pepper",
            "breed": "Shih Tzu",
            "age": 3
        },
        {
            "name": "Jimmy Chew",
            "breed": "Shih Tzu",
            "age": 10
        }
    ],
    "Dachshund": [
        {
            "name": "Bark Twain",
            "breed": "Dachshund",
            "age": 5
        },
        {
            "name": "Pup Tar",
            "breed": "Dachshund",
            "age": 2
        }
    ]
} 
</pre>
<p>bonarhyme 使用 core-js、react、react-dom、react-scripts 的数组分组方法示例</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Array Group Method Example by bonarhyme using core-js, react, react-dom, react-scripts</p>
</blockquote>
<p>用<code>groupToMap</code>分组数据</p>
<pre class="prettyprint"/>
<h2 id="grouping-data-grouptomap">与上一节一样，您可以看看下面的例子来快速入门:</h2>
<p>数组组使用 core-js，react，react-dom，react-scripts 通过 bonarhyme 映射方法</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Array GroupToMap Map Method by bonarhyme using core-js, react, react-dom, react-scripts</p>
</blockquote>
<p><code>groupToMap()</code>方法使用其<code>callback</code>函数返回的值对数组中的元素进行分组。它返回一个将来自<code>callback</code>函数的唯一值作为键的<code>Map</code>，可以用来访问每个组中的元素数组。复杂类型，比如对象，可以通过<code>groupToMap()</code>方法用作键。</p>
<p>当对与某个对象关联的元素进行分组时，尤其是当该对象可能会随时间变化时，方法最有用。在我们的例子中，让我们以一组运动员为例:</p>
<p>我们的运动员数组为每个<code>athlete</code>包含一个对象，每个对象有一个<code>name</code>、<code>nationality</code>、<code>age</code>和<code>height</code>。为了获得参加体育比赛的资格，<code>age</code>是最常见的属性，因此我们将使用它来对数据进行分组:</p>
<pre class="language-javascript hljs">const ATHLETES = [
 {
  name: 'Blessing Ogabere',
  nationality: 'Nigerian',
  age: 26,
  height: '78ft'
 },
  {
  name: 'Usain Bolt',
  nationality: 'Jamican',
  age: 29,
  height: '82ft'
 },
{
  name: 'Fred KERLEY',
  nationality: 'USA',
  age: 16,
  height: '82ft'
 },
{
  name: 'Oblique SEVILLE',
  nationality: 'Jamican',
  age: 17,
  height: '82ft'
 },
]
</pre>
<p>下面的代码使用带有<a href="https://blog.logrocket.com/anomalies-in-javascript-arrow-functions/"> <code>arrow</code>函数</a>的<code>groupToMap()</code>，该函数根据元素的年龄是否大于 18，返回名为<code>eligible</code>或<code>ineligible</code>的对象键。返回的结果对象是一个<code>Map</code>。</p>
<pre class="language-javascript hljs">const eligible  = {eligible: true };
const ineligible = {ineligible: true };

ATHLETES.groupByToMap((athlete, index, array) =&gt; {
  return athlete.age &gt; 18 ? eligible: ineligible;
});

// results: 
Map { 
{eligible: true}: [
{
  name: 'Blessing Ogabere',
  nationality: 'Nigerian',
  age: 26,
  height: '78ft'
 },
  {
  name: 'Usain Bolt',
  nationality: 'Jamican',
  age: 29,
  height: '82ft'
 }
],
 {ineligible: true}: [
{
  name: 'Fred KERLEY',
  nationality: 'USA',
  age: 16,
  height: '82ft'
 },
{
  name: 'Oblique SEVILLE',
  nationality: 'Jamican',
  age: 17,
  height: '82ft'
 }
] 
}
</pre>
<p>为了从<code>Map</code>中获得一个数组，我们需要用密钥调用<code>get()</code>来获得数组:</p>
<p>下面是 React 项目中使用的<code>groupToMap</code>方法:</p>
<pre class="language-javascript hljs">const results = ATHLETES.groupByToMap((athlete) =&gt; {
  return athlete.age &gt; 18 ? eligible: ineligible;
});

console.log(results.get(eligible));

//result:
[
{
  name: 'Blessing Ogabere',
  nationality: 'Nigerian',
  age: 26,
  height: '78ft'
 },
  {
  name: 'Usain Bolt',
  nationality: 'Jamican',
  age: 29,
  height: '82ft'
 }
]
</pre>
<p>数组组使用 core-js，react，react-dom，react-scripts 通过 bonarhyme 映射方法</p>
<blockquote class="embedly-card" data-card-controls="1" data-card-align="center" data-card-theme="light">

<p>Array GroupToMap Map Method by bonarhyme using core-js, react, react-dom, react-scripts</p>
</blockquote>
<p><code>group</code>和<code>groupToMap</code>方法之间的区别</p>
<pre class="prettyprint"/>
<h2 id="differences-group-grouptomap"><code>Group</code></h2>
<table>
<tbody>
<tr>
<td><code>GroupToMap</code></td>
<td>这将返回一个新对象，其中每个键都是您排序时使用的不同键</td>
</tr>
<tr>
<td>这将返回一个将来自<code>callback</code>函数的唯一值作为键的<code>Map</code>，可用于访问每个组中的元素数组</td>
<td>可以使用不同的值访问返回的结果，这些值现在已经被设置为键，就像在常规对象中一样</td>
</tr>
<tr>
<td>可以使用<code>Maps</code>中的<code>get</code>方法访问返回的结果</td>
<td>为排序指定的键值用于对数组进行分组</td>
</tr>
<tr>
<td>您创建的自定义值用于对阵列进行分组</td>
<td>这不需要条件来排序数组</td>
</tr>
<tr>
<td>这需要一个条件来对数组进行分组</td>
<td><code>group</code>的替代方案</td>
</tr>
</tbody>
</table>
<h2 id="alternatives-group">使用 Lodash</h2>
<h3>Lodash 是最著名的 JavaScript 实用程序库，它的创建是为了解决许多在旧版本 JavaScript 中不存在的 API 缺失问题。</h3>
<p>虽然现在存在许多 API，但人们在构建应用程序时仍然使用 Lodash。Lodash 有一个可以作为数组传递的<a href="https://lodash.com/docs/4.17.15#groupBy"> <code>groupBy</code>函数</a>和一个<code>callback</code>函数。我们可以在下面看到如何使用 Lodash 实现我们的狗的分组示例:</p>
<p>这会产生与<code>groupBy</code>提案相同的结果。然而，使用 Lodash 版本的主要区别是需要导入 Lodash 包并调用数组中传递的函数，而不是调用数组上的函数。</p>
<pre class="language-javascript hljs">import groupBy from 'lodash.groupby';

const byBreed = groupBy(dogs, dog =&gt; {
  return dog.breed;
});
</pre>
<p>使用 Ramda</p>
<h3><a href="https://ramdajs.com/"> Ramda </a>是另一个 JavaScript 实用程序库，它与 Lodash 的主要区别在于它的功能重点。Ramda 是一个一级公民库的函数式编程，你可以<a href="https://blog.logrocket.com/a-closer-look-at-javascript-closures-higher-order-functions-and-currying/">很容易地找到实用函数</a>。</h3>
<p>在下面的例子中，很难看出它和使用 Lodash 有什么区别:</p>
<p>在这个例子中，我们创建了一个<code>byBreed</code>函数，稍后我们可以用狗的列表来调用它。当我们调用拉姆达的<code>groupBy</code>时，我们也可以传入<code>DOGS</code>:</p>
<pre class="language-javascript hljs">import R from 'ramda';

const byBreed = R.groupBy(function(dog) {
 return dog.breed
});

byBreed(DOGS);  
</pre>
<p>这存档了相同的结果，但是如果我们使用 Ramda 的函数性质，我们可以组合多个函数:</p>
<pre class="language-javascript hljs">R.groupBy(dog =&gt; dog.breed, DOGS);
</pre>
<p>在这个例子中，我们可以反转每只狗的名字，将它们分组，并使其成为一个可重用的函数。</p>
<pre class="language-javascript hljs">const byBreed = R.groupBy(function(dog) {
 return dog.breed
});

const reverseName = R.map(function(dog) {
  return {
    ...dog,
    name: dog.name.split('').reverse().join('')
  }
})

const processDogs = R.compose(byBreed, reverseName)
processDogs(DOGS);
</pre>
<p>创建您自己的<code>group</code></p>
<h2 id="create-own-group">添加一个像 Lodash 或 Ramda 这样的外部库既有好处也有缺点。好处包括库提供的附加实用程序。然而，缺点包括最终用户的额外捆绑包大小和管理第三方依赖项的开销。</h2>
<p>因为<code>group</code>函数目前不在核心语言中；你可以创建你自己的<code>group</code>函数来使用，直到正式版本发布。让我们看看如何创建我们的版本:</p>
<p>在上面的例子中，我们创建了一个新的函数，它接受一个列表和一个键。这个键是我们要分组的。然后我们使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"> <code>Array.reduce</code>函数</a>进行分组。</p>
<pre class="language-javascript hljs">const group = (list, key) =&gt; {
    return list.reduce((prev, curr) =&gt; {
        return {
            ...prev,
            [curr[key]]: [
                ...(prev[key] || []),
                curr, 
            ]
        }    
    }, {})
}
group(DOGS, 'breed')
</pre>
<p>我们的<code>reduce</code>将狗的数组转换成一个对象，然后遍历每只狗，并将它们添加到对象中。如果该品种(<code>key</code>)在对象上不存在，则创建该对象。对象<code>key</code>的值是一个添加了品种的数组。</p>
<p>对阵列进行分组的最有效方法</p>
<h2 id="most-efficient-way-group-array">在编写本文时，实际上对数组进行分组的最有效的方法是使用<a href="https://blog.logrocket.com/write-more-readable-react-code/#:~:text=The%20Array.reduce%20function%20for%20data%20conversion"> <code>Array.reduce</code> </a>方法。本文“创建您自己的组”一节的示例中使用了这种方法。然而，使用<code>group</code>和<code>groupToMap</code>数组方法意味着我们实际上是在使用一种已经被证实工作良好的方法。</h2>
<p>结论</p>
<h2>增加<code>group</code>和<code>groupToMap</code>是对语言的一个小改动。不过，通过深入研究，我们可以看到 JavaScript 提案流程是如何工作的，现有的库是如何应对挑战的，以及我们如何创建自己的函数版本。</h2>
<p>通过理解上下文，更容易地调试 JavaScript 错误</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</h2>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的 JavaScript 前端的互动，让您能够准确找出导致错误的用户行为。</p>
<p>LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的 JavaScript 代码的影响从来没有这么简单过！</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>.</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
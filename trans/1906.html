<html>
<head>
<title>New features in Next.js 11 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Next.js 11 - LogRocket 博客中的新特性</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/new-features-in-next-js-11/#0001-01-01">https://blog.logrocket.com/new-features-in-next-js-11/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在 6 月 15 日的<a href="https://nextjs.org/conf#room-jz4ki"> 2021 Next.js Conf </a>上，来自世界各地的开发者共同见证了 Vercel 团队最新发布的<a href="https://nextjs.org/blog/next-11"> Next.js 11 </a>的发布。Next.js 11 中包含的更新和新特性对已经很流行的库进行了重大改进。</p>
<p>在本文中，我们将深入了解这些更新，它们对用户和开发人员的体验都产生了影响。我们开始吧！</p>
<h2 id="conformance">顺应</h2>
<p>在其核心，一致性是一套原则或编码指南，它从开发人员那里拿走了一些决策责任。通过设置默认值和提供指导方针，可以更容易地达到预期的结果并防止常见错误。</p>
<p>根据<a href="https://nextjs.org/blog/next-11"> Next.js 团队的说法，</a>“一致性是一个系统，它提供精心制作的解决方案和规则，以支持最佳加载和核心 Web 活力”。</p>
<p>Next.js 11 中新的一致性原则可以分为三个方面:</p>
<h3>1.严重违约</h3>
<p>框架必须在其核心建立一定的设计模式，使开发人员很难做错误的事情。</p>
<h3>2.可执行的规则</h3>
<p>尽管有很强的默认设置，但还是会有这样的情况，即开发人员有责任在两条潜在的路径之间做出选择。一组可操作的规则将使应用程序更容易遵守强大的性能标准，同时仍然允许足够的定制级别。</p>
<h3>3.创作时间</h3>
<p>创作时间在特性的开发周期中(而不是在生产之后)赋予性能以重要性。在代码提交之前必须考虑性能，而不是在产品发布之后将其视为基于分析的指标。</p>
<p>实施创作时间原则的最简单的方法之一是通过林挺规则。所以 Next.js 11 支持 ESLint 开箱即用。</p>
<p>要获得这些功能的好处，您必须通过运行以下代码升级到 Next.js 的最新版本:</p>
<pre>npm i <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0b656e737f4b676a7f6e787f">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="75071014160135191401100601">[email protected]</a> <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1c6e797d7f68317873715c707d68796f68">[email protected]</a></pre>
<p>通过运行以下代码启用林挺:</p>
<pre>npx next lint</pre>
<p>一旦我们升级我们的版本并启用 ESLint，我们将开始收到警告，促使我们朝着行业最佳实践的方向前进，帮助我们的应用程序遵守一致性准则。</p>
<h2 id="scriptoptimization">脚本优化</h2>
<p>许多网站包含第三方脚本来支持分析和广告。</p>
<p>脚本的加载顺序对页面性能有很大的影响，尤其是在处理一个网页上的多个外部脚本时。如果管理不当，脚本会严重降低用户体验。</p>
<p>Next.js 引入了一个<a href="https://nextjs.org/docs/basic-features/script">脚本组件</a>，它带有一个<code>strategy</code>属性，可以处理很多这样的问题。</p>
<p>让我们来测试一下！一个值得注意的变化是，我们不再需要将原生 HTML 脚本标签包装在<code>next/head</code>标签中:</p>
<pre>import Head from 'next/head'
function Home() {
 return (
    &lt;&gt;
      &lt;Head&gt;
        &lt;script async src="https://polyfill.io/v3/polyfill.min.js?features=WebAnimations" /&gt;
      &lt;/Head&gt;
    &lt;/&gt;
  )
}
</pre>
<p>相反，我们可以直接使用本机 HTML 脚本标记，如下所示:</p>
<pre>import Script from 'next/script'
function Home() {
  return (
    &lt;&gt;
      &lt;Script src="https://polyfill.io/v3/polyfill.min.js?features=WebAnimations" /&gt;
    &lt;/&gt;
  )
}
</pre>
<p>在本例中，建议我们使用<code>beforeInteractive</code>策略加载 polyfill。让我们改变策略，看看它是如何影响脚本加载的！</p>
<h3><code>beforeInteractive</code></h3>
<p>在捆绑的 JavaScript 可以运行之前，脚本被注入到服务器端的 HTML 中并在浏览器上运行。使用下面的代码块，我们看到获取 polyfill 的网络调用是在 network 选项卡中的其他所有操作之前进行的:</p>
<pre>&lt;Script src="https://polyfill.io/v3/polyfill.min.js?features=WebAnimations" 
`strategy="beforeInteractive" /&gt;
</pre>
<p><img data-attachment-id="56679" data-permalink="https://blog.logrocket.com/new-features-in-next-js-11/beforeinteractive-script-polyfill-first/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first.png" data-orig-size="730,326" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="beforeinteractive-script-polyfill-first" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first.png" decoding="async" class="aligncenter wp-image-56679 size-full jetpack-lazy-image" src="../Images/27e5bdd95c9d1332c0a633f2c68aa213.png" alt="Beforeinteractive Script Polyfill First" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first-300x134.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56679" data-permalink="https://blog.logrocket.com/new-features-in-next-js-11/beforeinteractive-script-polyfill-first/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first.png" data-orig-size="730,326" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="beforeinteractive-script-polyfill-first" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first.png" decoding="async" loading="lazy" class="aligncenter wp-image-56679 size-full" src="../Images/27e5bdd95c9d1332c0a633f2c68aa213.png" alt="Beforeinteractive Script Polyfill First" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first-300x134.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/beforeinteractive-script-polyfill-first.png"/></noscript>
<h3><code>afterInteractive</code></h3>
<p>如果我们将策略改为<code>afterInteractive</code>，脚本将在页面变得可交互后执行。网络请求位于页面底部的网络选项卡中，该选项卡优先处理更重要的任务。</p>
<p><img data-attachment-id="56680" data-permalink="https://blog.logrocket.com/new-features-in-next-js-11/after-interactive-script-execute-last/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last.png" data-orig-size="730,325" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="after-interactive-script-execute-last" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last.png" decoding="async" class="aligncenter wp-image-56680 size-full jetpack-lazy-image" src="../Images/2bd1b7d3af1a8b44b000b641154b8ade.png" alt="After Interactive Script Execute Last" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last-300x134.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56680" data-permalink="https://blog.logrocket.com/new-features-in-next-js-11/after-interactive-script-execute-last/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last.png" data-orig-size="730,325" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="after-interactive-script-execute-last" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last.png" decoding="async" loading="lazy" class="aligncenter wp-image-56680 size-full" src="../Images/2bd1b7d3af1a8b44b000b641154b8ade.png" alt="After Interactive Script Execute Last" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last-300x134.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/after-interactive-script-execute-last.png"/></noscript>
<h3><code>lazyOnload</code></h3>
<p>将策略改为<code>lazyOnload</code>告诉 Next.js 在空闲时间加载脚本。提取聚合填充的网络请求进一步向下移动到页面底部；没有其他懒惰加载的脚本，如下一个截图所示。</p>
<p><img data-attachment-id="56681" data-permalink="https://blog.logrocket.com/new-features-in-next-js-11/lazy-onload-polyfill/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill.png" data-orig-size="730,326" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="lazy-on-load-polyfill" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill.png" decoding="async" class="aligncenter wp-image-56681 size-full jetpack-lazy-image" src="../Images/809a15c23be3e2b61a79d0ea8e71b2e5.png" alt="Lazy On Load Polyfill" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill-300x134.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56681" data-permalink="https://blog.logrocket.com/new-features-in-next-js-11/lazy-onload-polyfill/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill.png" data-orig-size="730,326" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="lazy-on-load-polyfill" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill-300x134.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill.png" decoding="async" loading="lazy" class="aligncenter wp-image-56681 size-full" src="../Images/809a15c23be3e2b61a79d0ea8e71b2e5.png" alt="Lazy On Load Polyfill" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill-300x134.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/lazy-onload-polyfill.png"/></noscript>
<h3><code>onLoad</code>支柱</h3>
<p>除了上面的定制之外，如果我们想在脚本加载后执行一些代码，我们可以对脚本标签使用<code>onLoad</code>属性。<code>onLoad</code> prop 确保上面的脚本已经加载，允许函数使用脚本的特性和变量而不会崩溃:</p>
<pre>&lt;Script
  id="my-script"
src="https://polyfill.io/v3/polyfill.min.js?features=WebAnimations"
  onLoad={() =&gt; {
    // this executes after the script is loaded
  }}
/&gt;
</pre>
<h2 id="imageimprovements">形象改善</h2>
<p>Next.js 11 包含了对<code>next/image</code>组件的增强，比如减少布局偏移的<a href="https://blog.logrocket.com/fix-layout-shifts-improve-seo-next-js/">和为最终用户提供更流畅体验的</a>。</p>
<h3>静态图像的尺寸检测</h3>
<p>以前，要使用<code>Image</code>组件渲染图像，必须使用<code>height</code>和<code>width</code>道具。这些道具允许 Next.js 识别图像的大小并呈现占位符，防止布局偏移和混乱的用户界面:</p>
<pre>&lt;Image
  alt="Fixing"
  src="/fixing.png"
  layout="intrinsic"
  width={700}
  height={475}
/&gt;
</pre>
<p>Next.js 11 提供了对<code>src</code> prop 的支持，可以使用<code>import</code>关键字来应用它。如果以这种方式导入源，您不需要分别指定<code>height</code>和<code>width</code>道具:</p>
<pre>import source from '../public/fixing.png'
&lt;Image
  alt="Fixing"
  src={source}
  layout="intrinsic"
/&gt;
</pre>
<h3>图像占位符</h3>
<p>在 Next.js 11 中，<code>next/image</code>组件支持一个新的占位符属性，该属性在较慢的连接上将<code>value</code>设置为<code>blur</code>。在加载原始图像时，<code>next/image</code>组件将显示模糊的低分辨率图像:</p>
<pre>&lt;Image
  alt="Fixing"
  src={source}
  layout="intrinsic"
  placeholder="blur"
/&gt;
</pre>
<p>在原始图像最终加载之前，模糊图像将显示两到三秒钟。</p>
<p>此外，Next.js 11 提供了一个选项，通过<code>Image</code>标签提供一个定制的占位符，可以使用<code>blurDataURL</code> prop 来显示。提供给这个道具的值可以使用类似<a href="https://blurha.sh/"> <strong> blurha.sh </strong> </a> <strong>的应用程序生成。</strong></p>
<h2 id="webpack5defaultsupport">Webpack 5 默认支持</h2>
<p>在 10.2 版本中，宣布对所有 Next.js 项目提供 Webpack 5 支持，这些项目的<code>next.config.js</code>文件中没有自定义 Webpack 配置。自定义 webpack 配置类似于下面的代码:</p>
<pre>module.exports = {
  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) =&gt; {
    return config; // return the modified config
  },
}
</pre>
<p>从版本 11 开始，webpack 5 是所有 Next.js 应用程序的默认构建工具，与定制配置无关。webpack 5 附带的以下所有优化将可用于新构建的项目。</p>
<h3>改进的磁盘缓存</h3>
<p>我们知道可以使用命令<code>next build</code>来触发构建。但是如果我们为项目触发的两个连续的构建之间没有什么变化呢？</p>
<p>Webpack 5 只允许有条件地重新编译已经更改的文件。性能得到了提高，因为我们没有冗余地处理没有被改变的块。</p>
<h3>改进的快速刷新</h3>
<p>有了 webpack 5，Next.js 11 将快速刷新识别为一项特殊任务，并以更高的优先级执行它，从而在每次保存任何代码更改时实现更快的刷新。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h3>长期资产缓存</h3>
<p>有了 webpack 5，<code>build</code>命令的构建过程是确定的。如果代码段没有改变，则后续构建中生成的哈希不会改变，这意味着浏览器中经过哈希处理的文件可以在更长时间内重用。</p>
<h3>改进的树摇动</h3>
<p>Webpack 5 提供了树摇动<code>commonJS</code>模块的能力，从包中移除未使用的代码。</p>
<h2 id="migrationfromcreatereactapp">从创建 React 应用程序迁移</h2>
<p>由于社区的要求，Vercel 团队已经推出了<code>@next/codemod</code>工具，它支持 React 和 Next.js 项目之间的兼容性。</p>
<p>我们可以运行该工具，为它提供一个使用 Create React App 脚本生成的项目，并将其转换为 Next.js 项目。我们来试试吧！</p>
<p>首先，使用以下命令创建一个 React 应用程序:</p>
<pre>npx create-react-app cra-demo
</pre>
<p>现在，我们已经初始化了一个新的 React 项目，我们可以使用命令运行我们的项目:</p>
<pre>npm run start
</pre>
<p>您将看到熟悉的 React 屏幕:</p>
<p><img data-attachment-id="56684" data-permalink="https://blog.logrocket.com/new-features-in-next-js-11/react-loading-screen/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-loading-screen" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen.png" decoding="async" class="aligncenter wp-image-56684 size-full jetpack-lazy-image" src="../Images/e9f6eac8031a85233f06633cf5b16702.png" alt="React Loading Screen" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen-300x159.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="56684" data-permalink="https://blog.logrocket.com/new-features-in-next-js-11/react-loading-screen/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen.png" data-orig-size="730,386" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-loading-screen" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen.png" decoding="async" loading="lazy" class="aligncenter wp-image-56684 size-full" src="../Images/e9f6eac8031a85233f06633cf5b16702.png" alt="React Loading Screen" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen-300x159.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/react-loading-screen.png"/></noscript>
<p>接下来，运行脚本从 Create React App 迁移到 Next.js 项目:</p>
<pre>npx @next/codemod cra-to-next cra-demo
</pre>
<p>我们可以看到，该脚本对存储库进行了一些修改，以将其移植到 Next.js。</p>
<ul>
<li>更改<code>package.json</code>中的脚本</li>
<li>添加了<code>pages</code>文件夹，这是 Next.js repo 的一个主要特性</li>
<li>通过创建一个<code>_app.js</code>文件来改变 CSS 的导入方式</li>
<li>创建一个<code>next.config.js</code>文件并填充它</li>
</ul>
<h2 id="babeloptimization">巴别塔优化</h2>
<p>Next.js 11 采用了 webpack 的<a href="https://nextjs.org/blog/next-11#improved-performance"> Babel loader、</a>的全新实现，它包括一个内存中的配置缓存层，从 10.1 和 10.2 版本的改进中进一步减少了启动时间。</p>
<h2 id="nextjslive">Next.js Live</h2>
<p>Vercel 的团队已经使用了几种下一代前端技术，如 serviceWorker、WebAssembly 和 es 模块，以在浏览器中提供协作环境。使用 Next.js Live 特性，开发人员和设计人员只需共享一个 URL 就可以进行协作。实况特征是当前在早期访问下运行的<a href="https://nextjs.org/live">。</a></p>
<h2 id="conclusion">结论</h2>
<p>很明显，这些升级构成了有史以来最突出的 Next.js 版本之一！</p>
<p>对核心进行了一些更改，减少了启动时间，比如 Babel 优化，以及一些一致性建议，将开发人员推向一个成熟的解决方案。其他改进是加载图像和脚本，使用户体验无缝。此外，我们现在能够使用实时功能改进协作。</p>
<p>出于这些原因以及更多原因，Next.js 11 版本看起来很有前途，值得升级。试试吧，在评论中告诉我们你的想法！</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产 Next.js 应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示 JavaScript 错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你的 Next.js 应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用程序的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p><p>让您调试 Next.js 应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
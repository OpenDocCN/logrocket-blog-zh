<html>
<head>
<title>Comparing Node.js logging tools - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较 Node.js 日志工具- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-node-js-logging-tools/#0001-01-01">https://blog.logrocket.com/comparing-node-js-logging-tools/#0001-01-01</a></blockquote><div><article class="article-post">
<p>日志是软件工程中的一个重要概念。通过写出应用程序中发生的事件的审计，日志为开发人员提供了理解应用程序代码实际做什么的洞察力。</p>
<p>在本文中，我们将比较 Node.js 的不同日志工具，包括:</p>

<p>但是在我们进行比较之前，让我们深入了解一下日志记录的元素。</p>
<h2>我们为什么要记录？</h2>
<p>在任何应用程序中使用日志时，了解日志记录级别非常重要。日志记录级别是一种根据紧急程度和显示方式对日志文件中的条目进行分类的方式。</p>
<p>每个定义的日志消息都有一个相关联的日志级别，该日志级别为消息的重要性和紧急程度提供了粗略的指导。Nodejs 中最常见的日志记录级别有:</p>
<ul>
<li><code>ERROR</code></li>
<li><code>INFO</code></li>
<li><code>DEBUG</code></li>
<li><code>WARN</code></li>
<li><code>FATAL</code></li>
</ul>
<p>每个日志级别都有自己的用例以及如何应用它们。</p>
<h3><code>ERROR</code>日志级别</h3>
<p><code>ERROR</code>级表示必须处理的严重问题。它指定可能仍然允许应用程序继续运行的错误事件。</p>
<h3><code>INFO</code>日志级别</h3>
<p>此日志级别跟踪已发生的事件。假设系统的其余部分继续正常运行，通常可以忽略这些警报。</p>
<p>它基本上指示了信息性消息，这些消息在粒度级别上突出了应用程序的进度。</p>
<h3><code>DEBUG</code>日志级别</h3>
<p><code>DEBUG</code>日志级别包含的信息只在调试阶段有用，在生产过程中可能没有什么价值。它们基本上是在调试应用程序时最有用的信息事件。</p>
<h3><code>WARN</code>日志级别</h3>
<p><code>WARN</code>日志级别比错误条件稍微不那么严重，因为它们指示潜在的有害情况。该消息表明应用程序中发生了意外事件，可能会中断或延迟其他进程。</p>
<h3><code>FATAL</code>日志级别</h3>
<p>此日志级别表示可能导致应用程序中止的非常严重的错误事件。</p>
<h2>Node.js 日志库</h2>
<p>现在我们已经了解了不同的日志级别，我们可以深入了解 Node.js 中不同的日志工具，以及如何在我们的应用程序中使用它们。</p>
<h3 id="bunyan">班扬</h3>
<p><a href="https://www.npmjs.com/package/bunyan">班扬是</a>节点<a href="https://www.npmjs.com/package/bunyan">非常流行的测井工具。</a> <a href="https://www.npmjs.com/package/bunyan"> js </a>。这是一个用于 Node.js 服务的简单快速的 JSON 日志库，提供了一个漂亮的日志 CLI 视图，用不同的颜色描述不同的日志级别。</p>
<p><img data-attachment-id="70371" data-permalink="https://blog.logrocket.com/comparing-node-js-logging-tools/bunyan-interface/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface.png" data-orig-size="730,52" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Bunyan interface" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface-300x21.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface.png" decoding="async" class="aligncenter size-full wp-image-70371 jetpack-lazy-image" src="../Images/7243b849170949a82ff0b716f7a23443.png" alt="Bunyan Interface Showing Different Coloring For Code" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface-300x21.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="70371" data-permalink="https://blog.logrocket.com/comparing-node-js-logging-tools/bunyan-interface/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface.png" data-orig-size="730,52" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Bunyan interface" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface-300x21.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-70371" src="../Images/7243b849170949a82ff0b716f7a23443.png" alt="Bunyan Interface Showing Different Coloring For Code" srcset="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface-300x21.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/Bunyan-interface.png"/></noscript>
<h4>安装 Bunyan</h4>
<p>要安装 Bunyan，请将以下内容添加到您的终端:</p>
<pre>npm i bunyan
</pre>
<h4>使用班扬语</h4>
<p>要使用 Bunyan 开始日志记录，创建一个<code>test.js</code>文件并添加以下代码用于测试目的:</p>
<pre>const bunyan = require('bunyan');
</pre>
<p>在需要这个包之后，我们必须使用<code>createLogger</code>方法定义一个日志记录器的实例:</p>
<pre>var log = bunyan.createLogger({
  name: '&lt;name of application',
  stream: process.stdout
});
</pre>
<p>然后我们可以使用 Bunyan 来记录数据:</p>
<pre>log.info('hi');
</pre>
<p>如果我们运行我们的<code>test.js</code>文件，我们会在控制台中得到这个输出:</p>
<pre>{"name":"myapp","hostname":"banana.local","pid":40161,"level":30,"msg":"hi","time":"2013-01-04T18:46:23.851Z","v":0}
</pre>
<p>这里很明显，Bunyan 主张日志应该是 JSON 格式的，并且每个日志都带有日志创建的日期。Node.js 中的一个常见做法是将这些日志实体存储在一个文件中以供参考。</p>
<h4>班扬的好处</h4>
<p>除了 Node.js 之外，Bunyan 还支持多种运行时，如<a href="https://blog.logrocket.com/changes-coming-to-webpack-in-2021/"> Webpack </a>，Browserify 和 NW.js</p>
<p>Bunyan 还有序列化的概念，即函数从 JavaScript 对象产生一个 JSON-able 对象。这里，一个特定的 logger 实例可以有一个<code>serializer</code>，它将日志记录字段名称映射到一个序列化函数。</p>
<p>使用子日志记录，开发人员可以为应用程序的子组件专门设计一个日志记录器，比如创建一个新的日志记录器，在其日志记录中包含附加的绑定字段。</p>
<h3 id="winston">温斯顿</h3>
<p>Winston 是一个顶级的 Node.js 日志库<a href="https://github.com/winstonjs/winston">，由于其庞大的社区和功能，在撰写本文时，GitHub </a>上有超过 17k 颗星。</p>
<p>Winston 分离了日志记录的各个部分，通过大量的配置使其具有可扩展性和灵活性，从而实现无缝开发。</p>
<h4>安装 Winston</h4>
<p>要安装 Bunyan，请将以下内容添加到您的终端:</p>
<pre>npm i winston
</pre>
<h4>利用温斯顿</h4>
<p>安装库之后，我们必须在我们的根文件中需要该库，并创建它的一个实例:</p>
<pre>const winston = require('winston');
const logger = winston.createLogger({})
</pre>
<p><code>createLogger</code>方法可以保存很多配置，比如日志级别、格式和元描述:</p>
<pre>const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  defaultMeta: { service: '&lt;service&gt;' },
});
</pre>
<p>此外，我们可以通过将文件包含在<code>transport</code>数组中来指定一个文件，所有日志都将写入该文件:</p>
<pre>const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  defaultMeta: { service: 'user-service' },
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});
</pre>
<p>在这里，我们设置所有具有错误日志级别的日志必须写入<code>error.log</code>文件，而所有其他日志必须写入<code>combined.log</code>文件。</p>
<p>我们还可以选择在控制台中仅显示我们的日志，方法是在<code>transport</code>数组中使用以下配置:</p>
<pre>new winston.transports.Console()
</pre>
<p>要获得 Winston 提供的所有方法，<a href="https://www.npmjs.com/package/winston">您可以参考文档</a>。</p>
<h4>温斯顿福利</h4>
<p>Winston 能够将日志发送到其他云日志服务，如<a href="http://logz.io"> logz.io </a>和<a href="https://www.npmjs.com/package/winston-cloudwatch"> AWS Cloudwatch </a>，而不是将日志存储在静态文件中或记录在控制台上。</p>
<p>因为每个日志都有时间戳和日志级别，所以可以根据任何事件轻松跟踪日志。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h3 id="pino">皮诺</h3>
<p>Pino 标榜自己是一个“开销非常低”的 Node.js 日志记录器，因为它使用最少的资源进行日志记录。使用 Pino，记录的消息会随着时间的推移而增加，从而对应用程序产生节流效应，例如减少每秒请求数。</p>
<p>节流是一种方法，无论用户触发事件多少次，附属函数在给定的时间间隔内只执行一次。</p>
<h4>安装 Pino</h4>
<p>要安装 Pino，请将以下内容添加到您的终端:</p>
<pre>npm i pino
</pre>
<h4>使用 Pino</h4>
<p>使用这个库非常简单明了。您所要做的就是请求库并初始化它:</p>
<pre>const logger = require('pino')()

logger.info('hello world')
</pre>
<p>运行此脚本会在控制台上产生以下内容:</p>
<pre>{"level":30,"time":1531171074631,"msg":"hello world","pid":657,"hostname":"Davids-MBP-3.fritz.box"}
</pre>
<p>控制台上记录的数据包括日志级别、记录数据的时间、日志的实际消息、日志的<code>id</code>和主机。</p>
<h4>在 Express.js 中使用 Pino</h4>
<p>您也可以通过安装此软件包在 Express.js 应用程序中使用 Pino:</p>
<pre>npm install pino-http
</pre>
<p>安装这个库之后，您可以在您的 Express.js 应用程序中使用它，如下所示:</p>
<pre>const express = require('express')
const pino = require('pino-http')

const app = express();
const pinoInstance = pino()

app.use(pinoInstance);

app.post('/do-stuff', (req,res) =&gt; {
  req.log.info('Something done');
  res.send('Say hello to Pino')
})

app.listen(5500)
</pre>
<h4>皮诺的好处</h4>
<p>Pino 有一个模块提供了一个名为<code>pino-pretty</code>的基本 NDJSON 格式化程序。</p>
<p>换行符分隔的 JSON(或 NDJSON)是一种存储或流式传输结构化数据的方便格式，一次可以处理一条记录。考虑到日志级别和时间戳等因素，所有记录的数据都会应用额外的格式。</p>
<p>您可以将<code>pino-pretty</code>安装在您的项目上，或者全局安装在您的本地机器上。</p>
<p>要安装<code>pino-pretty</code>，请运行以下命令:</p>
<pre>npm install -g pino-pretty
</pre>
<p>安装后，您可以使用以下命令运行应用程序:</p>
<pre>node app.js | pino-pretty
</pre>
<h3 id="morgan">摩根</h3>
<p>Morgan 是一个 Node.js 库，用于记录 HTTP 请求。它通常作为中间件添加，这样它可以跟踪所有的请求。与其他日志记录工具不同，它的主要功能是记录 HTTP 请求。</p>
<h4>安装摩根</h4>
<p>要安装 Morgan，请将以下内容添加到您的终端:</p>
<pre>npm i morgan
</pre>
<h4>利用摩根</h4>
<p>安装后，您必须需要该库，然后将其作为 Express.js 中间件添加:</p>
<pre>var morgan = require('morgan')

app.use(morgan('dev'))
</pre>
<p>传递的<code>dev</code>是摩根格式。Morgan 实现了五种日志格式:</p>
<ol>
<li><code>combined</code>，它使用标准的 Apache 组合日志输出</li>
<li><code>common</code>，它使用标准的 Apache 组合日志输出</li>
<li><code>dev</code>，使用由响应状态着色的简明输出，供开发使用</li>
<li><code>short</code>，默认包含响应时间并缩短日志</li>
<li><code>tiny</code>，使用最小输出</li>
</ol>
<p>然后，您可以使用如下所示的格式:</p>
<pre>app.use(morgan('combined'))
app.use(morgan('common'))
app.use(morgan('dev'))
app.use(morgan('short'))
app.use(morgan('tiny'))
</pre>
<h4>摩根福利</h4>
<p>无需编写额外的配置代码，Morgan 使您能够根据您的需求选择任何预定义的格式，从而节省您的时间。</p>
<h3 id="npmlog">npmlog</h3>
<p>这是 npm 使用的官方记录器实用程序。就像其他 Node.js 日志库一样，它支持自定义级别、彩色输出，并允许您为不同的日志级别设置不同的颜色。</p>
<h4>正在安装 npmlog</h4>
<p>要安装 Npmlog，请将以下内容添加到您的终端:</p>
<pre>npm i npmlog
</pre>
<h4>使用 npmlog</h4>
<p>要开始使用这个库，创建一个测试文件，然后需要这个包:</p>
<pre>const log = require('npmlog');
log.info('Wisdom Ekpot', 'Hello from logrocket', {'message': 'test'})
</pre>
<p><code>log.info</code>在控制台或文件上记录数据，它最多可以接受三个参数:</p>
<ul>
<li>第一个参数:日志的前缀</li>
<li>第二个参数:实际的日志消息</li>
<li>第三个参数:日志的附加数据</li>
</ul>
<h4>npmlog 优势</h4>
<p>就像其他日志记录工具一样，npmlog 附带了许多简化开发的方法，比如设置日志标题、标题样式和定义日志级别。</p>
<h2>Node.js 日志库的统计信息</h2>
<p>下面是我们在本文中介绍的 Node.js 日志库的快速比较；在发表本文时，所有数据都是准确的。</p>
<h4>图书馆</h4>
<table class="tg">
<thead>
<tr>
<th class="tg-1wig">每周下载次数</th>
<th class="tg-1wig">Github stars</th>
<th class="tg-1wig">Github forks</th>
<th class="tg-1wig">班扬</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-0lax">1,568,274</td>
<td class="tg-0lax">6.7k</td>
<td class="tg-0lax">522</td>
<td class="tg-0lax">温斯顿</td>
</tr>
<tr>
<td class="tg-0lax">6,364,282</td>
<td class="tg-0lax">17.8k</td>
<td class="tg-0lax">1.6k</td>
<td class="tg-0lax">皮诺</td>
</tr>
<tr>
<td class="tg-0lax">1,836,807</td>
<td class="tg-0lax">7.8k</td>
<td class="tg-0lax">530</td>
<td class="tg-0lax">摩根</td>
</tr>
<tr>
<td class="tg-0lax">2 873 389</td>
<td class="tg-0lax">六点七 k</td>
<td class="tg-0lax">485</td>
<td class="tg-0lax">npmlog 公司</td>
</tr>
<tr>
<td class="tg-0lax">13,220,573</td>
<td class="tg-0lax">358</td>
<td class="tg-0lax">55</td>
<td class="tg-0lax">结论</td>
</tr>
</tbody>
</table>
<h2>浏览所有这些 Node.js 日志记录工具，它表明在我们的任何 Node.js 项目中实现日志记录都非常简单和直接。通常建议使用适合您的应用程序目的并显示实际所需数据的库。</h2>
<p>200 只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>部署基于节点的 web 应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
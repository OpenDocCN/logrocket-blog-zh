<html>
<head>
<title>Form validation in Svelte - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>苗条日志博客中的表单验证</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/form-validation-in-svelte/#0001-01-01">https://blog.logrocket.com/form-validation-in-svelte/#0001-01-01</a></blockquote><div><article class="article-post">
<p>表单仍然是用户与 web 交互的不可或缺的一部分。在处理表单时，我们必须处理跟踪用户输入、验证和显示错误，以及处理表单提交。</p>
<p/>
<p>在本文中，我们将了解输入绑定如何在 Svelte 中工作，如何用 Yup 验证表单，以及<code>svelte-forms-lib</code>如何使管理表单变得更容易。我们还将构建一个样本表单，并用这些工具来验证它，以展示在 Svelte 中构建和验证表单时的许多选项。</p>
<h2>理解苗条的输入绑定</h2>
<p>我们需要一种方法来跟踪和存储作为用户类型的输入字段的值。Svelte 提供了两个指令来实现这个目标:<code>on:input</code>和<code>bind</code>。</p>
<h3><code>on:input</code></h3>
<p>每当发生输入事件时，都会调用此事件侦听器:</p>
<pre>&lt;script&gt;
  let email = "";
  const handleInput = (e) =&gt; {
    email = e.target.value;
  };
&lt;/script&gt;

&lt;input type="email" name="email" on:input={handleInput} /&gt;
&lt;p&gt;{email}&lt;/p&gt;
</pre>
<p>在上面的代码中，我们定义了一个<code>handleInput</code>并将其传递给电子邮件输入字段。每当用户输入时，<code>email</code>变量就会用字段的值进行更新。</p>
<h3><code>bind:value</code></h3>
<p><code>bind</code>指令是一种在 Svelte 中跟踪表单值的更干净的方法:</p>
<pre>&lt;input type="email" name="email" bind:value={email} /&gt;
</pre>
<p>不需要创建一个<code>handleInput</code>事件，也不需要为给定表单中的每个输入字段设置<code>event.target.value</code>,<code>bind</code>会为我们处理，每当我们填充输入时，<code>email</code>变量就会更新。</p>
<p>在本文中，我们将使用<code>bind</code>指令来跟踪和存储表单值，因为这是一种更简单的工作方式。</p>
<h2>用“是”验证</h2>
<p>是一个 JavaScript 对象模式验证器。Yup 确保对象中的数据符合我们的要求:</p>
<pre>import * as yup from 'yup';

let values = {
    email: "",
    password: "",
    confirmPassword: "",
    hobby: "",
    checkbox: false,
};

const schema = yup.object().shape({
  email: yup.string().required("Email is required")
    .email("Email is invalid"),
  password: yup.string().required("Password is required"),
  confirmPassword: yup.string().required("Please confirm your password")
    .oneOf([yup.ref("password"), null], "Passwords do not match"),
  hobby: yup.string().required("Hobby is required"),
  checkbox: yup.bool().required("Checkbox must be accepted")
    .oneOf([true], "Checkbox must be accepted"),
});

const validationResult = schema
    .validate(values, { abortEarly: false })
    .then(() =&gt; {
      alert(JSON.stringify(values, null, 2));
    })
    .catch((err) =&gt; {
      console.log(err.errors);
    });

    //console.log message 
    //[ "Email is invalid", "Passwords do not match", "Hobby is required", "Che//ckbox must be accepted" ]
</pre>
<p>在<code>schema</code>中，我们定义了我们希望表单值的数据是什么样子。这确保了发送到服务器的数据是有效的。</p>
<p>我们使用其<code>validate</code>方法来验证 Yup 中的对象。我们可以在我们定义的任何模式上调用这个方法。</p>
<h2>创建配置文件表单</h2>
<p>现在我们已经了解了表单绑定如何在 Svelte 中工作，以及 Yup 如何验证对象值，让我们设置一个样本 profile 表单并验证它:</p>
<pre>&lt;script&gt;
  import schema from './schema';
  let values = {
    //store form data that will then be validated
  };

  const handleSubmit = () =&gt; {
    //validate form and submit data
  };
&lt;/script&gt;

&lt;div class="container"&gt;
  &lt;h1&gt;Profile Form&lt;/h1&gt;
  &lt;form on:submit|preventDefault={handleSubmit}&gt;
    &lt;div&gt;
      &lt;input type="text" name="email" bind:value={values.email} 
        placeholder="Email"
      /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input type="password" name="password" bind:value={values.password}
        placeholder="Password"
      /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input type="password" name="confirmPassword"
        bind:value={values.confirmPassword}
        placeholder="Confirm password"
      /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;select name="hobby" bind:value={values.hobby}&gt;
        &lt;option value=""&gt;Select a hobby&lt;/option&gt;
        &lt;option value="Eating"&gt;Eating&lt;/option&gt;
        &lt;option value="Reading"&gt;Reading&lt;/option&gt;
        &lt;option value="Sleeping"&gt;Sleeping&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;label for="checkbox"&gt;Check this box&lt;/label&gt;
      &lt;input name="checkbox" type="checkbox" bind:checked={values.checkbox} /&gt;
    &lt;/div&gt;
  &lt;/form&gt;
&lt;/div&gt;
</pre>
<p>我们首先设置一个简单的 profile 表单来捕获用户数据。我们将表单字段绑定到一个<code>values</code>对象。这个对象是我们存储表单数据的地方。</p>
<h2>验证配置文件表单</h2>
<p>既然我们已经创建了概要文件表单，我们需要验证它。</p>
<p>与我们将错误记录到控制台时所做的不同，我们希望将它们显示给用户看:</p>
<pre>&lt;script&gt;
  let errors = {};

  const handleSubmit = async () =&gt; {
    try {
      await schema.validate(values, { abortEarly: false });
      alert(JSON.stringify(values, null, 2));
      errors = {};
    } catch (err) {
      errors = err.inner.reduce((acc, err) =&gt; {
        return { ...acc, [err.path]: err.message };
      }, {});
    }
  };
&lt;/script&gt;
</pre>
<p>在这个代码块中，我们创建了一个<code>errors</code>对象，用于存储从<code>validate</code>调用中返回的错误。然后，我们创建一个异步函数，<code>handleSubmit</code>。在这里，我们将处理表单验证和提交。</p>
<p>我们将想要验证的数据传递给这个方法。在这种情况下，我们将验证从表单收到的<code>values</code>。</p>
<p><code>Validate</code>可以带第二个参数，一个 options 对象。默认情况下，验证在出现第一个错误时返回。为了获得所有返回的错误，我们必须将<code>abortEarly</code>设置为<code>false</code>。</p>
<p>如果没有错误，我们将显示表单值。如果有，我们显示错误。但是，在显示错误之前，我们必须访问它们:</p>
<pre>errors = err.inner.reduce((acc, err) =&gt; {
  return { ...acc, [err.path]: err.message };
}, {});
</pre>
<p>为了访问错误，我们遍历 Yup 的验证<code>error.inner</code>数组，并返回一个由字段及其错误消息组成的新对象。然后，我们用每个相应输入字段的错误更新<code>errors</code>对象。</p>
<h2>显示验证错误</h2>
<p>现在我们有了保存每个输入字段错误的<code>errors</code>对象，我们需要显示它们:</p>
<pre> &lt;div&gt;
      &lt;input type="email" /&gt;
      {#if errors.email}
        &lt;span class="error"&gt;{errors.email}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input type="password" /&gt;
      {#if errors.password}
        &lt;span class="error"&gt;{errors.password}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input type="password" /&gt;
      {#if errors.confirmPassword}
        &lt;span class="error"&gt;{errors.confirmPassword}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
    &lt;div&gt;
      &lt;select name="hobby" bind:value={values.hobby}&gt;
        &lt;option value=""&gt;Select a hobby&lt;/option&gt;
        &lt;option value="Eating"&gt;Eating&lt;/option&gt;
        &lt;option value="Reading"&gt;Reading&lt;/option&gt;
        &lt;option value="Sleeping"&gt;Sleeping&lt;/option&gt;
      &lt;/select&gt;
      {#if errors.hobby}
        &lt;span class="error"&gt;{errors.hobby}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input name="checkbox" type="checkbox" bind:checked={values.checkbox} /&gt;
      {#if errors.checkbox}
        &lt;span class="error"&gt;{errors.checkbox}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
</pre>
<p>我们设置了一个<code>if</code>块来处理显示错误。如果特定字段存在错误，我们将显示该字段的错误。这个 CodeSandbox 链接保存了这个部分的代码。</p>
<h2>用<code>svelte-forms-lib</code>确认</h2>
<p>是一个受 Formik 启发的库，用于在一个苗条的项目中轻松构建表单。</p>
<p>您可以安装<code>svelte-forms-lib</code>及以下内容:</p>
<pre>npm i svelte-forms-lib
</pre>
<p>首先，我们从<code>svelte-forms-lib</code>导入<code>createForm</code>函数:</p>
<pre>import { createForm } from "svelte-forms-lib";
</pre>
<p>这个函数是将<code>svelte-forms-lib</code>集成到表单中的核心部分。</p>
<p><code>CreateForm</code>让我们访问有用的表单帮助，比如<code>handleChange</code>和<code>handleSubmit</code>，等等。我们将需要这些助手函数来设置表单:</p>
<pre>&lt;script&gt;
  import { createForm } from "svelte-forms-lib";
  const { form, handleChange, handleSubmit } = createForm({
    initialValues: {
      email: "",
      password: "",
      confirmPassword: "",
      hobby: "",
      checkbox: "",
    },
    onSubmit: (values) =&gt; {
      alert(JSON.stringify(values));
    },
  });
&lt;/script&gt;
&lt;div class="container"&gt;
  &lt;h1&gt;Registration Form&lt;/h1&gt;
  &lt;form on:submit|preventDefault={handleSubmit}&gt;
    &lt;div&gt;
      &lt;input
        type="text"
        name="email"
        bind:value={$form.email}
        placeholder="Email"
        on:change={handleChange}
      /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input
        type="password"
        name="password"
        bind:value={$form.password}
        placeholder="Password"
        on:change={handleChange}
      /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input
        type="password"
        name="confirmPassword"
        bind:value={$form.confirmPassword}
        placeholder="Confirm password"
        on:change={handleChange}
      /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;select name="hobby" bind:value={$form.hobby} on:blur={handleChange}&gt;
        &lt;option value=""&gt;Select a hobby&lt;/option&gt;
        &lt;option value="Eating"&gt;Eating&lt;/option&gt;
        &lt;option value="Reading"&gt;Reading&lt;/option&gt;
        &lt;option value="Sleeping"&gt;Sleeping&lt;/option&gt;
      &lt;/select&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;label for="checkbox"&gt;Check this box&lt;/label&gt;
      &lt;input
        name="checkbox"
        type="checkbox"
        bind:checked={$form.checkbox}
        on:change={handleChange}
      /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;button type="submit"&gt;Register&lt;/button&gt;
    &lt;/div&gt;
  &lt;/form&gt;
&lt;/div&gt;
</pre>
<p>除了帮助函数，<code>svelte-forms-lib</code>还公开了可观察的值，这些值为我们提供了表单当前状态的信息。在本文中，我们将集中讨论如何使用<code>form</code>和<code>errors</code>可观测值。然而，你可以在这里查看<a href="https://svelte-forms-lib-sapper-docs.vercel.app/observables">可观测到的</a>的完整列表。</p>
<p>我们将一个配置对象作为参数传递给<code>createForm</code>。这里，我们定义了表单的<code>initialValues</code>和一个将处理表单提交的<code>onSubmit</code>处理器。</p>
<p>配置完<code>createForm</code>后，我们需要将概要文件表单挂接到<code>svelte-forms-lib</code>，这样它就可以跟踪表单值并处理提交。</p>
<p>为此，我们将<code>handleSubmit</code>助手传递给<code>form</code>元素。我们还将<code>handleChange</code>传递给输入字段，将<code>bind</code>的值传递给<code>form</code>可观察值。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h2><code>svelte-forms-lib</code>中的自定义验证</h2>
<p>现在我们知道了如何将<code>svelte-forms-lib</code>集成到表单中，我们需要处理表单验证:</p>
<pre>&lt;script&gt;
  import { createForm } from "svelte-forms-lib";
  const { form, errors, handleChange, handleSubmit } = createForm({
    initialValues: {},
    validate: (values) =&gt; {
      let errors = {};
      if (!values.email) {
        errors.email = "Email is Required";
      } else if (!/^[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="dfac9f">[email protected]</a>]<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="240f64">[email protected]</a>[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e192a1">[email protected]</a>]+\.[^\<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1f6c5f">[email protected]</a>]+$/.test(values.email)) {
        errors.email = "Invalid emaill address";
      }
      if (!values.password) {
        errors["password"] = "password is required";
      }
      if (!values.confirmPassword) {
        errors["confirmPassword"] = "confirm password is required";
      } else if (values.confirmPassword !== values.password) {
        errors["confirmPassword"] = "password does not match";
      }
      if (!values.hobby) {
        errors["hobby"] = "hobby is required";
      }
      if (!values.checkbox) {
        errors.checkbox = "You must accept our terms";
      }
      return errors;
    },
    onSubmit: (values) =&gt; {
      alert(JSON.stringify(values));
    },
  });
&lt;/script&gt;
&lt;div class="container"&gt;
  &lt;h1&gt;Registration Form&lt;/h1&gt;
  &lt;form on:submit|preventDefault={handleSubmit}&gt;
    &lt;div&gt;
      &lt;input
        type="text"
        name="email"
        bind:value={$form.email}
        placeholder="Email"
        on:change={handleChange}
      /&gt;
      {#if $errors.email}
        &lt;span class="error"&gt;{$errors.email}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input
        type="password"
        name="password"
        bind:value={$form.password}
        placeholder="Password"
        on:change={handleChange}
      /&gt;
      {#if $errors.password}
        &lt;span class="error"&gt;{$errors.password}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
    &lt;div&gt;
      &lt;input
        type="password"
        name="confirmPassword"
        bind:value={$form.confirmPassword}
        placeholder="Confirm password"
        on:change={handleChange}
      /&gt;
      {#if $errors.confirmPassword}
        &lt;span class="error"&gt;{$errors.confirmPassword}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
    &lt;div&gt;
      &lt;select name="hobby" bind:value={$form.hobby} on:blur={handleChange}&gt;
        &lt;option value=""&gt;Select a hobby&lt;/option&gt;
        &lt;option value="Eating"&gt;Eating&lt;/option&gt;
        &lt;option value="Reading"&gt;Reading&lt;/option&gt;
        &lt;option value="Sleeping"&gt;Sleeping&lt;/option&gt;
      &lt;/select&gt;
      {#if $errors.hobby}
        &lt;span class="error"&gt;{$errors.hobby}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
    &lt;div&gt;
      &lt;label for="checkbox"&gt;Check this box&lt;/label&gt;
      &lt;input
        name="checkbox"
        type="checkbox"
        bind:checked={$form.checkbox}
        on:change={handleChange}
      /&gt;
      {#if $errors.checkbox}
        &lt;span class="error"&gt;{$errors.checkbox}&lt;/span&gt;
      {/if}
    &lt;/div&gt;
    &lt;div&gt;
      &lt;button type="submit"&gt;Register&lt;/button&gt;
    &lt;/div&gt;
  &lt;/form&gt;
&lt;/div&gt;
</pre>
<p>除了用一个<code>initialValues</code>对象和一个<code>onSubmit</code>函数配置<code>createForm</code>之外，我们还可以添加一个<code>validate</code>回调来处理表单验证。</p>
<p>这里，我们检查每个输入字段的状态，并基于该状态更新<code>errors</code>对象。每当任何输入字段中有错误时，我们就在一个<code>if</code>块中显示它们。</p>
<h2>是在<code>svelte-forms-lib</code>进行验证</h2>
<p>虽然我们可以为表单创建一个自定义验证，但是我们也可以选择将这个责任交给 Yup。</p>
<p>我们将使用刚刚创建的同一个<code>schema</code>验证对象:</p>
<pre>&lt;script&gt;
  import schema from "./schema";
  import { createForm } from "svelte-forms-lib";
  const { form, errors, handleChange, handleSubmit } = createForm({
    initialValues: {
      //initial values here
    },
    validationSchema: schema,
    onSubmit: (values) =&gt; {
      alert(JSON.stringify(values));
    },
  });
&lt;/script&gt;

//profile form below
</pre>
<p><code>Svelte-forms-lib</code>通过一个接受模式对象的<code>validationSchema</code> prop 为 Yup 验证提供支持。我们传入我们定义的模式。你可以在这里找到<a href="https://codesandbox.io/s/svelte-forms-lib-yup-validation-4g9y0"> CodeSandbox 的链接。</a></p>
<h2><code>svelte-forms-lib</code>中的自定义表单组件</h2>
<p>到目前为止，我们必须将<code>handleSubmit</code>传递给表单，将每个字段绑定到它们各自的值，并将<code>handleChange</code>传递给每个字段。</p>
<p>虽然这已经完成了工作，<code>svelte-forms-lib</code>提供了一种更好的、更少重复的处理表单的方式:定制组件。</p>
<p>这些组件将减少样板文件，使表单代码非常简洁:</p>
<pre>&lt;script&gt;
  import { Form, Field, ErrorMessage, Select } from "svelte-forms-lib";
  import schema from "./schema";
  const formProps = {
    initialValues: {},
    validationSchema: schema,
    onSubmit: (values) =&gt; {
      alert(JSON.stringify(values));
    },
  };
&lt;/script&gt;
&lt;div class="container"&gt;
  &lt;h1&gt;Registration Form&lt;/h1&gt;
  &lt;Form {...formProps}&gt;
    &lt;div&gt;
      &lt;Field type="email" name="email" placeholder="Email" /&gt;
      &lt;ErrorMessage name="email" /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;Field type="password" name="password" placeholder="Password" /&gt;
      &lt;ErrorMessage name="password" /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;Field type="password" name="confirmPassword" placeholder="Password" /&gt;
      &lt;ErrorMessage name="confirmPassword" /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;Select name="hobby"&gt;
        &lt;option value=""&gt;Select a hobby&lt;/option&gt;
        &lt;option value="Eating"&gt;Eating&lt;/option&gt;
        &lt;option value="Reading"&gt;Reading&lt;/option&gt;
        &lt;option value="Sleeping"&gt;Sleeping&lt;/option&gt;
      &lt;/Select&gt;
      &lt;ErrorMessage name="hobby" /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;label for="checkbox"&gt;Check this box&lt;/label&gt;
      &lt;Field type="checkbox" name="checkbox" /&gt;
      &lt;ErrorMessage name="hobby" /&gt;
    &lt;/div&gt;
    &lt;div&gt;
      &lt;button type="submit"&gt;Register&lt;/button&gt;
    &lt;/div&gt;
  &lt;/Form&gt;
&lt;/div&gt;

//profile form below
</pre>
<p>这里，我们使用了<code>&lt;Form/&gt;</code>、<code>&lt;Field/&gt;</code>、<code>&lt;Select/&gt;</code>和<code>&lt;ErrorMessage/&gt;</code>组件。</p>
<p>我们通过我们定义的<code>formProps</code>变量将<code>initialValues</code>、<code>onSubmit</code>和<code>validationSchema</code>传递给<code>&lt;Form/&gt;</code>。<code>name</code>和<code>type</code>是<code>&lt;Field/&gt;</code>正常工作并呈现适当输入类型所必需的。</p>
<p>对于<code>&lt;ErrorMessage/&gt;</code>，我们传递我们想要跟踪的输入字段的名称，如果该输入有错误，<code>&lt;ErrorMessage/&gt;</code>将显示错误。我们不再需要自己有条件地呈现错误。</p>
<p>你可以在这里找到这个部分的链接。</p>
<h2 id="conclusion">结论</h2>
<p>创建苗条的表单既简单又复杂。在本文中，我们学习了如何在 Svelte 中跟踪和存储输入值，如何用 Yup 处理验证，<code>svelte-forms-lib</code>是如何工作的，以及如何将这个强大的库集成到表单中。</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>useState vs. useRef: Similarities, differences, and use cases - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>useState vs. useRef:相似性、差异和用例</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/usestate-vs-useref/#0001-01-01">https://blog.logrocket.com/usestate-vs-useref/#0001-01-01</a></blockquote><div><article class="article-post">
<p>这篇文章解释了 React 钩子<code>useState</code>和<code>useRef</code>。您将学习它们的基本用法，并了解两种挂钩的不同用例。</p>
<p>你可以在<a href="https://codesandbox.io/s/gifted-austin-28p3z?file=/src/App.js">代码沙箱</a>中找到这些例子。要查看不同的示例，只需修改<code>App.js:</code>中的以下代码行</p>
<pre>export default AppDemo6; // change to AppDemo&lt;Nr&gt;</pre>
<h2>理解<code>useState</code>挂钩</h2>
<p><code><a href="https://reactjs.org/docs/hooks-state.html">useState</a></code>钩子支持功能组件的组件状态开发。在 React 16.8 之前，组件局部状态只能在基于类的组件中实现。</p>
<p>看一下下面的代码。</p>
<pre>import { useState } from "react";
function AppDemo1() {
  const stateWithUpdater = useState(true);
  const darkMode = stateWithUpdater[0];
  const darkModeUpdater = stateWithUpdater[1];
  return (
    &lt;div&gt;
      &lt;p&gt;{darkMode ? "dark mode on" : "dark mode off"}&lt;/p&gt;
      &lt;button onClick={() =&gt; darkModeUpdater(!darkMode)}&gt;
        toggle dark mode
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</pre>
<p><code>useState</code>钩子返回一个包含两项的数组。在这个例子中，我们实现了一个布尔组件状态，并用<code>true</code>初始化我们的钩子。</p>
<p>只有在最初的渲染周期中才会考虑这个参数<code>useState</code>。然而，如果你需要一个计算复杂的初始值，那么你可以<a href="https://reactjs.org/docs/hooks-reference.html#lazy-initial-state">传递一个回调函数</a>来优化性能。</p>
<p>第一个数组项表示实际状态，第二个项构成状态更新器函数。<code>onClick</code>处理程序演示了如何使用更新函数(<code>darkModeUpdate</code>)来改变状态变量(<code>darkMode</code>)。像这样更新你的状态是很重要的。以下代码是非法的:</p>
<pre>darkMode = true;</pre>
<p>如果你有一些使用<code>useState</code>钩子的经验，你可能会对我的例子的语法感到疑惑。默认用法是在<a href="https://blog.logrocket.com/javascript-concepts-before-learning-react/">数组析构</a>的帮助下利用返回的数组项。</p>
<pre>const [darkMode, setDarkMode] = useState(true);</pre>
<p>提醒一下，使用任何钩子时，都要遵循<a href="https://reactjs.org/docs/hooks-rules.html">钩子</a>的规则，而不仅仅是<code>useState</code>或<code>useRef</code>规则，这一点至关重要:</p>
<ul>
<li>钩子应该只从 React 函数的顶层调用</li>
<li>不得从嵌套代码中调用挂钩(例如，循环、条件)</li>
<li>钩子也可以从自定义钩子在顶层调用</li>
</ul>
<p>现在我们已经介绍了基础知识，让我们用下面的示例代码来看看钩子的各个方面。</p>
<pre>import { useState } from "react";
import "./styles.css";
function AppDemo2() {
  console.log("render App");
  const [darkMode, setDarkMode] = useState(false);
  return (
    &lt;div className={`App ${darkMode &amp;&amp; "dark-mode"}`}&gt;
      &lt;h1&gt;The useState hook&lt;/h1&gt;
      &lt;h2&gt;Click the button to toggle the state&lt;/h2&gt;
      &lt;button
        onClick={() =&gt; {
          setDarkMode(!darkMode);
        }}
      &gt;
        toggle dark mode
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</pre>
<p>如果<code>darkMode</code>被设置为<code>true</code>，那么一个额外的 CSS 类(<code>dark-mode</code>)被添加到<code>className</code>，并且背景和文本的颜色被反转。从记录中的控制台输出可以看出，每次状态改变时，相应的组件都会被重新呈现。</p>
<figure id="attachment_50026" aria-describedby="caption-attachment-50026" class="wp-caption aligncenter"><img data-attachment-id="50026" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/component-re-render-every-state-change/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/component-re-render-every-state-change.gif" data-orig-size="524,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="App component re-renders on state change" data-image-description="" data-image-caption="&lt;p&gt;Every state change re-renders the App component.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/component-re-render-every-state-change-297x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/component-re-render-every-state-change.gif" decoding="async" class="size-full wp-image-50026 jetpack-lazy-image" src="../Images/be8570ae7a12fc56cc4beca5e6a1ddfe.png" alt="App Component Re-rendering on Every State Change" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/component-re-render-every-state-change.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/component-re-render-every-state-change.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50026" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/component-re-render-every-state-change/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/component-re-render-every-state-change.gif" data-orig-size="524,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="App component re-renders on state change" data-image-description="" data-image-caption="&lt;p&gt;Every state change re-renders the App component.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/component-re-render-every-state-change-297x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/component-re-render-every-state-change.gif" decoding="async" loading="lazy" class="size-full wp-image-50026" src="../Images/be8570ae7a12fc56cc4beca5e6a1ddfe.png" alt="App Component Re-rendering on Every State Change" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/component-re-render-every-state-change.gif"/></noscript><figcaption id="caption-attachment-50026" class="wp-caption-text">Every state change re-renders the <code>App</code> component.</figcaption></figure>
<p>在这里，React DevTools 特别有助于在组件渲染时突出显示更新。在最后一个记录中，您可以看到组件周围闪烁的边框，通知您另一个组件渲染周期。</p>
<figure id="attachment_50028" aria-describedby="caption-attachment-50028" class="wp-caption aligncenter"><img data-attachment-id="50028" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/react-devtools-highlight-option/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option.png" data-orig-size="730,289" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React DevTools highlight option" data-image-description="" data-image-caption="&lt;p&gt;Option to visually highlight re-renders.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option-300x119.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option.png" decoding="async" class="size-full wp-image-50028 jetpack-lazy-image" src="../Images/844bf391136074a5d88d1564f84efcd4.png" alt="Enabling React DevTools Option to Highlight Re-renders" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option-300x119.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="50028" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/react-devtools-highlight-option/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option.png" data-orig-size="730,289" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React DevTools highlight option" data-image-description="" data-image-caption="&lt;p&gt;Option to visually highlight re-renders.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option-300x119.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option.png" decoding="async" loading="lazy" class="size-full wp-image-50028" src="../Images/844bf391136074a5d88d1564f84efcd4.png" alt="Enabling React DevTools Option to Highlight Re-renders" srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option-300x119.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/react-devtools-highlight-option.png"/></noscript><figcaption id="caption-attachment-50028" class="wp-caption-text">Option to visually highlight re-renders.</figcaption></figure>
<p>在下一个例子中，标题被提取到一个单独的 React 组件中(<code>Description</code>)。</p>
<pre>import { useState } from "react";
import "./styles.css";
function AppDemo3() {
  console.log("render App");
  const [darkMode, setDarkMode] = useState(false);
  return (
    &lt;div className={`App ${darkMode &amp;&amp; "dark-mode"}`}&gt;
      &lt;Description /&gt;
      &lt;button
        onClick={() =&gt; {
          setDarkMode(!darkMode);
        }}
      &gt;
        toggle dark mode
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
const Description = () =&gt; {
  console.log("render Description");
  return (
    &lt;&gt;
      &lt;h1&gt;The useState hook&lt;/h1&gt;
      &lt;h2&gt;Click the button to toggle the state&lt;/h2&gt;
    &lt;/&gt;
  );
};</pre>
<p>每当用户单击按钮时，<code>App</code>组件就会被呈现，因为相应的 click 处理程序会更新<code>darkMode</code>状态变量。此外，子组件<code>Description</code>也得到了渲染。</p>
<figure id="attachment_50032" aria-describedby="caption-attachment-50032" class="wp-caption aligncenter"><img data-attachment-id="50032" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/child-component-re-render-every-state-change/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/child-component-re-render-every-state-change.gif" data-orig-size="524,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="App and child components re-render on state change" data-image-description="" data-image-caption="&lt;p&gt;Every state change re-renders the App and child components.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/child-component-re-render-every-state-change-297x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/child-component-re-render-every-state-change.gif" decoding="async" class="size-full wp-image-50032 jetpack-lazy-image" src="../Images/a5fc5ba026367b5ceda578ed73f82707.png" alt="App and Child Components Re-rendering on Every State Change" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/child-component-re-render-every-state-change.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/child-component-re-render-every-state-change.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50032" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/child-component-re-render-every-state-change/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/child-component-re-render-every-state-change.gif" data-orig-size="524,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="App and child components re-render on state change" data-image-description="" data-image-caption="&lt;p&gt;Every state change re-renders the App and child components.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/child-component-re-render-every-state-change-297x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/child-component-re-render-every-state-change.gif" decoding="async" loading="lazy" class="size-full wp-image-50032" src="../Images/a5fc5ba026367b5ceda578ed73f82707.png" alt="App and Child Components Re-rendering on Every State Change" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/child-component-re-render-every-state-change.gif"/></noscript><figcaption id="caption-attachment-50032" class="wp-caption-text">Every state change re-renders the <code>App</code> and child components.</figcaption></figure>
<p>下图中的<a href="https://wavez.github.io/react-hooks-lifecycle/">说明了状态变化导致渲染循环。</a></p>
<figure id="attachment_50033" aria-describedby="caption-attachment-50033" class="wp-caption aligncenter"><img data-attachment-id="50033" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/react-hooks-lifecycle-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram.png" data-orig-size="730,503" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Diagram of the React Hooks lifecycle" data-image-description="" data-image-caption="&lt;p&gt;A state update re-renders the corresponding component.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram-300x207.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram.png" decoding="async" class="size-full wp-image-50033 jetpack-lazy-image" src="../Images/1ced5fbae8d695fc394c2814558c1613.png" alt="Diagram of the React Hooks Lifecycle" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram-300x207.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="50033" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/react-hooks-lifecycle-diagram/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram.png" data-orig-size="730,503" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Diagram of the React Hooks lifecycle" data-image-description="" data-image-caption="&lt;p&gt;A state update re-renders the corresponding component.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram-300x207.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram.png" decoding="async" loading="lazy" class="size-full wp-image-50033" src="../Images/1ced5fbae8d695fc394c2814558c1613.png" alt="Diagram of the React Hooks Lifecycle" srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram-300x207.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/react-hooks-lifecycle-diagram.png"/></noscript><figcaption id="caption-attachment-50033" class="wp-caption-text">A state update re-renders the corresponding component.</figcaption></figure>
<p>为什么理解 React 钩子生命周期很重要？一方面，只要不通过 updater 函数更新状态，状态就会在渲染过程中保持不变，这本身就会触发新的渲染周期。</p>
<h3>使用带有<code>useEffect</code>的<code>useState</code>挂钩</h3>
<p>另一个需要理解的重要概念是<code><a href="https://reactjs.org/docs/hooks-effect.html">useEffect</a></code>钩子，您很可能必须在应用程序中使用它来调用异步代码(例如，获取数据)。正如你在前面的图中看到的，<code>useState</code>和<code>useEffect</code>钩子紧密耦合，因为状态变化可能会调用效果。</p>
<p>让我们看看下面的例子。我们引入两个额外的状态变量:<code>loading</code>和<code>lang</code>。每当<code>url</code>道具改变时，该效果就会被调用。它获取一个语言字符串(或者是<code>en</code>或者是<code>de</code>)并用<code>setLang</code> updater 函数更新状态。</p>
<p>根据语言的不同，标题中会呈现英语或德语字符串。此外，在获取过程中，设置了一个<code>loading</code>状态，并且根据该值(<code>true</code>或<code>false</code>)，呈现一个加载指示符而不是标题。</p>
<pre>import { useEffect, useState } from "react";
import "./styles.css";
  function App4({ url }) {
  console.log("render App");
  const [loading, setLoading] = useState(true);
  const [lang, setLang] = useState("de");
  const [darkMode, setDarkMode] = useState(false);
  useEffect(() =&gt; {
    console.log("useEffect");
    const fetchData = async function () {
      try {
        setLoading(true);
        const response = await axios.get(url);
        if (response.status === 200) {
          const { language } = response.data;
          setLang(language);
        }
      } catch (error) {
        throw error;
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [url]);
  return (
    &lt;div className={`App ${darkMode &amp;&amp; "dark-mode"}`}&gt;
      {loading ? (
        &lt;div&gt;Loading...&lt;/div&gt;
      ) : (
        &lt;&gt;
          &lt;h1&gt;
            {lang === "en"
              ? "The useState hook is awesome"
              : "Der useState Hook ist toll"}
          &lt;/h1&gt;
          &lt;button
            onClick={() =&gt; {
              setDarkMode(!darkMode);
            }}
          &gt;
            toggle dark mode
          &lt;/button&gt;
        &lt;/&gt;
      )}
    &lt;/div&gt;
  );
}</pre>
<figure id="attachment_50036" aria-describedby="caption-attachment-50036" class="wp-caption aligncenter"><img data-attachment-id="50036" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/setting-state-useeffect/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/setting-state-useeffect.gif" data-orig-size="542,604" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Setting loading and lang state inside useEffect" data-image-description="" data-image-caption="&lt;p&gt;Setting loading and lang state inside useEffect.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/setting-state-useeffect-269x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/setting-state-useeffect.gif" decoding="async" class="size-full wp-image-50036 jetpack-lazy-image" src="../Images/21e2c8f799aeb431652b3ecd859e1ea1.png" alt="Setting Loading and Lang State Inside useEffect" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/setting-state-useeffect.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/setting-state-useeffect.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50036" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/setting-state-useeffect/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/setting-state-useeffect.gif" data-orig-size="542,604" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Setting loading and lang state inside useEffect" data-image-description="" data-image-caption="&lt;p&gt;Setting loading and lang state inside useEffect.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/setting-state-useeffect-269x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/setting-state-useeffect.gif" decoding="async" loading="lazy" class="size-full wp-image-50036" src="../Images/21e2c8f799aeb431652b3ecd859e1ea1.png" alt="Setting Loading and Lang State Inside useEffect" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/setting-state-useeffect.gif"/></noscript><figcaption id="caption-attachment-50036" class="wp-caption-text">Setting loading and lang state inside <code>useEffect</code>.</figcaption></figure>
<p>让我们假设我们想在获取当前语言时切换黑暗模式。在更新了语言之后，我们添加了对<code>setDarkMode</code>更新器的调用。此外，我们需要将<code>darkMode</code>状态作为依赖项添加到效果的依赖数组中。</p>
<blockquote><p>为什么必须这样做超出了本文的范围，但是你可以在我之前的文章中<a href="https://blog.logrocket.com/guide-to-react-useeffect-hook/">详细阅读<code>useEffect</code>钩子</a>。</p></blockquote>
<pre>import { useEffect, useState } from "react";
import "./styles.css";
function AppDemo5({ url }) {
  console.log("render App");
  const [loading, setLoading] = useState(true);
  const [lang, setLang] = useState("de");
  const [darkMode, setDarkMode] = useState(false);
  useEffect(() =&gt; {
    console.log("useEffect");
    const fetchData = async function () {
      try {
        setLoading(true);
        const response = await axios.get(url);
        if (response.status === 200) {
          const { language } = response.data;
          setLang(language);
          setDarkMode(!darkMode);
        }
      } catch (error) {
        throw error;
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [url, darkMode]);
  return (
    &lt;div className={`App ${darkMode &amp;&amp; "dark-mode"}`}&gt;
      {loading ? (
        &lt;div&gt;Loading...&lt;/div&gt;
      ) : (
        &lt;&gt;
          &lt;h1&gt;
            {lang === "en"
              ? "The useState hook is awesome"
              : "Der useState Hook ist toll"}
          &lt;/h1&gt;
          &lt;button
            onClick={() =&gt; {
              setDarkMode(!darkMode);
            }}
          &gt;
            toggle dark mode
          &lt;/button&gt;
        &lt;/&gt;
      )}
    &lt;/div&gt;
  );
}</pre>
<p>不幸的是，我们造成了一个无限循环。</p>
<figure id="attachment_50090" aria-describedby="caption-attachment-50090" class="wp-caption aligncenter"><img data-attachment-id="50090" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/useeffect-render-infinite-loop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/useeffect-render-infinite-loop.gif" data-orig-size="550,586" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Infinite loop of renders caused by useEffect" data-image-description="" data-image-caption="&lt;p&gt;Wrong usage of state in combination with useEffect causes an infinite loop.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/useeffect-render-infinite-loop-282x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/useeffect-render-infinite-loop.gif" decoding="async" class="size-full wp-image-50090 jetpack-lazy-image" src="../Images/e7b9e8e1266fd8ba68a935fcaca6205a.png" alt="Incorrect Use of useEffect Causes an Infinite Loop of Renders" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/useeffect-render-infinite-loop.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/useeffect-render-infinite-loop.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50090" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/useeffect-render-infinite-loop/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/useeffect-render-infinite-loop.gif" data-orig-size="550,586" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Infinite loop of renders caused by useEffect" data-image-description="" data-image-caption="&lt;p&gt;Wrong usage of state in combination with useEffect causes an infinite loop.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/useeffect-render-infinite-loop-282x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/useeffect-render-infinite-loop.gif" decoding="async" loading="lazy" class="size-full wp-image-50090" src="../Images/e7b9e8e1266fd8ba68a935fcaca6205a.png" alt="Incorrect Use of useEffect Causes an Infinite Loop of Renders" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/useeffect-render-infinite-loop.gif"/></noscript><figcaption id="caption-attachment-50090" class="wp-caption-text">Wrong usage of state in combination with <code>useEffect</code> causes an infinite loop.</figcaption></figure>
<p>这是为什么呢？因为我们已经将<code>darkMode</code>添加到效果的依赖数组中，并且我们更新了效果内部的确切状态，所以效果再次被调用，再次更新状态，如此循环往复。</p>
<p>但是有一条出路！我们可以通过<a href="https://reactjs.org/docs/hooks-reference.html#functional-updates">从先前的状态</a>计算新的状态来避免<code>darkMode</code>成为效果的依赖。我们通过传递一个具有先前状态的函数作为参数来调用<code>setDarkMode</code>更新器。</p>
<p>修改后的<code>useEffect</code>实现如下所示:</p>
<pre>  useEffect(() =&gt; {
    console.log("useEffect");
    const fetchData = async function () {
      try {
        setLoading(true);
        const response = await axios.get(url);
        if (response.status === 200) {
          const { language } = response.data;
          setLang(language);
          setDarkMode((previous) =&gt; !previous); // no access of darkMode state
        }
      } catch (error) {
        throw error;
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [url]); // no darkMode dependency</pre>
<h3>与基于类的组件的区别</h3>
<p>如果您已经使用 React 很长时间了，或者您目前正在处理遗留代码，那么您应该知道基于类的组件。对于基于类的组件，只有一个对象表示组件状态。为了更新整体状态的一部分，您可以利用通用的<code>[setState](<a href="https://reactjs.org/docs/state-and-lifecycle.html" rel="nofollow">https://reactjs.org/docs/state-and-lifecycle.html</a>)</code>方法。</p>
<p>假设我们只想更新<code>darkMode</code>状态变量。然后，您可以将更新的属性放入对象中；该州的其他地方不受影响。</p>
<pre>this.setState({darkMode: false});</pre>
<p>然而，对于功能组件，首选方式是使用可以单独更新的原子状态变量。否则，你可以很快发现自己在泪之谷。</p>
<p>与<code>AppDemo6</code>相比，以下组件(<code>AppDemo7</code>)仅在状态管理方面进行了重构。我们使用一个状态对象(<code>state</code>)，而不是三个原始数据类型的原子状态变量。</p>
<pre>import { useEffect, useState } from "react";
import "./styles.css";
function AppDemo7({ url }) {
  const initialState = {
    loading: true,
    lang: "de",
    darkMode: true
  };
  const [state, setState] = useState(initialState);
  console.log("render App", state);
  useEffect(() =&gt; {
    console.log("useEffect");
    const fetchData = async function () {
      try {
        setState((prev) =&gt; ({
          loading: true,
          lang: prev.lang,
          darkMode: prev.darkMode
        }));
        const response = await axios.get(url);
        if (response.status === 200) {
          const { language } = response.data;
          setState((prev) =&gt; ({
            lang: language,
            darkMode: !prev.darkMode,
            loading: prev.loading
          }));
        }
      } catch (error) {
        throw error;
      } finally {
        setState((prev) =&gt; ({
          loading: false,
          lang: prev.lang,
          darkMode: prev.darkMode
        }));
      }
    };
    fetchData();
  }, [url]);
  return (
    &lt;div className={`App ${state.darkMode &amp;&amp; "dark-mode"}`}&gt;
      {state.loading ? (
        &lt;div&gt;Loading...&lt;/div&gt;
      ) : (
        &lt;&gt;
          &lt;h1&gt;
            {state.lang === "en"
              ? "The useState hook is awesome"
              : "Der useState Hook ist toll"}
          &lt;/h1&gt;
          &lt;button
            onClick={() =&gt; {
              setState((prev) =&gt; ({
                darkMode: !prev.darkMode,
                // lang: prev.lang,
                loading: prev.loading
              }));
            }}
          &gt;
            toggle dark mode
          &lt;/button&gt;
        &lt;/&gt;
      )}
    &lt;/div&gt;
  );
}</pre>
<p>如你所见，代码很乱，很难维护。它还包括一个 bug，用<code>onClick</code>处理程序中的注释掉的属性来说明。当用户单击按钮时，整体状态计算不正确。</p>
<p>在这种情况下，<code>lang</code>属性不存在。这导致了一个错误，导致文本以德语呈现，因为<code>state.lang</code>是<code>undefined</code>。我希望我已经明确表明这是一个坏主意。顺便说一下，<a href="https://reactjs.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables"> React 团队也不建议</a>。</p>
<h2>理解<code>useRef</code>挂钩</h2>
<p><code><a href="https://reactjs.org/docs/hooks-reference.html#useref">useRef</a></code>挂钩与<code>useState</code>相似，但有所不同😀。在我澄清之前，我先解释一下它的基本用法。</p>
<pre>import { useRef } from 'react';
const AppDemo8 = () =&gt; {
  const ref1 = useRef();
  const ref2 = useRef(2021);
  console.log("render");
  console.log(ref1, ref2);
  return (
    &lt;div&gt;
      &lt;h2&gt;{ref1.current}&lt;/h2&gt;
      &lt;h2&gt;{ref2.current}&lt;/h2&gt;
    &lt;/div&gt;
  );
};</pre>
<p>结果并不引人注目，但却揭示了症结所在。</p>
<figure id="attachment_50094" aria-describedby="caption-attachment-50094" class="wp-caption aligncenter"><img data-attachment-id="50094" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/values-stored-current-property/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property.png" data-orig-size="730,181" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Values stored in the current property" data-image-description="" data-image-caption="&lt;p&gt;The values are stored in the current property.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property-300x74.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property.png" decoding="async" class="size-full wp-image-50094 jetpack-lazy-image" src="../Images/9e3731c53cd1a2693f8c162523ed525c.png" alt="useRef Values Are Stored in the Current Property" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property-300x74.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="50094" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/values-stored-current-property/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property.png" data-orig-size="730,181" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Values stored in the current property" data-image-description="" data-image-caption="&lt;p&gt;The values are stored in the current property.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property-300x74.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property.png" decoding="async" loading="lazy" class="size-full wp-image-50094" src="../Images/9e3731c53cd1a2693f8c162523ed525c.png" alt="useRef Values Are Stored in the Current Property" srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property-300x74.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/values-stored-current-property.png"/></noscript><figcaption id="caption-attachment-50094" class="wp-caption-text">The values are stored in the <code>current</code> property.</figcaption></figure>
<p>我们通过调用。钩子调用返回一个具有属性<code>current</code>的对象，该属性存储实际值。如果您将一个参数<code>initialValue</code>传递给<code>useRef(initialValue)</code>，那么这个值将存储在<code>current</code>中。</p>
<p>这就是第一个<code>console.log</code>输出存储<code>undefined</code>的原因:因为我们在没有任何参数的情况下调用了钩子。别担心，我们可以稍后赋值。</p>
<p>要访问 ref 的值，您需要访问它的<code>current</code>属性，就像我们在 JSX 部分所做的那样。定义引用后，它们在初始渲染中直接可用。</p>
<p>但是我们到底为什么需要<code>useRef</code>？为什么不用普通的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">变量<code>let</code>代替</a>？别急——我们回头再谈那个。</p>
<h3><code>useRef</code>的常见用例</h3>
<p>让我们看看下面的例子。</p>
<pre>import { useRef } from "react";
import "./styles.css";
const AppDemo9 = () =&gt; {
  const countRef = useRef(0);
  console.log("render");
  return (
    &lt;div className="App"&gt;
      &lt;h2&gt;count: {countRef.current}&lt;/h2&gt;
      &lt;button
        onClick={() =&gt; {
          countRef.current = countRef.current + 1;
          console.log(countRef.current);
        }}
      &gt;
        increase count
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</pre>
<p>我们的目标是定义一个名为<code>countRef</code>的 ref，用<code>0</code>初始化这个值，并在每次点击按钮时增加这个计数器变量。渲染的计数值应该更新。不幸的是，它不起作用——甚至控制台输出也证明了<code>current</code>属性保存了正确的更新。</p>
<figure id="attachment_50097" aria-describedby="caption-attachment-50097" class="wp-caption aligncenter"><img data-attachment-id="50097" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/count-no-update-click/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/count-no-update-click.gif" data-orig-size="582,376" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Count doesn’t update on button click" data-image-description="" data-image-caption="&lt;p&gt;Count does not update on button click.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/count-no-update-click-300x194.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/count-no-update-click.gif" decoding="async" class="size-full wp-image-50097 jetpack-lazy-image" src="../Images/7710aa9812f6426fbf210b91faab1759.png" alt="Count Doesn't Update on Button Click" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/count-no-update-click.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/count-no-update-click.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50097" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/count-no-update-click/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/count-no-update-click.gif" data-orig-size="582,376" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Count doesn’t update on button click" data-image-description="" data-image-caption="&lt;p&gt;Count does not update on button click.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/count-no-update-click-300x194.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/count-no-update-click.gif" decoding="async" loading="lazy" class="size-full wp-image-50097" src="../Images/7710aa9812f6426fbf210b91faab1759.png" alt="Count Doesn't Update on Button Click" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/count-no-update-click.gif"/></noscript><figcaption id="caption-attachment-50097" class="wp-caption-text">Count does not update on button click.</figcaption></figure>
<p>正如您从我们的另一个控制台输出呈现中看到的，我们的组件没有重新呈现。我们可以利用<code>useState</code>来代替这种行为。</p>
<p>什么？所以<code>useRef</code>挺没用的？没那么快——和其他触发重渲染的钩子结合使用很方便，比如<code>useState</code>、<code><a href="https://reactjs.org/docs/hooks-reference.html#usereducer">useReducer</a></code>和<code><a href="https://reactjs.org/docs/hooks-reference.html#usecontext">useContext</a></code>。</p>
<p>你得把<code>useRef</code>当成你工具箱里的另一个工具，你得明白什么时候用它。还记得上面的组件生命周期图吗？refs 的值(特别是<code>current</code>属性)在整个渲染周期中保持不变。这不是一个错误；这是一个特点。</p>
<p>考虑这样的情况，您想要更新组件的数据(即，它的状态变量)来触发呈现，以便更新 UI。您也可能需要相同的行为，但有一个例外:您不希望触发渲染循环，因为这可能会导致错误、尴尬的用户体验(例如，闪烁)或性能问题。</p>
<p>你可以把 refs 想象成基于类的组件的<a href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables">实例变量。ref 是一个通用容器，用于存储任何类型的数据，如原始数据或对象。</a></p>
<p>好吧，我们将展示一个有用的例子。</p>
<pre>import { useState } from "react";
import "./styles.css";
const AppDemo10 = () =&gt; {
  const [value, setValue] = useState("");
  console.log("render");
  const handleInputChange = (e) =&gt; {
    setValue(e.target.value);
  };
  return (
    &lt;div className="App"&gt;
      &lt;input value={value} onChange={handleInputChange} /&gt;
    &lt;/div&gt;
  );
};</pre>
<p>从下面的记录中可以看到，这个组件只是呈现一个输入字段，并将其值存储在<code>value</code>状态变量中。控制台输出显示，每次击键时都会重新呈现<code>AppDemo10</code>组件。</p>
<p>这可能是您想要的行为，例如，对每个字符执行搜索等操作。这被称为<a href="https://reactjs.org/docs/uncontrolled-components.html">受控组件</a>。然而，它可能正好相反，并且渲染变得有问题。然后你需要一个<a href="https://reactjs.org/docs/uncontrolled-components.html">不受控组件</a>。</p>
<figure id="attachment_50098" aria-describedby="caption-attachment-50098" class="wp-caption aligncenter"><img data-attachment-id="50098" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/controlled-component-renders-every-keystroke/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/controlled-component-renders-every-keystroke.gif" data-orig-size="612,376" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Controlled component rendering on every keystroke" data-image-description="" data-image-caption="&lt;p&gt;A controlled component renders on every keystroke.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/controlled-component-renders-every-keystroke-300x184.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/controlled-component-renders-every-keystroke.gif" decoding="async" class="size-full wp-image-50098 jetpack-lazy-image" src="../Images/d557aa7b965c4e057a255dfbd9cfef9a.png" alt="A Controlled Component Rendering on Every Keystroke" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/controlled-component-renders-every-keystroke.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/controlled-component-renders-every-keystroke.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50098" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/controlled-component-renders-every-keystroke/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/controlled-component-renders-every-keystroke.gif" data-orig-size="612,376" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Controlled component rendering on every keystroke" data-image-description="" data-image-caption="&lt;p&gt;A controlled component renders on every keystroke.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/controlled-component-renders-every-keystroke-300x184.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/controlled-component-renders-every-keystroke.gif" decoding="async" loading="lazy" class="size-full wp-image-50098" src="../Images/d557aa7b965c4e057a255dfbd9cfef9a.png" alt="A Controlled Component Rendering on Every Keystroke" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/controlled-component-renders-every-keystroke.gif"/></noscript><figcaption id="caption-attachment-50098" class="wp-caption-text">A controlled component renders on every keystroke.</figcaption></figure>
<p>让我们重写这个例子，使用一个带有<code>useRef</code>的不受控制的组件。因此，我们需要一个按钮来更新组件的状态并存储完全填充的输入字段。</p>
<pre>import { useState, useRef } from "react";
import "./styles.css";
const AppDemo11 = () =&gt; {
  const [value, setValue] = useState("");
  const valueRef = useRef();
  console.log("render");
  const handleClick = () =&gt; {
    console.log(valueRef);
    setValue(valueRef.current.value);
  };
  return (
    &lt;div className="App"&gt;
      &lt;h4&gt;Value: {value}&lt;/h4&gt;
      &lt;input ref={valueRef} /&gt;
      &lt;button onClick={handleClick}&gt;click&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre>
<p>使用这种解决方案，我们不会在每次击键时导致渲染循环。另一方面，我们需要用一个按钮“提交”输入来更新状态变量<code>value</code>。从控制台输出可以看出，第二次渲染首先发生在单击按钮时。</p>
<figure id="attachment_50114" aria-describedby="caption-attachment-50114" class="wp-caption aligncenter"><img data-attachment-id="50114" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/uncontrolled-component-no-re-renders/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/uncontrolled-component-no-re-renders.gif" data-orig-size="612,376" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Uncontrolled components don’t trigger re-renders" data-image-description="" data-image-caption="&lt;p&gt;An uncontrolled component does not trigger re-renders on change.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/uncontrolled-component-no-re-renders-300x184.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/uncontrolled-component-no-re-renders.gif" decoding="async" class="size-full wp-image-50114 jetpack-lazy-image" src="../Images/d6a309909348bd9cfe4bb25d025170a0.png" alt="An Uncontrolled Component Does Not Trigger a Re-render" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/uncontrolled-component-no-re-renders.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/uncontrolled-component-no-re-renders.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50114" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/uncontrolled-component-no-re-renders/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/uncontrolled-component-no-re-renders.gif" data-orig-size="612,376" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Uncontrolled components don’t trigger re-renders" data-image-description="" data-image-caption="&lt;p&gt;An uncontrolled component does not trigger re-renders on change.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/uncontrolled-component-no-re-renders-300x184.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/uncontrolled-component-no-re-renders.gif" decoding="async" loading="lazy" class="size-full wp-image-50114" src="../Images/d6a309909348bd9cfe4bb25d025170a0.png" alt="An Uncontrolled Component Does Not Trigger a Re-render" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/uncontrolled-component-no-re-renders.gif"/></noscript><figcaption id="caption-attachment-50114" class="wp-caption-text">An uncontrolled component does not trigger re-renders on change.</figcaption></figure>
<p>顺便说一下，上面的例子展示了 refs 的第二个用例。</p>
<pre>&lt;input ref={valueRef} /&gt;</pre>
<p>通过<code>ref</code>属性，React 提供了对 React 组件或 HTML 元素的直接访问。控制台输出显示我们确实可以访问<code>input</code>元素。引用存储在<code>current</code>属性中。</p>
<p>这构成了<code>useRef</code>的第二个用例，除了将它作为一个通用容器在整个组件生命周期中保存数据。如果需要直接访问 DOM 元素，可以利用<code>ref</code> prop。下一个示例显示了如何在组件初始化后聚焦输入字段。</p>
<pre>import { useEffect, useRef } from "react";
import "./styles.css";
const AppDemo12 = () =&gt; {
  const inputRef = useRef();
  console.log("render");
  useEffect(() =&gt; {
    console.log("useEffect");
    inputRef.current.focus();
  }, []);
  return (
    &lt;div className="App"&gt;
      &lt;input ref={inputRef} placeholder="input" /&gt;
    &lt;/div&gt;
  );
};</pre>
<p>在<code>useEffect</code>回调中，我们调用本机<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus">focus</a></code>方法。</p>
<figure id="attachment_50101" aria-describedby="caption-attachment-50101" class="wp-caption aligncenter"><img data-attachment-id="50101" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/focus-input-field/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/focus-input-field.gif" data-orig-size="612,374" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Adding focus to an input field" data-image-description="" data-image-caption="&lt;p&gt;Focus an input field with the help of a ref.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/focus-input-field-300x183.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/focus-input-field.gif" decoding="async" class="size-full wp-image-50101 jetpack-lazy-image" src="../Images/27550bec028f1ff43509195a647126e3.png" alt="Adding Focus to an Input Field Via refs" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/focus-input-field.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/focus-input-field.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50101" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/focus-input-field/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/focus-input-field.gif" data-orig-size="612,374" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Adding focus to an input field" data-image-description="" data-image-caption="&lt;p&gt;Focus an input field with the help of a ref.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/focus-input-field-300x183.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/focus-input-field.gif" decoding="async" loading="lazy" class="size-full wp-image-50101" src="../Images/27550bec028f1ff43509195a647126e3.png" alt="Adding Focus to an Input Field Via refs" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/focus-input-field.gif"/></noscript><figcaption id="caption-attachment-50101" class="wp-caption-text">Focus an input field with the help of a ref.</figcaption></figure>
<p>当您需要直接访问 DOM 元素时，这种技术也广泛用于与第三方(非 React)组件结合的 React 项目中。</p>
<p>另一个常见的用例是当您需要前一个渲染周期的状态值时。以下示例显示了如何做到这一点。当然，您也可以将逻辑提取到一个定制的<code><a href="https://usehooks.com/usePrevious/">usePrevious</a></code>钩子中。</p>
<pre>import { useEffect, useState, useRef } from "react";
import "./styles.css";
const AppDemo13 = () =&gt; {
  console.log("render");
  const [count, setCount] = useState(0);
  // Get the previous value (was passed into hook on last render)
  const ref = useRef();
  // Store current value in ref
  useEffect(() =&gt; {
    console.log("useEffect");
    ref.current = count;
  }, [count]); // Only re-run if value changes
  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;
        Now: {count}, before: {ref.current}
      &lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre>
<p>在初始渲染之后，执行一个效果，将状态变量<code>count</code>分配给<code>ref.current</code>。因为没有额外的渲染发生，所以渲染值是<code>undefined</code>。点击按钮触发状态更新，因为调用了<code>setCount</code>。</p>
<p>接下来，UI 被重新呈现，标签前的<strong>显示正确的值(<code>0</code>)。渲染后，调用另一个效果。现在<code>1</code>被分配给我们的 ref，以此类推。</strong></p>
<figure id="attachment_50116" aria-describedby="caption-attachment-50116" class="wp-caption aligncenter"><img data-attachment-id="50116" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/access-previous-state-useref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/access-previous-state-useref.gif" data-orig-size="612,374" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Accessing previous state via useRef" data-image-description="&lt;p&gt;Access previous state with the help of useRef.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/access-previous-state-useref-300x183.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/access-previous-state-useref.gif" decoding="async" class="wp-image-50116 size-full jetpack-lazy-image" src="../Images/3513339db32e37846466256401d295e2.png" alt="Accessing Previous State Via useRef" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/access-previous-state-useref.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/access-previous-state-useref.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50116" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/access-previous-state-useref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/access-previous-state-useref.gif" data-orig-size="612,374" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Accessing previous state via useRef" data-image-description="&lt;p&gt;Access previous state with the help of useRef.&lt;/p&gt;&#10;" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/access-previous-state-useref-300x183.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/access-previous-state-useref.gif" decoding="async" loading="lazy" class="wp-image-50116 size-full" src="../Images/3513339db32e37846466256401d295e2.png" alt="Accessing Previous State Via useRef" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/access-previous-state-useref.gif"/></noscript><figcaption id="caption-attachment-50116" class="wp-caption-text">Access previous state with the help of <code>useRef</code>.</figcaption></figure>
<p>值得注意的是，所有的引用都需要在<code>useEffect</code>回调或处理程序中得到更新。在渲染期间改变 ref，也就是说，从除了刚才提到的地方之外的地方，可能会引入 bug。这同样适用于<code>useState</code>。</p>
<h3>为什么<code>let</code>不能取代<code>useRef</code></h3>
<p>现在我还欠你一个解释，为什么一个<code>let</code>变量不能代替一个 ref 的概念。下一个例子用来自<code>useEffect</code>钩子内部的普通 JavaScript 变量赋值替换了<code>useRef</code>的使用。</p>
<pre>import { useEffect, useState } from "react";
import "./styles.css";
const AppDemo14 = () =&gt; {
  console.log("render");
  const [count, setCount] = useState(0);
  let prevCount;
  useEffect(() =&gt; {
    console.log("useEffect", prevCount);
    prevCount = count;
  }, [count]);
  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;
        Now: {count}, before: {prevCount}
      &lt;/h1&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
};</pre>
<p>然而，下面的录音将揭示这是行不通的。控制台输出加剧了这个问题，因为在每个新的渲染周期中，<code>useEffect</code>内部的赋值都会被覆盖。<code>undefined</code>因<code>let prevCount;</code>而被隐式赋值。</p>
<figure id="attachment_50118" aria-describedby="caption-attachment-50118" class="wp-caption aligncenter"><img data-attachment-id="50118" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/normal-variable-assignment-useref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/normal-variable-assignment-useref.gif" data-orig-size="718,342" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="let variables can’t replace useRef" data-image-description="" data-image-caption="&lt;p&gt;A normal variable assignment cannot replace useRef.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/normal-variable-assignment-useref-300x143.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/normal-variable-assignment-useref.gif" decoding="async" class="size-full wp-image-50118 jetpack-lazy-image" src="../Images/f32320045dea38b3a53db91a3ce906aa.png" alt="A Normal Variable Assignment Cannot Replace useRef" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/normal-variable-assignment-useref.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/normal-variable-assignment-useref.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="50118" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/normal-variable-assignment-useref/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/normal-variable-assignment-useref.gif" data-orig-size="718,342" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="let variables can’t replace useRef" data-image-description="" data-image-caption="&lt;p&gt;A normal variable assignment cannot replace useRef.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/normal-variable-assignment-useref-300x143.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/normal-variable-assignment-useref.gif" decoding="async" loading="lazy" class="size-full wp-image-50118" src="../Images/f32320045dea38b3a53db91a3ce906aa.png" alt="A Normal Variable Assignment Cannot Replace useRef" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/normal-variable-assignment-useref.gif"/></noscript><figcaption id="caption-attachment-50118" class="wp-caption-text">A normal variable assignment cannot replace useRef.</figcaption></figure>
<p>甚至强大的 ESLint <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">钩子规则插件</a>也告诉你我们应该利用<code>useRef</code>来代替。</p>
<figure id="attachment_50120" aria-describedby="caption-attachment-50120" class="wp-caption aligncenter"><img data-attachment-id="50120" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/eslint-rules-hooks-plugin-warning/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning.png" data-orig-size="730,328" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Warning from ESLint plugin" data-image-description="" data-image-caption="&lt;p&gt;The ESLint plugin warns you about using variables instead of refs.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning-300x135.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning.png" decoding="async" class="size-full wp-image-50120 jetpack-lazy-image" src="../Images/e85b8bf36d08bf4f9a857f5528a9f8b7.png" alt="Warning From the ESLint Rules of Hooks Plugin " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning-300x135.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="50120" data-permalink="https://blog.logrocket.com/usestate-vs-useref/attachment/eslint-rules-hooks-plugin-warning/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning.png" data-orig-size="730,328" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Warning from ESLint plugin" data-image-description="" data-image-caption="&lt;p&gt;The ESLint plugin warns you about using variables instead of refs.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning-300x135.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning.png" decoding="async" loading="lazy" class="size-full wp-image-50120" src="../Images/e85b8bf36d08bf4f9a857f5528a9f8b7.png" alt="Warning From the ESLint Rules of Hooks Plugin " srcset="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning-300x135.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/eslint-rules-hooks-plugin-warning.png"/></noscript><figcaption id="caption-attachment-50120" class="wp-caption-text">The ESLint plugin warns you about using variables instead of refs.</figcaption></figure>
<h2><code>useRef</code>和<code>useState</code>的区别一目了然</h2>
<p>以下差异已经过详细讨论，但在此再次以简洁的总结形式呈现:</p>
<ul>
<li>两者都在渲染周期和 UI 更新期间保留了它们的数据，但是只有带有 updater 函数的<code>useState</code>钩子会导致重新渲染</li>
<li><code>useRef</code>返回一个具有保存实际值的<code>current</code>属性的对象。相反，<code>useState</code>返回一个包含两个元素的数组:第一项构成了州，第二项代表了州更新函数</li>
<li><code>useRef</code>的<code>current</code>属性是<a href="https://doppelmutzi.github.io/javascript-to-master-before-learning-react/#immutable-vs-mutable-values">可变的</a>，而<code>useState</code>的状态变量不是。与<code>useRef</code>的<code>current</code>属性相反，你不应该直接给<code>useState</code>的状态变量赋值。相反，总是使用 updater 函数(即第二个数组项)。正如 React 团队在<a href="https://reactjs.org/docs/react-component.html#state">文档</a>中为基于类的组件<code>setState</code>所建议的那样(但对函数组件也是如此)，将状态视为不可变变量</li>
<li><code>useState</code>和<code>useRef</code>可以被认为是数据挂钩，但是只有<code>useRef</code>可以用于另一个应用领域:直接访问 React 组件或 DOM 元素</li>
</ul>
<h2>结论</h2>
<p>本文讨论了<code>useState</code>和<code>useRef</code>挂钩。在这一点上应该很清楚，挂钩没有好坏之分。React 应用程序需要这两个挂钩，因为它们是为不同的应用程序设计的。</p>
<p>如果你想更新数据并引起 UI 更新，<code>useState</code>就是你的钩子。如果在组件的整个生命周期中，您需要某种数据容器，而不会因为改变变量而导致渲染周期，那么<code>useRef</code>就是您的解决方案。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
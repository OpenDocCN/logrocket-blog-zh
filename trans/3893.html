<html>
<head>
<title>Using React with Popper and styled-components </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>对Popper和样式化组件使用React</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-react-popper-styled-components/#0001-01-01">https://blog.logrocket.com/using-react-popper-styled-components/#0001-01-01</a></blockquote><div><article class="article-post">
<p>事实证明，工具提示和其他弹出窗口对于提高任何应用程序的UX都是必不可少的。它们使得进一步解释用户正在查看的项目变得容易——比如将鼠标悬停在工具提示上——或者导航到子部分，比如在下拉菜单中。</p>
<p>用CSS创建工具提示或下拉菜单很容易。然而，将它们放置在你的UI中总是很麻烦。通常，您必须引入JavaScript来实现这一点，这可能很繁琐。</p>
<p>这就是像Popper.js 这样的库派上用场的地方。Popper是一个JavaScript库，帮助您轻松管理popovers。在本文中，我们将了解如何在React应用程序中使用Popper。我们将涵盖:</p>

<p>注意，本文中使用的Popper版本是v2，它在v1的基础上有许多改进。</p>
<h2 id="what-styled-components">什么是样式组件？</h2>
<p>在我们真正开始研究Popper之前，让我们先看看本文中用来设计popovers样式的库。</p>
<p>波普不是预先设计好的。这是因为它不会创建你的工具提示或弹出窗口；这只会帮助他们用更少的代码更好地定位和执行。</p>
<p>你必须自己设计工具提示的样式。这就是样式化组件库的用武之地。</p>
<p>样式化组件反应库是一个很好的方式，可以很容易地对组件进行样式化反应。它使用基本的CSS-in-JS样式语法。</p>
<p>这个库允许你创建一个组件，并使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates"> ES6标记的模板文字</a>给它附加样式。下面的代码显示了一个样式化的<code>Button</code>组件:</p>
<pre class="language-javascript hljs">import styled from 'styled-components';

const Button = styled.button`
  padding: 10px;
  border: 2px solid blue;
  border-radius: 4px;

  &amp;:hover {
    border-color: red;
  }
`;

const Example1 = () =&gt; {
  return (
    &lt;main&gt;
      &lt;Button&gt;Click me&lt;/Button&gt;
    &lt;/main&gt;
  );
};

export default Example1;</pre>
<p>结果应该是这样的:</p>
<p><img data-attachment-id="157943" data-permalink="https://blog.logrocket.com/using-react-popper-styled-components/attachment/img1-styled-button-component-styled-components-react-library/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img1-Styled-button-component-styled-components-React-library.gif" data-orig-size="730,387" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Styled-button-component-styled-components-React-library" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img1-Styled-button-component-styled-components-React-library-300x159.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img1-Styled-button-component-styled-components-React-library.gif" decoding="async" class="aligncenter size-full wp-image-157943 jetpack-lazy-image" src="../Images/1bb226b03c99751de8e1b8b412e5cec5.png" alt="White Screen With Centered Light Grey Button Component Outlined In Blue. When Mouse Moves Over Button, Outline Changes To Red" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/img1-Styled-button-component-styled-components-React-library.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/img1-Styled-button-component-styled-components-React-library.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="157943" data-permalink="https://blog.logrocket.com/using-react-popper-styled-components/attachment/img1-styled-button-component-styled-components-react-library/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img1-Styled-button-component-styled-components-React-library.gif" data-orig-size="730,387" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Styled-button-component-styled-components-React-library" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img1-Styled-button-component-styled-components-React-library-300x159.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img1-Styled-button-component-styled-components-React-library.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-157943" src="../Images/1bb226b03c99751de8e1b8b412e5cec5.png" alt="White Screen With Centered Light Grey Button Component Outlined In Blue. When Mouse Moves Over Button, Outline Changes To Red" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/img1-Styled-button-component-styled-components-React-library.gif"/></noscript>
<p>&amp;操作符是styled-components引用被样式化的组件的方式。可以把它想象成JavaScript在类中的<code>this</code>。</p>
<p>此外，在上面的例子中，我们发现在ES6模板中使用CSS来设计按钮的样式。<code>Button</code>组件——它是一个实际的React组件——是一个按钮，按钮元素的所有属性/特性都可以传递给<code>Button</code>组件:</p>
<pre class="language-javascript hljs">const Example1 = () =&gt; {
  return (
    &lt;main&gt;
      &lt;Button type="submit"&gt;Click me&lt;/Button&gt;
    &lt;/main&gt;
  );
};</pre>
<p>我们不可能在这里详细介绍使用样式化组件的每一个细节，但是到目前为止，我所解释的关于样式化组件的内容对于本教程来说已经足够了。</p>
<h2 id="what-popper">波普是什么？</h2>
<p>Popper不是工具提示或下拉库。相反，它是一个使构建工具提示或下拉菜单更容易的库。换句话说，Popper不会为您创建工具提示，但它会帮助您定位工具提示，使其始终适合您的UI。</p>
<p>用Popper定位popovers是完全可定制的。您可以打开和关闭功能，自定义现有功能以满足您的需求，以及创建一些自定义功能。</p>
<p>Popper v2的大小从超过7kb的minzipped减少到现在的3kb minzipped。也可以通过树摇动从您的包<a href="https://blog.logrocket.com/tree-shaking-json-files-webpack/">中删除未使用的代码。</a></p>
<p>Popper可用于任何弹出窗口，但它主要用于工具提示。虽然我将在本文中引用工具提示，但是您可以使用这些知识来放置您想要创建的任何弹出窗口。</p>
<p>Popper默认支持vanilla JS，但也支持React。创建者创建了另一个名为 <code><a href="https://www.npmjs.com/package/react-popper">react-popper</a></code>的<a href="https://www.npmjs.com/package/react-popper">库来扩展核心Popper库，以便在React应用程序中使用。</a></p>
<p>下面是一个用<code>react-popper</code>定位工具提示的基本交互示例:</p>
<p><img data-attachment-id="157945" data-permalink="https://blog.logrocket.com/using-react-popper-styled-components/attachment/img2-interactive-tooltip-positioning-react-popper/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img2-Interactive-tooltip-positioning-react-popper.gif" data-orig-size="730,402" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Interactive-tooltip-positioning-react-popper" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img2-Interactive-tooltip-positioning-react-popper-300x165.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img2-Interactive-tooltip-positioning-react-popper.gif" decoding="async" class="aligncenter size-full wp-image-157945 jetpack-lazy-image" src="../Images/29d259f7b17f92b2c3a21444076e3d10.png" alt="Dark Grey Background Demoing Interactive Tooltip Positioning With Centered Black Button And White Tooltip Above Line Of Tooltip Positioning Options. Tooltip Moves As User Clicks On Various Positioning Options" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/img2-Interactive-tooltip-positioning-react-popper.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/img2-Interactive-tooltip-positioning-react-popper.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="157945" data-permalink="https://blog.logrocket.com/using-react-popper-styled-components/attachment/img2-interactive-tooltip-positioning-react-popper/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img2-Interactive-tooltip-positioning-react-popper.gif" data-orig-size="730,402" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Interactive-tooltip-positioning-react-popper" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img2-Interactive-tooltip-positioning-react-popper-300x165.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img2-Interactive-tooltip-positioning-react-popper.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-157945" src="../Images/29d259f7b17f92b2c3a21444076e3d10.png" alt="Dark Grey Background Demoing Interactive Tooltip Positioning With Centered Black Button And White Tooltip Above Line Of Tooltip Positioning Options. Tooltip Moves As User Clicks On Various Positioning Options" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/img2-Interactive-tooltip-positioning-react-popper.gif"/></noscript>
<p>你可以<a href="https://e6n1w5.csb.app/example1">在你的浏览器</a>中与这个例子互动，看看它是如何为你自己工作的。</p>
<p>在本例中，我们提供了四种在按钮周围定位工具提示项的方法:</p>

<p>Popper还提供了类似于<code>top-start</code>和<code>top-end</code>的其他位置，我们稍后会更详细地讨论这些位置。</p>
<h2 id="getting-started-react-popper">开始使用<code>react-popper</code></h2>
<p>这是一个代码部分，所以试着跟着做。在这一节中，我们将讨论在React中开始使用Popper所需的一切。</p>
<h3 id="setting-up-new-project">设置新项目</h3>
<p>首先，让我们使用下面的命令用Vite 创建一个新的React项目:</p>
<pre class="language-bash hljs">npm create <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4d3b2439280d212c39283e39">[email protected]</a> popper-js -- --template react</pre>
<p>我们的项目将被称为<code>popper-js</code>。你可以选择给你的名字取任何合适的名字。</p>
<p>接下来，我们将安装依赖项:</p>
<pre class="language-bash hljs">npm install styled-components @popperjs/core react-popper</pre>
<p>现在我们已经建立了项目，您可以运行<code>npm run dev</code>在本地主机上启动项目。</p>
<p>接下来，让我们创建一个简单的工具提示来显示网站上的一些信息。清除<code>App.js</code>文件中的代码，并将以下内容粘贴到其中:</p>
<pre class="language-javascript hljs">import {
 StyledAppContainer,
 LongEl,
 Tooltip,
 Button
} from "./App.styled"; 
import { useState } from "react"; 

export default function App() {
 const [referenceEl, setReferenceEl] = useState(null);
 const [popperEl, setPopperEl] = useState(null);

 return (
   &lt;StyledAppContainer&gt;
     &lt;div&gt;
       &lt;LongEl /&gt;
       &lt;Button ref={setReferenceEl}&gt;I'm a mystery&lt;/Button&gt;
       &lt;Tooltip
         ref={setPopperEl}
       &gt;
         &lt;p&gt;A tooltip&lt;/p&gt;
       &lt;/Tooltip&gt;
       &lt;LongEl /&gt;
     &lt;/div&gt;
   &lt;/StyledAppContainer&gt;
 );
}</pre>
<p>我们在上面的代码中所做的就是创建工具提示所需的组件。</p>
<p><code>Button</code>组件是参考元素。Popper使用reference元素作为放置工具提示的元素。工具提示组件是popover容器或元素，它表示将要弹出的内容。</p>
<p>我们还有几个<code>LongEl</code>组件，它们的唯一目的是使上下滚动视窗成为可能。这将有助于我们了解波普的工作。</p>
<p>reference元素和popper或popover元素都被分配了<a href="https://blog.logrocket.com/react-reference-guide-refs-dom/#callbackrefs">回调refs </a>，我们将使用它让Popper访问这些元素。</p>

<p>如果您保存之前创建的文件，您将会看到几个错误，因为我们还没有创建我们使用的样式组件。要解决这个问题，继续创建一个名为<code>App.styled.jsx</code>的新文件，并将以下代码粘贴到其中:</p>
<pre class="language-javascript hljs">import styled from "styled-components";

export const LongEl = styled.div`
 min-height: 100vh;
 width: 100%;
`;

export const StyledAppContainer = styled.div`
 min-height: 100vh;
 margin: 0;
 font-family: sans-serif;
 text-align: center;
 background: #242424;
 display: flex;
 justify-content: center;
 align-items: center;
`;

export const Button = styled.button`
 background: #000;
 padding: 15px;
 border: 1px solid lightblue;
 border-radius: 8px;
 color: #fff;
 font-family: sans-serif;
 font-size: 0.8rem;
 font-weight: 500;
`;

export const Tooltip = styled.div`
 background: #fff;
 border-radius: 5px;
 padding: 10px;
 text-align: left;
 position: relative;
 font-size: 0.8rem;
 max-width: 140px;
`;</pre>
<p>这将确保我们需要的所有组件都设计好了，随时可以使用。</p>
<h3 id="usepopper-hook"><code>usePopper</code>钩子</h3>
<p>现在我们已经有了工具提示，可以用Popper来使用了。在<code>App.js</code>文件中，我们将从<code>react-popper</code>导入<code>usePopper</code>钩子，并在<code>App</code>组件中使用它:</p>
<pre class="language-javascript hljs">import { usePopper } from "react-popper"; 

export default function App() {
 const [referenceEl, setReferenceEl] = useState(null);
 const [popperEl, setPopperEl] = useState(null);
  const { styles, attributes } = usePopper(referenceEl, popperEl, {
    placement: "bottom"
  });

 return (
   &lt;StyledAppContainer&gt;
     &lt;div&gt;
       &lt;LongEl /&gt;
       &lt;Button ref={setReferenceEl}&gt;I'm a mystery&lt;/Button&gt;
       &lt;Tooltip
         ref={setPopperEl}
         style={styles.popper}
         {...attributes.popper}
       &gt;
         &lt;p&gt;A tooltip&lt;/p&gt;
       &lt;/Tooltip&gt;
       &lt;LongEl /&gt;
     &lt;/div&gt;
   &lt;/StyledAppContainer&gt;
 );
}</pre>
<p><code>usePopper</code>钩子有三个参数:</p>
<ul>
<li><code>referenceEl</code>—<code>popperEl</code>将沿其放置的参考元素</li>
<li><code>popperEl</code>—popover元素；在这种情况下，工具提示</li>
<li><code>options</code> —帮助定制工具提示以满足您需求的对象。</li>
</ul>
<p><code>options</code>对象包括如下属性:</p>
<ul>
<li><code>modifiers</code> —一系列中间件<ul>
<li>用于更改Popper的默认功能和创建新功能</li>
</ul>
</li>
<li><code>placement</code> —工具提示的初始位置</li>
<li><code>strategy</code> —描述要使用的定位策略<ul>
<li>默认情况下使用<code>absolute</code></li>
</ul>
</li>
<li><code>onFirstUpdate</code> —第一次更新时调用的函数</li>
</ul>
<p>稍后将详细讨论<code>modifiers</code>属性。对于<code>strategy</code>属性，在引用元素位于固定容器中的情况下，您可以很容易地将其从<code>absolute</code>更改为<code>fixed</code>，以帮助正确定位工具提示。</p>
<p>placement属性接受工具提示的初始位置字符串，包括顶部、底部、左侧、右侧和其他位置。默认值是<code>auto</code>，它告诉Popper将工具提示放在空间最大的地方。其他可能的值有:</p>
<ul>
<li><code>top-start</code></li>
<li><code>top-end</code></li>
<li><code>right-start</code></li>
<li><code>right-end</code></li>
<li><code>bottom-start</code></li>
<li><code>bottom-end</code></li>
<li><code>left-start</code></li>
<li><code>left-end</code></li>
</ul>
<p>设置初始位置不会阻止Popper在需要时翻转工具提示。当我们讨论修饰语时，我们也将更多地关注翻转。</p>
<p>挂钩返回一个样式和属性的对象。两者都是用于为tooltip元素分配样式和属性的对象。两者都有一个popper属性，指定<code>popperEl</code>应该使用一组样式以及一组属性。</p>
<p>如果您将<code>styles.popper</code>登录到控制台，您实际上会有一个样式对象，Popper知道您的工具提示将需要它来帮助工作。这些样式与我们使用的样式化组件完全不同。</p>
<p>当我们希望工具提示中有更多的功能时，也需要使用<code>attributes</code>。这方面的一个例子是让工具提示只在被触发时出现。另一个例子是在工具提示上有一个箭头，它指向工具提示去的任何地方，同时保持它在工具提示上的位置。</p>
<p>继续保存您的文件并运行项目。如果你没有关注，你可以在CodeSandbox 中<a href="https://codesandbox.io/s/popper-styled-components-e6n1w5?file=/src/Example3.js">打开这个例子。</a></p>
<h3 id="adding-functionalities">添加功能</h3>
<p>到目前为止，我们只创建了一个总是可见的工具提示，这不是真正的工具提示，对不对？工具提示应该能够随时消失和出现。用Popper做到这一点非常容易。</p>
<p>让我们改进上面的例子，默认隐藏工具提示。然后，当参考元素被悬停时，它可以被显示。这意味着我们将向引用元素添加一个<code>onMouseEnter</code>和一个<code>onMouseLeave</code>事件，如下所示:</p>
<pre class="language-javascript hljs">export default function App() {
 const [referenceEl, setReferenceEl] = useState(null);
 const [popperEl, setPopperEl] = useState(null);
 const { styles, attributes } = usePopper(referenceEl, popperEl, {
   placement: "bottom"
 });

 const showTooltip = () =&gt; {
   popperEl.setAttribute('data-show', true);
 }

 const hideTooltip = () =&gt; {
   popperEl.removeAttribute('data-show')
 }

 return (
   &lt;StyledExampleContainer&gt;
     &lt;div&gt;
       &lt;LongEl /&gt;
       &lt;Button 
         onMouseEnter={showTooltip}
         onMouseLeave={hideTooltip}
         ref={setReferenceEl}
       &gt;
         I'm a mystery
       &lt;/Button&gt;
       &lt;Tooltip 
         ref={setPopperEl}
         style={styles.popper}
         {...attributes.popper}&gt;
         &lt;p&gt;A tooltip&lt;/p&gt;
       &lt;/Tooltip&gt;
       &lt;LongEl /&gt;
     &lt;/div&gt;
   &lt;/StyledExampleContainer&gt;
 );
}</pre>
<p>下一步是将工具提示的样式更改为仅在设置了data-show属性时显示。转到<code>App.styled.jsx</code>文件，像这样更新<code>Tooltip</code>组件:</p>
<pre class="language-javascript hljs">export const Tooltip = styled.div`
 background: #fff;
 border-radius: 5px;
 padding: 10px;
 text-align: left;
 position: relative;
 font-size: 0.8rem;
 max-width: 140px;
 visibility: hidden;

 &amp;[data-show="true"] {
   visibility: visible;
 }
`</pre>
<p>现在保存并运行项目来查看工作中的工具提示，或者您可以<a href="https://codesandbox.io/s/popper-styled-components-e6n1w5?file=/src/Example4.js">在CodeSandbox </a>中查看更新的示例。</p>
<p>对于可访问性，您可能想要添加不仅仅是<code>onMouseEnter</code>和<code>onMouseLeave</code>事件。您还可以添加<code>onFocus</code>和<code>onBlur</code>事件，这样使用键盘导航的人也可以查看工具提示。</p>
<h2 id="extending-react-popper-with-modifiers">用修饰符扩展<code>react-popper</code></h2>
<p>到目前为止，我们已经看到了一个使用<code>react-popper</code>的基本例子，这可能是你的应用程序所需要的。但是如果你的应用程序需要比我们到目前为止所介绍的更多的功能，你也可以从这个库中得到更多。所以我们来看看吧！</p>
<p>当涉及到在Popper中添加或更改功能时，我们所需要的就是<code>usePopper</code>钩子的modifiers属性。默认情况下，Popper附带了一些默认修改器，其中包括:</p>
<ul>
<li><code>popperOffset</code> —用于在参考元素周围定位弹出器元素</li>
<li><code>offset</code> —用于沿其参考元素移动弹出器元素<ul>
<li>也用于将其移至其参考元素或从其参考元素移出</li>
</ul>
</li>
<li><code>popperOverflow</code> —通过防止弹出器被切断，帮助保持弹出器在其边界区域内可见</li>
<li><code>arrow</code> —用于为工具提示指定一个箭头，并沿工具提示定位</li>
<li><code>flip</code> —用于在需要时翻转工具提示<ul>
<li>也用于指定翻转功能的工作方式</li>
</ul>
</li>
<li><code>hide</code> —当popper元素与其参考元素分离时，用于隐藏popper元素</li>
</ul>
<p>所有这些默认修改器，以及这里没有提到的任何其他修改器，都是Popper用来让你的工具提示完成它的工作的。我们可以创建更多的修改器或者更新当前的修改器来满足我们的需求。</p>
<p>首先，让我们看看如何创建修改器。</p>
<h3 id="creating-custom-modifiers">创建自定义修改器</h3>
<p>修改器需要四个属性才能工作:</p>

<p><code>name</code>属性表示修饰符的名称。就像每个默认修改器都有名字一样，你的也应该有。该名称使得从库的其他部分引用修改器成为可能。</p>
<p>每个修改器应该有一个唯一的名字，这样你就不会覆盖一个默认的或者自定义的修改器。因为修饰符的相关性以降序增加，所以在必要时，数组底部的修饰符将总是覆盖它前面的修饰符。</p>
<p>一个简单的例子是改变弹出元素和参考元素之间的距离:</p>
<pre class="language-javascript hljs">const { styles, attributes } = usePopper(referenceEl, popperEl, {
   modifiers: [
     {
       name: "offset",
       options: {
         offset: [0, 10] // [skidding, distance]
       }
     }
   ]
 });</pre>
<p>“阶段”属性与Popper修改器生命周期的三个不同核心阶段相关:</p>
<ul>
<li><code>main</code> —对于只想执行逻辑的修饰符</li>
<li><code>read</code> —对于只想从DOM中读取的修饰符</li>
<li><code>write</code>–对于只需要写入DOM的修饰符</li>
</ul>
<p>这有助于分组Popper对DOM的访问。Popper还为每个主要阶段提供了两个子阶段— <code>beforeMain</code>和<code>afterMain</code>。</p>
<p><code>enabled</code>属性是一个布尔值，它指定修改器是否被启用。默认情况下，上面列出的默认修改器是启用的，但是您可以使用<code>enabled</code>属性轻松地禁用它们中的任何一个，如下所示:</p>
<pre class="language-javascript hljs">const { styles, attributes } = usePopper(referenceEl, popperEl, {
  modifiers: [
    {
      name: 'flip',
      enabled: false
    }
  ]
});</pre>
<p>上面的例子将阻止工具提示翻转。只是一个旁注，关闭翻转模式也会关闭将放置设置为自动的功能。换句话说，必须启用“翻转”修改器，自动放置才能工作。</p>
<p><code>fn</code>属性是一个返回状态对象的函数，它实际上是创建的弹出器的状态。该函数还用于向修改器提供逻辑。</p>
<p>传统上，修饰符上的函数会创建一个无限循环，因为<code>react-popper</code>对所提供的配置进行浅层比较。对于内联函数，浅层比较会失败，并使代码认为配置发生了变化。</p>
<p>对此的解决方案是使用<a href="https://blog.logrocket.com/react-hooks-cheat-sheet-unlock-solutions-to-common-problems-af4caf699e70/#usememo"> React的</a> <code><a href="https://blog.logrocket.com/react-hooks-cheat-sheet-unlock-solutions-to-common-problems-af4caf699e70/#usememo">useMemo</a></code> <a href="https://blog.logrocket.com/react-hooks-cheat-sheet-unlock-solutions-to-common-problems-af4caf699e70/#usememo">钩子</a>或者在组件外声明函数。</p>
<p>还有其他属性用于<a href="https://popper.js.org/docs/v2/modifiers/#custom-modifiers">使用弹出器</a>创建修改器。例如，有一个requires属性，用于指定正在创建的修改器所依赖的修改器。</p>
<p>此外，还有一个选项属性，用于指定用于配置修饰符的所有属性。如果你想要更多的道具，你应该去<a href="https://popper.js.org/docs/v2/modifiers/#custom-modifiers"> Popper docs查看这些</a>。</p>
<p>现在，让我们创建我们的第一个自定义修改器。当工具提示位于引用元素的顶部时，此修改器将简单地改变工具提示的背景颜色:</p>
<pre class="language-javascript hljs"> const changeTooltipBg = useMemo(
   () =&gt; ({
     name: "tooltipBgChanger",
     enabled: true,
     phase: "write",
     fn: ({ state }) =&gt; {
       if (state.placement === "top") {
         popperEl.setAttribute('to-red', true);
       } else {
         popperEl.removeAttribute('to-red');
       }
     }
   }),
   [popperEl]
 );
  const { styles, attributes } = usePopper(referenceEl, popperEl, {
   placement: "bottom",
   modifiers: [
     changeTooltipBg
   ]
 });</pre>
<p>这意味着你也必须调整你的风格。参见CodeSandbox 中的<a href="https://codesandbox.io/s/popper-styled-components-e6n1w5?file=/src/Example5.js">示例。</a></p>
<p>请注意，我使用了<code>write</code>阶段，因为我们在这里<a href="https://blog.logrocket.com/virtual-dom-react/">向DOM </a>写入数据。</p>
<h3 id="using-default-modifiers">使用默认修饰符</h3>
<p>在我们结束这篇文章之前，我想让我们看看几个修饰语。我们将会看到一些对你的项目非常有用的默认修饰符。</p>
<h4>打滑和距离</h4>
<p><code>offset</code>修改器用于指定弹出器和参考元素之间的距离，以及弹出器元素沿参考元素的位移或滑动。</p>
<p>打滑和距离的值都作为数组传递，打滑作为第一个值。它们被传递到修改器的<code>options</code>对象的<code>offset</code>属性中:</p>
<pre class="language-javascript hljs">const { styles, attributes } = usePopper(referenceEl, popperEl, {
   modifiers: [
     {
       name: "offset",
       options: {
         offset: [0, 0] // [skidding, distance]
       }
     }
   ]
 });</pre>
<p>打滑和距离都接受正值和负值。对于滑动，如果工具提示当前位于顶部或底部，正值会向右移动或滑动工具提示。同样，如果工具提示当前位于左侧或右侧，它会将工具提示移动到顶部。同时，负值会产生相反的效果。</p>
<p>对于距离，正值会将工具提示推离参考元素。同时，负值会将工具提示推向参考元素，以便它可以覆盖在参考元素上。</p>
<p>除了直接指定值的数组之外，您还可以用函数来做这件事，这样您就可以动态地指定一个值。这是因为该函数返回一个具有<code>popper</code>、<code>reference</code>和<code>placement</code>属性的对象:</p>
<pre class="language-javascript hljs">const changeDistance = useMemo(
   () =&gt; ({
     name: "offset",
     options: {
       offset: ({ popper, reference, placement }) =&gt; {
         if (placement === "top" || placement === 'bottom') {
           return [0, popper.height / 2];
         }

         return [0, 0];
       }
     }
   }),
   []
 );

 const { styles, attributes } = usePopper(referenceEl, popperEl, {
   placement: "bottom",
   modifiers: [changeDistance]
 });</pre>
<p>popper和reference属性分别返回popper元素和reference元素的高度和宽度。</p>
<h4>添加箭头</h4>
<p>箭头对于指示弹出器指向的参考元素非常有用。就像使用popper元素一样，Popper也为箭头元素提供样式和属性。</p>
<p>将箭头添加到我们之前构建的工具提示项目的步骤是:</p>
<ul>
<li>创建箭头元素</li>
<li>引用箭头修饰符中的箭头元素</li>
<li>设置工具提示的样式</li>
</ul>
<p>现在让我们实施这些步骤。</p>
<p>第一步，让我们转到<code>App.jsx</code>文件，为箭头添加一个元素:</p>
<pre class="language-javascript hljs"> return (
   &lt;StyledAppContainer&gt;
     &lt;div&gt;
       &lt;LongEl /&gt;
       &lt;Button ref={setReferenceEl}&gt;I'm a mystery&lt;/Button&gt;
       &lt;Tooltip
         style={styles.popper}
         data-show="true"
         {...attributes.popper}
         ref={setPopperEl}
       &gt;
         &lt;p&gt;A tooltip with&lt;/p&gt;
         &lt;span
           ref={setArrowEl} // doesn't exist yet
           style={styles.arrow}
           {...attributes.arrow}
           className="arrow"
         /&gt;
       &lt;/Tooltip&gt;
       &lt;LongEl /&gt;
     &lt;/div&gt;
   &lt;/StyledAppContainer&gt;
 );</pre>
<p>请注意连接到表示箭头的元素的箭头的属性和样式。这不会有任何影响，因为我们没有在arrow修饰符中引用arrow元素。</p>
<p>对于第二步，我们仍然在<code>App.js</code>文件中工作。创建引用箭头元素的新状态，如下所示:</p>
<pre class="language-javascript hljs">const [arrowEl, setArrowEl] = useState(null);</pre>
<p>接下来，我们引用箭头修饰符中的箭头元素，如下所示:</p>
<pre class="language-javascript hljs">const { styles, attributes } = usePopper(referenceEl, popperEl, {
  placement: "left",
  modifiers: [
    { name: "arrow", options: { element: arrowEl } }
  ]
});</pre>
<p>最后，对于第三步，将Popper中的样式添加到箭头不会创建箭头。相反，它有助于始终沿着工具提示移动箭头:</p>
<p><img data-attachment-id="157869" data-permalink="https://blog.logrocket.com/using-react-popper-styled-components/attachment/img3-tooltip-moving-placement-arrow/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img3-Tooltip-moving-placement-arrow.gif" data-orig-size="730,324" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Tooltip-moving-placement-arrow" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img3-Tooltip-moving-placement-arrow-300x133.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img3-Tooltip-moving-placement-arrow.gif" decoding="async" class="aligncenter size-full wp-image-157869 jetpack-lazy-image" src="../Images/eb37f5f6725c2874eef43b6e7ec8da97.png" alt="Dark Grey Background With Small White Box Containing Multiple Text Lines. Arrow On Right Side Shown Moving Up And Down With Tooltip Moving Along With It" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/img3-Tooltip-moving-placement-arrow.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/img3-Tooltip-moving-placement-arrow.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="157869" data-permalink="https://blog.logrocket.com/using-react-popper-styled-components/attachment/img3-tooltip-moving-placement-arrow/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img3-Tooltip-moving-placement-arrow.gif" data-orig-size="730,324" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Tooltip-moving-placement-arrow" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img3-Tooltip-moving-placement-arrow-300x133.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/img3-Tooltip-moving-placement-arrow.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-157869" src="../Images/eb37f5f6725c2874eef43b6e7ec8da97.png" alt="Dark Grey Background With Small White Box Containing Multiple Text Lines. Arrow On Right Side Shown Moving Up And Down With Tooltip Moving Along With It" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/img3-Tooltip-moving-placement-arrow.gif"/></noscript>
<p>我们负责创建工具提示，并根据箭头的位置对其进行定位。在<code>App.styled.jsx</code>文件中找到<code>Tooltip</code>样式的组件，并添加这些样式:</p>
<pre class="language-javascript hljs">`
 .arrow,
 .arrow::before {
   position: absolute;
   width: 8px;
   height: 8px;
   background: inherit;
   transition: top 0.3s ease-in, bottom 0.3s ease-in, left 0.3s ease-in,
     right 0.3s ease-in;
 }

 .arrow {
   visibility: hidden;
 }

 .arrow::before {
   visibility: hidden;
   content: "";
   transform: rotate(45deg);
 }

 &amp;[data-popper-placement^="top"] &gt; .arrow {
   bottom: -4px;
 }

 &amp;[data-popper-placement^="bottom"] &gt; .arrow {
   top: -4px;
 }

 &amp;[data-popper-placement^="left"] &gt; .arrow {
   right: -4px;
 }

 &amp;[data-popper-placement^="right"] &gt; .arrow {
   left: -4px;
 }
`</pre>
<p>我们可以做的另一件事是当箭头到达弹出器的边缘时隐藏它，因为它现在在边缘看起来不太好。这样做很容易！我们所要做的就是创建一个自定义修改器，并检查箭头何时到达边缘:</p>
<pre class="language-javascript hljs">const hideArrowAtEdges = useMemo(
   () =&gt; ({
     name: "arrowHide",
     enabled: true,
     phase: "write",
     fn: ({ state }) =&gt; {
       const { arrow } = state.elements;

       if (arrow) {
         if (state.modifiersData.arrow.centerOffset !== 0) {
           arrowEl.setAttribute("data-hide", true);
         } else {
           arrowEl.removeAttribute("data-hide");
         }
       }
     }
   }),
   [arrowEl]
 );

 const { styles, attributes } = usePopper(referenceEl, popperEl, {
   placement: "left",
   modifiers: [
     { name: "arrow", options: { element: arrowEl } },
     hideArrowAtEdges
   ]
 });</pre>
<p>请随意在CodeSandbox 中与这个例子进行交互。</p>
<h4>隐藏popper元素</h4>
<p>当参考元素在视口中不再可见时，可以隐藏弹出器元素。</p>
<p>当参考元素不再可见时，hide修改器通过将属性<code>data-popper-reference-hidden</code>附加到popper元素来实现这一点。</p>
<p>我们所要做的就是选择属性并为其附加一个样式，如下所示:</p>
<pre class="language-javascript hljs">&amp;[data-popper-reference-hidden="true"] {
   visibility: hidden;
 }</pre>
<p><a href="https://e6n1w5.csb.app/example6">自己去看看</a>。</p>
<h2 id="using-react-portals-with-react-popper">通过<code>react-popper</code>使用React门户</h2>
<p>门户对于管理大规模应用程序中的弹出窗口至关重要。它们帮助管理popovers的DOM层次结构。</p>
<p>通常，你会<a href="https://blog.logrocket.com/zindex-react-native-stack-elements-best-practices/">想在小规模应用中使用</a> <code><a href="https://blog.logrocket.com/zindex-react-native-stack-elements-best-practices/">zIndex</a></code>。然而，<code>zIndex</code>对于较大的应用程序不是很有效，因为很难大规模地跟踪所有的zIndex值。</p>
<p>门户允许您在React的默认DOM层次结构之外呈现popovers。在React 中使用门户非常简单。</p>
<p>使用带有<code>react-popper</code>的门户并不需要库有什么特别的东西。你不需要打开任何东西；您只需要用门户包装popover并指向目的地:</p>
<pre class="language-javascript hljs">{createPortal(
    &lt;Tooltip
      style={styles.popper}
      data-show="true"
      {...attributes.popper}
      ref={setPopperEl}
    &gt;
     &lt;p&gt;A tooltip&lt;/p&gt;
     &lt;span
        ref={setArrowEl}
        style={styles.arrow}
        {...attributes.arrow}
        className="arrow"
      /&gt;
    &lt;/Tooltip&gt;,
    document.getElementById("popper")
)}</pre>
<p><a href="https://codesandbox.io/s/popper-styled-components-e6n1w5?file=/src/Example7.js:1217-1663">参见CodeSandbox </a>中的例子。</p>
<h2 id="comparing-floating-ui-popper">比较浮动UI和Popper</h2>
<p>2021年，Popper 的<a href="https://github.com/atomiks">创造者宣布</a><a href="https://opencollective.com/floating-ui/updates/popper-is-evolving-into-floating-ui"> Popper现在是浮动UI </a>。浮动UI只是Popper的下一个级别。</p>
<p>从特性、大小、跨平台支持、可伸缩性等方面来看，浮动UI客观上是更好的选择。</p>
<p>Popper v2相比v1有了很大的改进，但是<a href="https://blog.logrocket.com/popper-vs-floating-ui/">浮动UI才是未来。</a>与Popper只能在vanilla JavaScript和React中使用不同，浮动UI也可以在React Native和Vue中使用。</p>
<p>就他们的工作方式而言，没有太多不同。您可以随时从Popper 轻松地<a href="https://floating-ui.com/docs/migration">转换到浮动UI。</a></p>
<p>那么是什么让你在浮动UI上使用Popper呢？</p>
<p>浮动UI的一个缺点是它没有像Popper那样被广泛采用，所以与Popper相比，它的教程和项目样本更少。</p>
<p>然而，Popper现在的一个缺点是，创作者还宣布该库将保持低维护状态，他信守了自己的诺言。如果可以的话，我会推荐你转到浮动UI。</p>
<h2>结论</h2>
<p>在本教程中，我们了解了如何在React中使用Popper v2来更好地定位弹出器。我们研究了如何创建自定义修饰符来扩展<code>react-popper</code>，以及如何将React Portals与<code>react-popper</code>一起使用，这被证明是非常简单和有用的。</p>
<p>我们还研究了用样式化组件来设计我们的松饼的样式。顺便说一句，样式化组件不仅仅用于样式化popovers。您还可以使用它来设计React中的任何东西，无论是本文中看到的简单元素还是库中的组件。</p>
<p>就是这样。感谢您的阅读，祝您黑客生涯愉快。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
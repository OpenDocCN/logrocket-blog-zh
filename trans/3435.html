<html>
<head>
<title>WebView and Android back button navigation - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>WebView和Android后退按钮导航- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/customize-androids-back-button-navigation-webview/#0001-01-01">https://blog.logrocket.com/customize-androids-back-button-navigation-webview/#0001-01-01</a></blockquote><div><article class="article-post">
<p>WebView是一个Android组件，允许开发者在应用程序中显示网页。</p>
<p>WebView可以在多种场景中发挥作用。例如，它可以用来显示Web和Android之间的公共页面，比如“条款&amp;隐私”页面。它还可以用来显示页面，从而避免网络请求，然后解析数据以在Android布局中显示。</p>
<p>你可能会想，如果你可以在Android应用程序中显示网页，那么你就可以构建自己的浏览器应用程序！</p>
<p>默认情况下，WebView只有一个目标——显示网页。它不包括像真正的网络浏览器那样的功能，如导航控件或地址栏。但是，如果它是一个视图，并且您可以将它包含在活动布局中，那么您也可以包含自己的控件。</p>
<p>在本文中，我们将分享Android开发人员在使用WebView时经常遇到的常见问题的解决方案，例如如何定制Android的后退按钮导航。本文中的所有代码都是Kotlin。</p>
<p><em>向前跳转:</em></p>

<h2 id="handling-page-navigation">如果没有内容，处理页面导航和页面重新加载</h2>
<p>当用户点击WebView中的链接时，Android操作系统将尝试在能够处理URL的外部应用程序中打开它，例如浏览器:</p>
<p><img data-attachment-id="136089" data-permalink="https://blog.logrocket.com/customize-androids-back-button-navigation-webview/attachment/opening-app-in-browser/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/opening-app-in-browser.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Opening app in browser" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/opening-app-in-browser-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/opening-app-in-browser-485x1024.gif" decoding="async" class="aligncenter size-full wp-image-136089 jetpack-lazy-image" src="../Images/1e1e146d295f4f9ea3cb3f9f96b793c3.png" alt="Opening App in Browser" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/opening-app-in-browser.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/opening-app-in-browser.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136089" data-permalink="https://blog.logrocket.com/customize-androids-back-button-navigation-webview/attachment/opening-app-in-browser/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/opening-app-in-browser.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Opening app in browser" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/opening-app-in-browser-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/opening-app-in-browser-485x1024.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-136089" src="../Images/1e1e146d295f4f9ea3cb3f9f96b793c3.png" alt="Opening App in Browser" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/opening-app-in-browser.gif"/></noscript>
<p>要允许用户在他们的网页历史中向前和向后导航，您需要为WebView提供一个WebViewClient:</p>
<pre class="language-kotlin hljs">val myWebView: WebView = findViewById(R.id.webview)
myWebView.webViewClient = WebViewClient()</pre>
<p><img data-attachment-id="136091" data-permalink="https://blog.logrocket.com/customize-androids-back-button-navigation-webview/attachment/toggling-back-and-forward/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/toggling-back-and-forward.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Toggling back and forward" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/toggling-back-and-forward-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/toggling-back-and-forward-485x1024.gif" decoding="async" class="aligncenter size-full wp-image-136091 jetpack-lazy-image" src="../Images/d48d642ba2a1b00d8a193b4ae5064055.png" alt="Toggling Back and Forward" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/toggling-back-and-forward.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/toggling-back-and-forward.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136091" data-permalink="https://blog.logrocket.com/customize-androids-back-button-navigation-webview/attachment/toggling-back-and-forward/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/toggling-back-and-forward.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Toggling back and forward" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/toggling-back-and-forward-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/toggling-back-and-forward-485x1024.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-136091" src="../Images/d48d642ba2a1b00d8a193b4ae5064055.png" alt="Toggling Back and Forward" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/toggling-back-and-forward.gif"/></noscript>
<p>除了使用默认的<code>WebViewClient</code>，你也可以实现自己的，比如:</p>
<pre class="language-kotlin hljs">myWebView.webViewClient = object : WebViewClient() {
    …
}
</pre>
<p><code>WebViewClient</code>的两个最常被覆盖的行为是<code>onPageStarted</code>和<code>onPageFinished</code>。</p>
<pre class="language-kotlin hljs">myWebView.webViewClient = object : WebViewClient() {
     override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
         super.onPageStarted(view, url, favicon)
     }
      override fun onPageFinished(view: WebView?, url: String?) {
         super.onPageFinished(view, url)
     }
}
</pre>
<p>使用这两种方法，您可以了解页面何时开始和完成加载，并且可以访问URL。</p>
<p><code>onPageFinished</code>的一个常见实现是当页面完成加载时，如果内容高度为<code>0</code>则刷新网页，因为这可能表明出现了问题(例如，PDF可能无法在WebView上加载):</p>
<pre class="language-kotlin hljs">myWebView.webViewClient = object : WebViewClient() {
     override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
         super.onPageStarted(view, url, favicon)
     }
      override fun onPageFinished(view: WebView?, url: String?) {
              if (view?.contentHeight == 0) {
                  view.reload()
              } else {
                 super.onPageFinished(view, url)
              }
     }
}
</pre>
<h2 id="handling-back-button-navigation">处理后退按钮导航</h2>
<p>如前所述，WebView没有内置导航控件。如果你打开了一个页面，然后点击了Android的后退按钮，它将不会转到WebView上之前访问过的页面。相反，它将在应用程序内部导航，如下所示:</p>
<p><img data-attachment-id="136093" data-permalink="https://blog.logrocket.com/customize-androids-back-button-navigation-webview/attachment/navigating-to-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/navigating-to-application.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Navigating to application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/navigating-to-application-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/navigating-to-application-485x1024.gif" decoding="async" class="aligncenter size-full wp-image-136093 jetpack-lazy-image" src="../Images/38c540c2641f23ec4f6116608f299faf.png" alt="Navigating to Application" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/navigating-to-application.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/navigating-to-application.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136093" data-permalink="https://blog.logrocket.com/customize-androids-back-button-navigation-webview/attachment/navigating-to-application/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/navigating-to-application.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Navigating to application" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/navigating-to-application-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/navigating-to-application-485x1024.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-136093" src="../Images/38c540c2641f23ec4f6116608f299faf.png" alt="Navigating to Application" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/navigating-to-application.gif"/></noscript>
<p>通常，WebViews是在它们自己的活动上实现的。要解决这个问题，我们需要仔细看看我们能够访问的活动行为。</p>
<p>Activity类提供了各种覆盖和自定义行为的方法。一个例子是<code>onKeyDown</code>；当一个键被按下时，这个方法被调用。</p>
<p>我们可以使用这种方法来检测用户何时按下设备的后退按钮。这里有一个例子:</p>
<pre class="language-kotlin hljs">override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
    if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; webView.canGoBack()) {
        webView.goBack()
        return true
    }
    // If it wasn't the Back key or there's no webpage history, bubble up to the default
    // system behavior (probably exit the activity)
    return super.onKeyDown(keyCode, event)
}
</pre>
<p>WebView提供了一些有用的实用方法，比如<code>canGoBack</code>和<code>goBack</code>。</p>
<p>我们可以使用<code>canGoBack</code>来找出一个页面之前是否被加载过。我们可以使用<code>goBack</code>来加载上一页:</p>
<pre class="language-kotlin hljs">if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; webView.canGoBack()) 
</pre>
<p>上面的代码检查按下的键是否是设备的后退按钮，以及在按钮被按下之前是否加载了任何页面。如果结果是肯定的，就调用<code>goBack</code>方法。</p>
<p><code>onKeyDown</code>返回一个布尔值。如果我们想覆盖行为，我们返回<code>true</code>；否则，我们返回<code>false</code>。</p>
<p>通过将此代码添加到我们的活动中，我们应该会看到以下行为:</p>
<p><img data-attachment-id="136095" data-permalink="https://blog.logrocket.com/customize-androids-back-button-navigation-webview/attachment/back-button-going-backward/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/back-button-going-backward.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Back button going backward" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/back-button-going-backward-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/back-button-going-backward-485x1024.gif" decoding="async" class="aligncenter size-full wp-image-136095 jetpack-lazy-image" src="../Images/ab317d578aec2a6957b59edc27e4c368.png" alt="Back Button Going Backward" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/back-button-going-backward.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/back-button-going-backward.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136095" data-permalink="https://blog.logrocket.com/customize-androids-back-button-navigation-webview/attachment/back-button-going-backward/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/back-button-going-backward.gif" data-orig-size="730,1541" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Back button going backward" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/back-button-going-backward-142x300.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/back-button-going-backward-485x1024.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-136095" src="../Images/ab317d578aec2a6957b59edc27e4c368.png" alt="Back Button Going Backward" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/back-button-going-backward.gif"/></noscript>
<h2 id="analyzing-accessed-urls">分析访问的URL</h2>
<p>在某些情况下，我们可能希望将用户重定向到外部应用程序。例如，我们可能希望允许用户打开PDF。</p>
<p>为了实现这一点，WebViewClient提供了另一个可以被覆盖的方法，称为<code>shouldOverrideUrlLoading</code>:</p>
<pre class="language-kotlin hljs">myWebView.webViewClient = object : WebViewClient() {
    override fun shouldOverrideUrlLoading(
        view: WebView?,
        request: WebResourceRequest?
    ): Boolean {
        …
        return super.shouldOverrideUrlLoading(view, request)
    }
}
</pre>
<p>每次加载新的URL时都会调用这个方法。这使我们能够检查加载的是什么URL，并做出相应的反应:</p>
<pre class="language-kotlin hljs">myWebView.webViewClient = object : WebViewClient() {
    override fun shouldOverrideUrlLoading(
        view: WebView?,
        request: WebResourceRequest?
    ): Boolean {
        view?.url?.let { url -&gt;
           if (url.endsWith(".pdf")) {
               startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(url)))
               return true
           }
        }

        return super.shouldOverrideUrlLoading(view, request)
    }
}
</pre>
<p>WebView有一个名为<code>url</code>的属性，对应于当前加载的URL。我们可以获取该属性并确认URL是否以PDF扩展名结尾，如下所示:</p>
<p><code>if (url.endsWith(".pdf"))</code></p>
<p>如果URL确实以<code>.pdf</code>结尾，我们将它委托给操作系统来寻找一个可以处理该类型URL的应用程序。每次我们想要覆盖<code>shouldOverrideUrlLoading</code>时，必须返回<code>true</code>的值。</p>
<h2 id="showing-loading-screen">页面加载时显示加载屏幕</h2>
<p>为了改善用户体验，我们可以提供一种方式让用户知道页面仍在加载。我们可以通过覆盖<code>WebViewClient</code>上的<code>onPageStarted</code>和<code>onPageFinished</code>来实现，就像这样:</p>
<pre class="language-kotlin hljs">myWebView.webViewClient = object : WebViewClient() {
     override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
         super.onPageStarted(view, url, favicon)
     }
      override fun onPageFinished(view: WebView?, url: String?) {
         super.onPageFinished(view, url)
     }
}
</pre>
<p>假设您有一种显示加载屏幕的方式，比如包含进度条的弹出窗口，您可以分别在<code>onPageStarted</code>和<code>onPageFinished</code>上显示和关闭加载屏幕。</p>
<p>这里有一个例子:</p>
<pre class="language-kotlin hljs">myWebView.webViewClient = object : WebViewClient() {
     override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
         super.onPageStarted(view, url, favicon)
         showLoading()
     }
      override fun onPageFinished(view: WebView?, url: String?) {
         super.onPageFinished(view, url)
         dismissLoading()
     }
}
</pre>
<h2 id="handling-render-process-crashes">处理渲染进程崩溃</h2>
<p>另一个常见问题是当WebView的渲染进程崩溃时。这可能是因为系统终止了渲染器以回收急需的内存，或者是因为渲染进程本身崩溃。</p>
<p>如果崩溃堆栈跟踪包含以下消息，您通常会知道您正在处理这个问题:</p>
<pre class="language-kotlin hljs">Render process's crash wasn't handled by all associated webviews, triggering application crash.
</pre>
<p>错误信息也可能引用<code>processId</code>。</p>
<p>为了确保用户体验不会受到负面影响，必须处理崩溃，否则应用程序将关闭。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>出现此错误后，无法重用关联的WebView实例。相反，它必须被销毁并从视图层次结构中删除，并且必须创建一个新的WebView实例。</p>
<p>如果在访问特定网页时渲染进程崩溃，尝试加载相同的页面可能会导致相同的问题。</p>
<p>为了处理这个问题，我们需要在<code>WebViewClient</code>上覆盖<code>onRenderProcessGone</code>，就像这样:</p>
<pre class="language-kotlin hljs">myWebView.webViewClient = object : WebViewClient() {
    override fun onRenderProcessGone(view: WebView, detail: RenderProcessGoneDetail): Boolean {
        if (!detail.didCrash()) {
            Log.e("MY_APP_TAG", ("System killed the WebView rendering process " +
                "to reclaim memory. Recreating..."))

            myWebView?.also { webView -&gt;
                val webViewContainer: ViewGroup = findViewById(R.id.my_web_view_container)
                webViewContainer.removeView(webView)
                webView.destroy()
                myWebView = null
            }

            // By this point, the instance variable "myWebView" is guaranteed
            // to be null, so it's safe to reinitialize it.

            return true // The app continues executing.
        }

        Log.e("MY_APP_TAG", "The WebView rendering process crashed!")

        return false
    }
}
</pre>
<p>如果<code>RenderProcessGoneDetail</code> <code>didCrash()</code>返回值<code>false</code>，这意味着进程因为系统内存不足而被终止。在这种情况下，应用程序可以通过创建新的WebView实例来正常恢复。</p>
<p>当从<code>onRenderProcessGone</code>返回一个值<code>true</code>时，这意味着我们希望保持应用程序运行，而不是因为崩溃而关闭它。</p>
<p>如果<code>RenderProcessGoneDetail</code> <code>didCrash()</code>返回一个值<code>true</code>，这意味着进程由于内部错误而终止，比如内存访问冲突。这种情况下如果返回<code>false</code>，检测到渲染器崩溃后app会崩溃。</p>
<p>要更优雅地处理崩溃并允许应用程序继续执行，请遵循以下步骤:</p>
<ol>
<li>销毁当前WebView实例</li>
<li>指定应用程序如何继续执行的逻辑</li>
<li>从<code>onRenderProcessGone</code>返回<code>true</code></li>
</ol>
<h2>结论</h2>
<p>在本文中，我们调查了Android开发人员在使用WebView时遇到的一些最常见的问题，并提供了解决方案。具体来说，我们研究了如何:使用WebView定制Android的后退按钮导航，处理页面导航和页面重载(如果没有内容)，分析访问的URL，在页面加载时显示加载屏幕，以及处理渲染过程崩溃。</p>
<p>要了解更多关于WebView的信息，请查看官方文档中的<a href="https://developer.android.com/develop/ui/views/layout/webapps/webview" target="_blank" rel="noopener">在WebView中构建web应用</a>和<a href="https://developer.android.com/develop/ui/views/layout/webapps/managing-webview" target="_blank" rel="noopener">管理WebView对象</a>。</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款Android监控解决方案，可以帮助您即时重现问题，确定bug的优先级，并了解您的Android应用程序的性能。</p><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的Android应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p></div>
</div>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

 </div>    
</body>
</html>
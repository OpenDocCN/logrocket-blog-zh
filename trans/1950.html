<html>
<head>
<title>petite-vue: An Alpine alternative for progressive enhancement - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>petite-vue:渐进增强的阿尔卑斯山替代方案</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/petite-vue-alpine-alternative-progressive-enhancement/#0001-01-01">https://blog.logrocket.com/petite-vue-alpine-alternative-progressive-enhancement/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本文最后一次更新于 2022 年 8 月 12 日，以反映对<code>petite-vue</code>的更改，包括捆绑包大小。</em></p>
<p>根据 Vue 的创造者尤雨溪的说法，<code><a href="https://github.com/vuejs/petite-vue#comparison-with-standard-vue">petite-vue</a></code>是一种受 Alpine 启发的 Vue 替代版本，针对渐进增强进行了优化。对于熟悉 Vue 并希望将 Vue 添加到在服务器端渲染的项目中的开发人员来说，<code>petite-vue</code>提供了完美的方法。</p>
<p>在这篇文章中，我们将探索<code>petite-vue</code>做什么，它如何工作，以及它如何与标准 Vue 和 Alpine 的<a href="https://blog.logrocket.com/intro-to-alpine-js-for-vue-developers/">进行比较。我们还将介绍如何开始使用<code>petite-vue</code>,并看看它的一些用例。</a></p>

<h2 id="what-progressive-enhancement">什么是渐进增强？</h2>
<p>渐进式改进是一种方法，它允许 web 开发人员开始用 HTML 编程，并根据需要包含其他技术。您可以开始仅使用 HTML 静态构建网站，然后向页面添加交互性或客户端状态。</p>
<p><code>petite-vue</code>针对由服务器框架呈现的现有 HTML 页面上的小交互进行了优化，从而简化了渐进式增强。现在，让我们看看它是如何工作的。</p>
<h2 id="fundamental-features-petite-vue"><code>petite-vue</code>的基本特征</h2>
<p>为了理解<code>petite-vue</code>是如何工作的，我们必须考虑它的基本特征。</p>

<p>有了<code>petite-vue</code>，你就不用担心构建工具了。相反，您可以简单地将它包含在一个<code>script</code>标签中，以便在 HTML 页面中获得它的特性:</p>
<pre>&lt;script src="https://unpkg.com/petite-vue" defer init&gt;&lt;/script&gt;

&lt;!-- anywhere on the page --&gt;
&lt;div v-scope="{ count: 0 }"&gt;
  {{ count }}
  &lt;button @click="count++"&gt;inc&lt;/button&gt;
&lt;/div&gt;
</pre>
<h3 id="small-bundle-size">小捆尺寸</h3>
<p>在撰写本文时，Vue 和 Alpine 的最新版本的包大小分别为<a href="https://bundlephobia.com/package/vue@3.2.37"> 34.2kB </a>和<a href="https://bundlephobia.com/package/alpinejs@3.10.3"> 13.5kB </a> minified 和 gzipped。另一方面，<code>petite-vue</code>的束大小仅为<a href="https://bundlephobia.com/package/petite-vue@0.4.1"> 6。</a> <a href="https://bundlephobia.com/package/petite-vue@0.4.1"> 9 </a> <a href="https://bundlephobia.com/package/petite-vue@0.4.1"> kB </a>并且本意是轻量级的。</p>
<h3 id="vue-compatible-template-syntax">Vue 兼容模板语法</h3>
<p>已经熟悉 Vue 模板语法的开发人员会发现在 Vue 和<code>petite-vue</code>之间转换很容易。<span>作为 Vue 本身的子集，</span> <code>petite-vue</code> <span>使用了 Vue 的大部分相同语法。比如</span> <code>petite-vue</code> <span>使用类似</span> <code>{{ count }}</code> <span>的模板插值和类似</span> <code>@click</code> <span>的模板事件监听器。</span></p>
<h3 id="no-virtual-dom">没有虚拟 DOM</h3>
<p>与 Vue、React 和大多数其他前端库和框架不同，<code>petite-vue</code>不使用虚拟 DOM。相反，它就地改变了 DOM。因此，<code>petite-vue</code>在网页上运行，不需要编译器，减小了整体大小。</p>
<h3 id="driven-vue-reactivity">由<code>@vue/reactivity</code>驱动</h3>
<p><a href="https://github.com/vuejs/vue-next/tree/master/packages/reactivity"> <code>@vue/reactivity</code> </a>包负责处理 Vue 和 Alpine 中的反应性；<code>petite-vue</code>使用同样的反应技术。</p>
<h2 id="howpetitevuecomparestostandardvue"><code>petite-vue</code>与标准 Vue 相比如何</h2>
<p><code>petite-vue</code>在很多方面和 Vue 相似。如前所述，它提供了与标准 Vue 相同的模板语法和<code>@vue/reactivity</code>模型。然而，最显著的区别是<code>petite-vue</code>是为渐进增强而制造的。</p>
<p>标准 Vue 是为使用构建步骤来构建具有大量交互的单页面应用程序(spa)而设计的。Vue 使用渲染函数来替换现有的 DOM 模板，而另一方面，<code>petite-vue</code>遍历现有的 DOM 并对其进行适当的变异，因此不需要构建步骤。</p>
<h2 id="petite-vue-exclusive-features"><code>petite-vue</code>独家功能</h2>
<p><code>petite-vue</code>引入了一些标准 Vue 中没有的功能，有助于优化渐进式增强。让我们来看看他们吧！</p>
<h3 id="v-scope"><code>v-scope</code></h3>
<p>在<code>petite-vue</code>中，<code>v-scope</code>是一个标记页面中由<code>petite-vue</code>控制的区域的指令。您还可以使用<code>v-scope</code>指令来传递页面中特定区域可以访问的状态。</p>
<h3 id="v-effect"><code>v-effect</code></h3>
<p><code>v-effect</code>是用于执行<code>petite-vue</code>中内联反应语句的指令。在下面的代码片段中，<code>count</code>变量是反应性的，所以每当计数改变时<code>v-effect</code>就会重新运行，然后用<code>count</code>的当前值更新<code>div</code>:</p>
<pre>&lt;div v-scope="{ count: 0 }"&gt;
  &lt;div v-effect="$el.textContent = count"&gt;&lt;/div&gt;
  &lt;button @click="count++"&gt;++&lt;/button&gt;
&lt;/div&gt;
</pre>
<h3 id="lifecycle-events">生命周期事件</h3>
<p><code>petite-vue</code>附带了两个生命周期事件，<code>@mounted</code>和<code>@unmounted</code>，它们允许您监听<code>petite-vue</code>何时在您的页面上挂载或卸载。</p>
<h2 id="vue-compatible-features">Vue 兼容特性</h2>
<p>现在我们已经看到了<code>petite-vue</code>带来的新特性，让我们回顾一下它在 Vue 中已经存在的特性:</p>
<ul>
<li><code>{{ }}</code>:文本绑定</li>
<li><code>v-bind</code>和<code>:</code>:类别和样式特殊处理</li>
<li><code>v-on</code>和<code>@</code>:事件处理</li>
<li><code>v-model</code>:表示所有输入类型和非字符串<code>:value</code>绑定</li>
<li><code>v-if</code> / <code>v-else</code> / <code>v-else-if</code></li>
<li><code>v-for</code></li>
<li><code>v-show</code></li>
<li><code>v-html</code></li>
<li><code>v-pre</code></li>
<li><code>v-once</code></li>
<li><code>v-cloak</code></li>
<li><code>reactive()</code></li>
<li><code>nextTick()</code></li>
<li>模板参考</li>
</ul>
<h2 id="exclusive-vue-features">Vue 独有的功能</h2>
<p>由于范围小，<code>petite-vue</code>放弃了标准 Vue 中的一些功能:</p>
<ul>
<li><code>ref()</code>和<code>computed()</code></li>
<li>渲染函数:<code>petite-vue</code>没有虚拟 DOM</li>
<li>收集类型的反应性:<code>Map</code>、<code>Set</code>等。</li>
<li><code>Transition</code>、<code>keep-alive</code>、<code>&lt;teleport&gt;</code>和<code>&lt;suspense&gt;</code>组件</li>
<li><code>v-for</code>:深度破坏</li>
<li><code>v-on="object"</code></li>
<li><code>v-is</code>和<code>&lt;component :is="newComponent"&gt;</code></li>
<li><code>v-bind:style</code>自动前缀</li>
</ul>
<h2 id="how-petite-vue-compares-alpine">与阿尔卑斯山相比如何</h2>
<p>虽然<a href="https://blog.logrocket.com/getting-started-alpine/"> <code>petite-vue</code>受到阿尔卑斯山</a>的启发，并解决了类似的问题，但由于其极简主义和与 Vue 的兼容性，它与阿尔卑斯山不同。</p>
<p>例如，<code>petite-vue</code>大约是 Alpine 的一半大小，与 Alpine 不同，它没有配备过渡系统。</p>
<p>另外，Alpine 和<code>petite-vue</code>的设计不同。虽然 Alpine 在某些方面类似于 Vue 的结构，但<code>petite-vue</code>更符合标准 Vue，如果你想在 Vue 和<code>petite-vue</code>之间转换，可以最小化开销。</p>
<h2 id="getting-started-petite-vue">开始使用<code>petite-vue</code></h2>
<p>要开始使用<code>petite-vue</code>，您需要包含一个指向<code>petite-vue</code>包的<code>script</code>标签。举个例子，让我们创建一个由<code>petite-vue</code>支持的简单投票应用程序。</p>
<p>首先，创建一个<code>index.html</code>文件。在它的主体中，添加以下代码片段:</p>
<pre> &lt;script src="https://unpkg.com/petite-vue" defer init&gt;&lt;/script&gt;
  &lt;div v-scope="{ upVotes: 0, downVotes: 0 }"&gt;
    &lt;p&gt;
      {{ upVotes }} &lt;button @click="upVotes++"&gt;&amp;#128077;&lt;/button&gt;
    &lt;/p&gt;
    &lt;p&gt;
      {{ downVotes }} &lt;button @click="downVotes++"&gt;&amp;#128078;&lt;/button&gt;
    &lt;/p&gt;
  &lt;/div&gt;
</pre>
<p>在浏览器解析 HTML 内容之后，<code>script</code>标签上的<code>defer</code>属性导致脚本加载<code>petite-vue</code>被加载。<code>init</code>属性告诉<code>petite-vue</code>自动查询并初始化所有有<code>v-scope</code>的元素，<code>v-scope</code>告诉<code>petite-vue</code>处理页面的哪个区域。我们还传递了对该区域可用的<code>upVotes</code>和<code>downVotes</code>状态。</p>
<h3>手动初始化</h3>
<p>如果您不想让<code>petite-vue</code>自动初始化所有具有<code>v-scope</code>属性的元素，您可以通过更改脚本来手动初始化它们:</p>
<pre>&lt;script src="https://unpkg.com/petite-vue"&gt;&lt;/script&gt;
&lt;script&gt;
  PetiteVue.createApp().mount()
&lt;/script&gt;
</pre>
<p>或者，您可以使用<code>petite-vue</code>的 ES 模块构建:</p>
<pre>&lt;script type="module"&gt;
  import { createApp } from 'https://unpkg.com/petite-vue?module'
  createApp().mount()
&lt;/script&gt;
</pre>
<h3><code>petite-vue</code> CDN 制作网址</h3>
<p>在我们的例子中，我们使用一个<a href="https://blog.logrocket.com/using-cdns-to-optimize-website-performance/"> CDN URL </a>访问<code>petite-vue</code>。我们使用了一个简写的 URL <code><a href="https://unpkg.com/petite-vue">https://unpkg.com/petite-vue</a></code>，这对于原型制作来说很好，但是对于生产来说不太好。我们希望避免解析和重定向成本，所以我们将在生产中使用完整的 URL。</p>
<p>全局构建生产 URL <code><a href="https://unpkg.com/petite-vue@0.4.1/dist/petite-vue.iife.js" rel="nofollow">https://unpkg.com/<span class="__cf_email__" data-cfemail="245441504d50410952514164140a100a15">[email protected]</span>/dist/petite-vue.iife.js</a></code>公开了<code>PetiteVue</code>全局，并且还支持自动初始化。</p>
<p>ESM 构建生产 URL <code><a href="https://unpkg.com/petite-vue@0.4.1/dist/petite-vue.iife.js" rel="nofollow">https://unpkg.com/<span class="__cf_email__" data-cfemail="255540514c51400853504065150b110b14">[email protected]</span>/dist/petite-vue.iife.js</a></code>必须在<code>&lt;scripttype="module"&gt;</code>块中使用。</p>
<h2 id="when-use-petite-vue">何时使用<code>petite-vue</code></h2>
<p>我们已经了解了很多关于<code>petite-vue</code>的特性和它能做什么。让我们回顾一下<code>petite-vue</code>最适合哪种情况:</p>
<ul>
<li>不需要构建工具时的快速原型制作</li>
<li>在服务器呈现的框架中添加 Vue 功能，如 Sails、Laravel 或 Rails</li>
<li>构建登录页面或营销页面，这些页面可以是静态的，很少交互</li>
<li>任何你通常会用到阿尔卑斯山的地方</li>
</ul>
<h2 id="conclusion">结论</h2>
<p>是 Vue 的一个轻量级版本，为页面增加了高效的交互。在本文中，我们通过考虑其独有的功能、与标准 Vue 的相似性以及为获得其轻质尺寸而进行的功能权衡，对<code>petite-vue</code>进行了初步了解。</p>
<p>在撰写本文时，<code>petite-vue</code>仍然非常新，并且包含了对任何潜在错误的免责声明。然而，<code>petite-vue</code>已经是一个很有潜力和实用性的功能选项了。它对于快速原型开发、将 Vue 功能分散到服务器呈现的框架中以及构建静态页面特别有帮助。</p>
<p>我希望你喜欢这篇文章！给我们留下评论，让我们知道你是否打算尝试<code>petite-vue</code>。</p><div class="code-block code-block-20">
<div class="blog-plug inline-plug vue-inline"><h2>像用户一样体验您的 Vue 应用</h2><p>调试 Vue.js 应用程序可能会很困难，尤其是当用户会话期间有几十个(如果不是几百个)突变时。如果您对监视和跟踪生产中所有用户的 Vue 突变感兴趣，</p><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/0d269845910c723dd7df26adab9289cb.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://files.readme.io/00591d0-687474703a2f2f692e696d6775722e636f6d2f6a3049327856572e706e67.png"/></noscript></a><a href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Vue 应用程序中发生的一切，包括网络请求、JavaScript 错误、性能问题等等。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。</p><p>LogRocket Vuex 插件将 Vuex 突变记录到 LogRocket 控制台，为您提供导致错误的环境，以及出现问题时应用程序的状态。</p><p>现代化您调试 Vue 应用的方式- <a class="signup" href="https://lp.logrocket.com/blg/vue-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
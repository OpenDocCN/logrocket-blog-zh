<html>
<head>
<title>Understanding primitive data types in Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>理解Rust - LogRocket博客中的原始数据类型</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-primitive-data-types-rust/#0001-01-01">https://blog.logrocket.com/understanding-primitive-data-types-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Rust有一个称为原语的数据类型列表。在本文中，我们将讨论Rust中原始数据类型的列表——我们将把它分为标量和复合类型——以及Rust中原始数据类型的局限性。</p>
<p>我们将涵盖:</p>

<p>本文旨在帮助那些刚刚开始使用Rust并希望快速理解和能够使用Rust中的原始数据类型的人。</p>
<h2 id="what-primitive-data-types">什么是原始数据类型？</h2>
<p>顾名思义，原始数据类型基本上就是编程语言自带的数据类型。它们是内置的，当组合在一起时，可以形成更复杂的数据类型，这些数据类型被称为非原始数据类型。</p>
<p>正如我们提到的，Rust编程语言附带了一系列内置的原始数据类型，开发人员可以将它们用作其他数据类型的构建块。</p>
<h2 id="review-rust-programming-language">Rust程序设计语言综述</h2>
<p>Rust将自己描述为一种系统编程语言，运行速度快得惊人，可以防止所有崩溃，并消除数据竞争。它在内存效率方面很好，因为它没有运行时或垃圾收集器。由于这个原因和许多其他原因，<a href="https://blog.logrocket.com/why-is-rust-popular/" target="_blank" rel="noreferrer noopener"> Rust是一种流行且深受喜爱的编程语言</a>。</p>
<p>目前，这种编程语言及其社区还相对年轻。这意味着有持续的开发来添加、改进和稳定各种特性、方法和特征实现。</p>
<p>通过简单的<a href="https://rust-cli.github.io/book/index.html" target="_blank" rel="noreferrer noopener">命令行界面(CLI) </a>、<a href="https://blog.logrocket.com/getting-started-with-webassembly-and-rust/" target="_blank" rel="noreferrer noopener"> WebAssembly (Wasm) </a>、联网、嵌入式，就可以很舒服地使用Rust。</p>
<p>人们大多喜欢谈论Rust是否值得学习或者是否有一个陡峭的学习曲线。但最终，这是由每个人来决定是否值得为你的个人需求而学习。</p>
<p>当然，让Rust与众不同的是，还有一些最值得注意的事情:</p>
<ul>
<li>这是一种设计良好的语言</li>
<li>与其他语言相比，它注重正确性和安全性</li>
<li>它具有良好的并发性和速度</li>
<li>它有一个非常强大的社区</li>
</ul>
<p>Rust由Graydon Hoare设计，于2010年7月7日首次亮相。截至本文发布时，这种编程语言是2022年8月11日发布的版本1.63.0 。</p>
<h2 id="primitive-data-types-rust">Rust中的原始数据类型</h2>
<p>让我们看看Rust提供的原始数据类型。</p>
<p>我们想首先将它们分为标量和复合数据类型。这两者的区别在于，复合类型在一个类型中包含多个值，而标量类型只包含一个值。</p>
<h3 id="scalar-primitive-types-rust">Rust中的标量原始类型</h3>
<p>Rust中有五种您应该熟悉的标量原语类型:</p>

<p>让我们看看每种类型的定义和例子。</p>
<h4 id="boolean"><code>bool</code>数据类型</h4>
<p>布尔数据类型可以分为真或假，如下所示:</p>
<pre class="language-rust hljs">let active:bool = true;
let inactive:bool = false;
</pre>
<p>如上所示，确保在声明布尔变量时使用了<code>bool</code>关键字。</p>
<p>布尔数据类型主要用于比较值或逻辑，例如，检查测试分数是A、B还是c。</p>
<h4 id="character"><code>char</code>数据类型</h4>
<p>字符类型是4字节数据类型。它用于存储单个字符，例如:</p>
<pre class="language-rust hljs">let first:char = 'a';
let second:char = 'b';
let symbol:char = '∞';
</pre>
<p>字符数据类型用于存储单个字符，允许Rust 中的<a href="https://blog.logrocket.com/guide-using-arenas-rust/" target="_blank" rel="noreferrer noopener">内存分配保持较小。</a></p>
<h4 id="integer"><code>integer</code>数据类型</h4>
<p>整数数据类型有很多种，分为两类:有符号的(I)和无符号的(u)。它们包括:<code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>isize</code>、<code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>usize</code>。以下是一些例子:</p>
<pre class="language-rust hljs">let height:u8 = 172; //u8
let weight:u8 = 68; // u8 
let size:u8 = 23; // u8
let data:i8 = -128 // i8
</pre>
<h4 id="floating"><code>floating</code>数据类型</h4>
<p>浮点数据类型总是<code>f32</code>或<code>f64</code>，其范围可以从负数到正数:</p>
<pre class="language-rust hljs">f32 ---&gt; -3.8x10^8 to +3.8x10^8
f64 ---&gt; -1.8x10^308 to +1.8x10^308 
</pre>
<p>浮点数就是我们所说的小数。参见下面的一些例子:</p>
<pre class="language-rust hljs">let interest:f32 = 1.20;
let returns:f32 = 2.80;
let agency:f64 = 10.0;
</pre>
<h4 id="unit"><code>unit</code>数据类型</h4>
<p>在Rust中，单元数据类型使用符号<code>()</code>，它主要用作避免使用<code>null</code>的机制。</p>
<p>任何不返回任何内容的表达式实际上都返回Rust中的<code>()</code>。它更像是类C语言中的<code>void</code>。</p>
<p>另一个用例类似于<code>Response&lt;(), String&gt;</code>，这意味着响应可能失败，也可能成功。</p>
<h3 id="compound-primitive-types-rust">Rust中的复合原始类型</h3>
<p>下面是Rust中的四种复合原始数据类型，我们将在下面介绍:</p>

<p>正如我们在上一节中所做的那样，让我们看看每种类型的定义和示例。</p>
<h4 id="array"><code>array</code>数据类型</h4>
<p>数组是包含一组元素的数据类型。它的大小总是固定的，并且是相同的数据类型，就像这样:</p>
<pre class="language-rust hljs">let counts: [i32; 7] = [4, 2, 4, 8, 3, 2, 4, 8];
let grade: [i32; 4] = [20, 40, 34, 70];
</pre>
<p>在上面的例子中，<code>counts</code>数组包含数据类型<code>i32</code>(整数)的<code>7</code>元素，而<code>grade</code>数组包含数据类型<code>i32</code>的<code>4</code>元素。</p>
<h4 id="string"><code>string</code>数据类型</h4>
<p>Rust 中有<a href="https://blog.logrocket.com/understanding-rust-string-str/" target="_blank" rel="noreferrer noopener">两种</a> <code><a href="https://blog.logrocket.com/understanding-rust-string-str/" target="_blank" rel="noreferrer noopener">string</a></code> <a href="https://blog.logrocket.com/understanding-rust-string-str/" target="_blank" rel="noreferrer noopener">数据类型:<code>String</code>(字符串对象)和<code>&amp;str</code>(字符串文字)。</a></p>
<p><code>String</code>对象不在核心语言中，而是在标准库中提供。它也是最常见的字符串类型，因为它是可变的。要创建一个<code>String</code>:</p>
<pre class="language-rust hljs">String::new();


let name = String::new();
name.push_str = 'Victor Jonah';
println("{}", name);
</pre>
<p>Rust中的<code>&amp;str</code>数据类型被认为是string slice，据说是不可变的，这意味着它们在程序的生命周期中不能被改变。看看下面的例子:</p>
<pre class="language-rust hljs">let name:&amp;str = 'Victor Jonah';
let company:&amp;str = 'LogRocket';
</pre>
<p>在上面的例子中，在程序的生命周期中，<code>name</code>将总是与字符串<code>Victor Jonah</code>相关联，而<code>company</code>将总是与字符串<code>LogRocket</code>相关联。</p>
<h4 id="slice"><code>slice</code>数据类型</h4>
<p>切片类似于数组，但也有一些不同。</p>
<p>虽然数组大小是固定的，但切片的大小是动态的；在编译时长度是未知的，数据被分割到一个新的集合中。请参见下面的示例:</p>
<pre class="language-rust hljs">let grades: [132:6] = [20, 10, 30, 40, 50, 10, 20];
let slice = &amp;[20...4]; // 20, 10, 30, 40
</pre>
<p>切片也是一个指向上面的字符串对象的指针，在这里我们可以检索字符串值中的某个字符。我们也可以借用切片中的元素在其他地方使用。</p>
<h4 id="tuples"><code>tuple</code>数据类型</h4>
<p>在JavaScript等其他语言中，元组被称为对象。它们是包含不同类型元素的固定数据类型，而数组只能包含相同类型的元素。</p>
<pre class="language-rust hljs">let employee: (&amp;str, i32, &amp;str) = ('Victor Jonah', 25, 'Technical Writer');
</pre>
<p>在上面的例子中，tuple <code>employee</code>包含三个元素:一个字符串(<code>Victor Jonah</code>)、一个整数(<code>25</code>)和另一个字符串(<code>Technical Writer</code>)。</p>
<h2 id="limitations-rust-primitive-types">铁锈的局限性及其原始类型</h2>
<p>顺便提一下，讨论Rust编程语言的<a href="https://blog.logrocket.com/what-you-cant-do-in-rust-and-what-to-do-instead/" target="_blank" rel="noreferrer noopener">限制是很重要的。大多数人都说或声称Rust非常可爱——这是真的——但是有几点需要考虑。</a></p>
<p>首先要注意的是，它的学习曲线很陡；Rust作为一门语言需要更多的时间去学习，因为它是一门系统编程语言，具有高级编程概念。</p>
<p>当涉及到信任原始数据类型并将它们组合在一起时，有很多东西需要学习，比如模式匹配、指针、字符串文字、三种类型的数组等等。然而，这是值得你花时间的。</p>
<p>根据我的观察，陡峭的学习曲线主要是由于在使用Rust的早期，Rust文档缺乏清晰度。</p>
<p>这让我想到了第二点:Rust社区可能在开始时不太引人注目，但是当你接触到它时，它是欢迎的、活跃的和有帮助的。</p>
<p>还有一点需要注意的是，Rust是一种静态编程语言，它非常严格，以至于在编译之前所有的东西都要声明。这是Rust的主要原则之一，它强制要求在编译时检查一切。</p>
<p>这可能会减慢开发速度，但也是有好处的，因为当大多数事情都在编译时检查时，程序在运行时失败的可能性就更小了。</p>
<h2 id="conclusion">结论</h2>
<p>Rust原始数据类型是内置的，它们的用例正是典型编程语言所需要的。这些数据类型有两种形式:标量和复合。</p>
<p>了解和理解Rust中所有不同的原始数据类型对您的Rust之旅非常有帮助。为此，我写了这篇短文。感谢您的阅读。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What to expect from ES2022 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>对 ES2022 - LogRocket 博客有什么期待</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/es2022-what-to-expect/#0001-01-01">https://blog.logrocket.com/es2022-what-to-expect/#0001-01-01</a></blockquote><div><article class="article-post">
<p>根据<a href="https://insights.stackoverflow.com/survey/2020#technology-programming-scripting-and-markup-languages-professional-developers" target="_blank" rel="noopener"> Stack Overflow 的 2020 年开发者调查</a>，JavaScript 是最常用的编程语言，并且它还在不断发展。事实上，自 2015 年以来，每年都有新的 ECMAScript 规范发布。在撰写本文的时候，几个新的特性提案已经通过了第四个提案阶段<a href="https://github.com/tc39/proposals/blob/main/finished-proposals.md" target="_blank" rel="noopener">，并有望被包含在 JavaScript 的第 13 个版本 ES2022 中。</a></p>
<p>在本文中，我们将了解预计在 2022 年年中发布的八项功能提案:</p>

<h2 id="delaying-the-execution-of-modules-with-top-level-await">用顶层<code>await</code>延迟模块的执行</h2>
<p>ES2022 将使开发人员能够在异步(<code>async</code>)函数范围之外使用<code>await</code>，从而更易于在模块级别使用。</p>
<p>以下是在 ES2022 之前如何使用<code>await</code>的示例:</p>
<pre class="language-javascript hljs">import users from './users'

const getUsers = async() =&gt; {
  let users = await users()
  return users
}
</pre>
<p>下面是同一个例子，展示了如何在 ES2022 下使用<code>await</code>:</p>
<pre class="language-javascript hljs">let users = await import './users'
</pre>
<p>顶层<code>await</code>特性延迟当前模块和父模块的执行，直到导入的模块被加载。使用这个特性，模块可以使用运行时值来确定依赖关系。顶级的<code>await</code>也可以作为依赖关系的后备。</p>
<pre class="language-javascript hljs">let users;
try {
  users = await import('https://example1.com/users');
} 
catch {
  users = await import('https://example2.com/users');
}
</pre>
<h2 id="regexp-match-indices-with-the-d-flag"><code>RegExp</code>匹配带有<code>d</code>标志的索引</h2>
<p>正则表达式匹配是用于在字符串中查找特定字符组合的模式。结果，<code>RegExp.exec</code>和<code>String.matchAll</code>返回匹配的列表。</p>
<pre class="language-javascript hljs">const names = 'Names: John, Frank, Johnson, Kelly'
const regex = /(John)/g;

// .exec
// RegExp(regex).exec(names);
// [
//   'John',
//   index: 7,
//   input: 'Names: John, Frank, Johnson, Kelly',
//   groups: undefined
// ]

// matchAll
const matches = [...names.matchAll(regex)];
matches[0];
// [
//   'John',
//   'John',
//   index: 7,
//   input: 'Names: John, Frank, Johnson, Kelly',
//   groups: undefined
// ]
</pre>
<p><code>RegExp.exec</code>单独传递结果，而<code>String.matchAll</code>返回一个迭代器，可用于迭代所有匹配。</p>
<p>ES2022 将允许开发者使用<code>d</code>标志来指定<code>RegExp</code>结果中<code>matches</code>的开始和结束索引。这里有一个例子:</p>
<pre class="language-javascript hljs">const names = 'Names: John, Frank, Johnson, Kelly'
const regex = /(John)/gd;
const matches = [...names.matchAll(regex)];
matches[0];
// [
// "John",
// "John",
// groups: undefined
// index: 7
// indices:[]
//  [7, 11],
//  [7, 11]
// ]
// groups: undefined
</pre>
<h2 id="class-field-declarations"><code>class</code>字段声明</h2>
<h3 id="defining-and-enforcing-private-fields-with-the-hash-prefix">使用前缀<code>#</code>定义和实施私有字段</h3>
<p>在 ES2022 之前，类字段在<code>constructor</code>中简单定义。前缀为下划线(<code>_</code>)的字段传统上在类外是不可访问的，因为它们被认为是私有的。看一下下面的示例代码:</p>
<pre class="language-javascript hljs">class User {

  constructor(){

      // public field
      this.name = 'kodex'

      // private field
      this._password = '1234';
  }
}

const user = new User();
console.log(user.name);
// name - public fields are accessible outside the classes

user._password = 'qwert';
console.log(user._password);
// password - no error thrown, we can access it from outside the class
</pre>
<p>在这个例子中，私有属性<code>_password</code>在类的外部被访问和修改。</p>
<p>ES2022 将使开发人员只需在字段名前插入一个<code>#</code>前缀，即可定义和实施私有字段。ES2022 还消除了在<code>constructor()</code>中定义公共或私有字段的需要。</p>
<p>考虑下面的例子:</p>
<pre class="language-javascript hljs">class User {

  // public field
  name = 'kodex'

  // private field
  #password = '1234';
}

const  user = new User()

console.log(user.#password);
user.#password = 'qwert';
// error - Private field '#password' must be declared in an enclosing class
</pre>
<p>在这段代码中，试图访问类外部的私有字段会导致错误。</p>
<h3 id="restricting-private-field-methods-and-accessors-with-the-hash-prefix">用前缀<code>#</code>限制私有字段方法和访问器</h3>
<p>ES2022 还允许开发人员使用带有私有方法和访问器的<code>#</code>前缀(“getters”和“setters”)来限制类的方法和变量。这使方法和访问器严格保持在内部，并防止它们被类外访问。这里有一个例子:</p>
<pre class="language-javascript hljs">class User {

  // public field
  name = 'kodex'

  // private field
  #password = '1234';

  #getPwd(){
    return this.#password
  }

  set #setPwd(data){
    this.#password = data
  }
}

const user = new User()

// Error - Private field '#getPwd' must be declared in an enclosing class
console.log(user.#getPwd);

// Error - Private field '#setPwd' must be declared in an enclosing class
user.#setPwd = 'qwert';```
</pre>
<h3 id="specifying-static-fields-and-private-static-methods-with-the-static-keyword">用<code>static</code>关键字指定静态字段和私有静态方法</h3>
<p>静态<code>class</code>字段和方法只能在类原型中访问，而不能在类的每个实例中访问。在 ES2022 之前，<code>class</code>的静态字段可以指定如下:</p>
<pre class="language-javascript hljs">class Animal {}
Animal.cow = "mammal"
</pre>
<p>在 ES2022 中，<code>static</code>关键字可以用来指定<code>class</code>的静态字段和私有静态方法。这里有一个例子:</p>
<pre class="language-javascript hljs">class Animal {
static cow = "mammal"
}
</pre>
<h2 id="ergonomic-brand-checks-for-private-fields-using-the-in-keyword">使用<code>in</code>关键字对私有字段进行人体工程学品牌检查</h2>
<p>试图访问一个类之外的私有字段会导致抛出一个异常，而不是返回<code>undefined</code>。我们可以在类内部使用<code>try</code> / <code>catch</code>来确定私有字段是否存在。然而，这种方法的问题是很难确定异常的来源。</p>
<p>ES2022 将为开发人员提供关键字<code>in</code>,该关键字可用于生成指示私有字段存在的布尔值。这个简单的解决方案不需要<code>try</code> / <code>catch</code>方法或异常:</p>
<pre class="language-javascript hljs">class Person{
  #name = 'Kelly';
  get #getName(){
    return #name;
  }
  set #setName(){
    #name = 'Anna';
  }
  static hasTitle(obj){
    return #name in obj;
  }
}
</pre>
<h2 id="negative-indexing-with-the-at-method">使用<code>.at()</code>方法进行负步进</h2>
<p><a href="https://blog.logrocket.com/using-new-javascript-at-method/" target="_blank" rel="noopener"><code>.at()</code>方法提供了对数组或字符串</a>的任何索引的简单访问，无论是正数还是负数。这里有一个例子:</p>
<pre class="language-javascript hljs">array= [1, 2, 3, 4, 5]
console.log(array[array.length-1]); // 5
console.log(array.at(-1)); // 5
</pre>
<p>ES2022 将使开发人员能够将<code>.at()</code>方法添加到一个数组中，并使用负整数值从数组的末尾向后计数。</p>
<h2 id="more-accessible-object-prototype-hasownproperty-with-the-objecthasownmethod">使用<code>Object.hasOwn()</code>方法更容易访问<code>Object.prototype.hasOwnProperty</code></h2>
<p>按照惯例，<code>hasOwnProperty</code>不能在原型本身之外使用。一个对象可能有一个名为<code>hasOwnProperty</code>的属性，它不同于<code>Object.prototype.hasOwnProperty</code>。这里有一个例子:</p>
<pre class="language-javascript hljs">const employee = {
  hasOwnProperty:()=&gt; {
    return false
  }
}
obj.hasOwnProperty('prop'); // false
</pre>
<p>ES2022 将使开发人员能够通过使用<code>Object.hasOwn()</code>方法来解决这个问题。该方法将对象作为第一个参数，将我们希望验证的属性作为第二个参数:</p>
<pre class="language-javascript hljs">const employee = {
name: 'Grace',
age: 18
}
Object.hasOwn(employee, 'name'); // true
Object.hasOwn(employee, 'position'); // false</pre>
<h2 id="initialization-during-class-definition-evaluation-with-static-blocks">使用<code>static{}</code>程序块进行类定义评估时的初始化</h2>
<p>传统上，像<code>try</code> / <code>catch</code>这样的语句是在初始化期间在类体之外进行计算的。</p>
<pre class="language-javascript hljs">class UserStatus{
    status = false;
    get getStatus(){
        if(!this.#status){
            throw new Error('User is not active');
        } 
        return this.#status
    }
}

// evaluate outside the class body
try {
    const state = UserStatus.getStatus;
    UserStatus.status = state
} catch {
    UserStatus.status = false
}
</pre>
<p>ES2022 将允许开发者使用<code>static{}</code>块来评估类声明范围内的语句。这在需要设置多个静态字段的情况下非常有用。<code>static{}</code>块允许访问一个类的私有状态(方法和字段),并允许在同一个作用域中声明的类或函数之间共享信息。</p>
<pre class="language-javascript hljs">let initState;

class UserStatus{
    #status = false;

    get getStatus(){
        if(!this.#status){
            throw new Error('User is not active');
        } 
        return this.#status
    }
    static {
        initState = () =&gt; {
            this.#status = this.getStatus;
        }
    }
}

initState();
</pre>
<h2 id="chaining-errors-with-the-cause-property">用<code>cause</code>属性链接错误</h2>
<p>传统上，在运行时使用上下文信息(如错误消息和错误实例属性)来识别和处理错误。如果错误发生在深度嵌套的函数中，在缺乏适当的异常设计模式的情况下，很难确定其原因。</p>
<pre class="language-javascript hljs">function processData(arrayData) {
  return arrayData.map(data =&gt; {
      try {
        const json = JSON.parse(data);
        return json;
      } catch (error) {
        // throw random error
      }
    });
</pre>
<p>在 ES2022 中，<code>cause</code>属性作为一个额外的参数被添加到<code>Error()</code>构造函数中，允许链接错误，而不需要在条件中包装错误的不必要的手续。</p>
<pre class="language-javascript hljs">function processData(arrayData) {
  return arrayData.map(data =&gt; {
      try {
        const json = JSON.parse(data);
        return json;
      } catch (err) {
        throw new Error(
          `Data processing failed`,
          {cause: err}
        );
      }
    });
}</pre>
<h2 id="conclusion">结论</h2>
<p>开发人员必须了解最新的语言规范。在本文中，我们研究了 JavaScript 的 ES2022 规范将提供的八个新特性。JavaScript 在不断发展，每年都会增加新的特性。我们很高兴看到 ES2023 有哪些新功能！</p><div class="code-block code-block-27">
<div class="blog-plug inline-plug vanilla-javascript-cta"><h2>通过理解上下文，更容易地调试 JavaScript 错误</h2>
<p>调试代码总是一项单调乏味的任务。但是你越了解自己的错误，就越容易改正。</p>
<p>LogRocket 让你以新的独特的方式理解这些错误。我们的前端监控解决方案跟踪用户与您的 JavaScript 前端的互动，让您能够准确找出导致错误的用户行为。</p>
<a href="https://lp.logrocket.com/blg/javascript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/cbfed9be3defcb505e662574769a7636.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2020/06/reproduce-javascript-errors.gif"/></noscript></a>
<p>LogRocket 记录控制台日志、页面加载时间、堆栈跟踪、慢速网络请求/响应(带有标题+正文)、浏览器元数据和自定义日志。理解您的 JavaScript 代码的影响从来没有这么简单过！</p>
<a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
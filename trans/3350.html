<html>
<head>
<title>Rust Bevy Entity Component System - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Rust Bevy实体组件系统- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/rust-bevy-entity-component-system/#0001-01-01">https://blog.logrocket.com/rust-bevy-entity-component-system/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按</em> </strong> : <em>本帖包括来自《Bevy》撰稿人<a href="https://www.linkedin.com/in/alice-cecile-183116a3/?originalSubdomain=ca">爱丽丝·塞西尔</a>的补充内容。</em> <em>帮助和评论上</em> <a href="https://discord.com/invite/bevy"> <em>对张子华的不和谐</em> </a> <em>所带来的喜悦和逻辑大为赞赏。</em></p>
<p>Bevy是一个用Rust编写的游戏引擎，以非常符合人体工程学的实体组件系统而闻名。</p>
<p>在<a href="https://bevyengine.org/learn/book/getting-started/ecs/"> ECS模式</a>中，实体是由组件组成的独特事物，就像游戏世界中的物体一样。系统处理这些实体并控制应用程序的行为。是什么让<a href="https://bevyengine.org"> Bevy的API </a>如此优雅，用户可以在Rust中编写常规函数，Bevy将知道如何通过它们的类型签名调用它们，分派正确的数据。</p>
<p>关于如何使用ECS模式构建你自己的游戏，已经有大量的文档可用，比如非官方的Bevy Cheat Book 中的<a href="https://bevy-cheatbook.github.io/programming/ecs-intro.html">。相反，在本文中，我们将解释如何在Bevy本身中实现ECS模式。为此，我们将从头开始构建一个小型的、类似Bevy的API，它接受任意的系统函数。</a></p>
<p>这种模式非常通用，您可以将它应用到自己的Rust项目中。为了说明这一点，我们将在文章的最后一节更详细地讨论Axum web framework如何将这种模式用于其路由处理程序方法。</p>
<p>如果您熟悉Rust，并且对类型系统技巧感兴趣，那么这篇文章适合您。在我们开始之前，我建议看看我以前的一篇关于Bevy标签实现的文章。我们开始吧！</p>
<h2 id="tableofcontents">目录</h2>

<h2 id="bevys-system-functions-user-facing-api">Bevy的系统就像一个面向用户的API</h2>
<p>首先，让我们学习如何使用Bevy的API，这样我们就可以从它开始逆向工作，自己重新创建它。下面的代码展示了一个带有示例系统的小型应用程序:</p>
<pre class="language-rust hljs">use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins) // includes rendering and keyboard input
        .add_system(move_player) // this is ours
        // in a real game you'd add more systems to e.g. spawn a player
        .run();
}

#[derive(Component)]
struct Player;

/// Move player when user presses space
fn move_player(
    // Fetches a resource registered with the `App`
    keyboard: Res&lt;Input&lt;KeyCode&gt;&gt;,
    // Queries the ECS for entities
    mut player: Query&lt;(&amp;mut Transform,), With&lt;Player&gt;&gt;,
) {
    if !keyboard.just_pressed(KeyCode::Space) { return; }

    if let Ok(player) = player.get_single_mut() {
        // destructure the `(&amp;mut Transform,)` type from above to access transform
        let (mut player_position,) = player;
        player_position.translation.x += 1.0;
    }
}
</pre>
<p>在上面的代码中，我们可以将一个常规的Rust函数传递给<code>add_system</code>，Bevy知道如何处理它。更好的是，我们可以使用函数参数来告诉Bevy我们想要查询哪些组件。在我们的例子中，我们希望每个实体都有定制的<code>Player</code>组件。在幕后，Bevy甚至根据函数签名来推断哪些系统可以并行运行。</p>
<h2 id="add_system"><code>add_system</code>方法</h2>
<p>Bevy有很多API面。毕竟，它是一个完整的游戏引擎，除了实体组件系统之外，还有调度系统、2D和3D渲染器等等。在本文中，我们将忽略其中的大部分内容，而是专注于将函数作为系统添加并调用它们。</p>
<p>按照Bevy的例子，我们将调用我们添加系统的项目，<code>App</code>，并给它两个方法，<code>new</code>和<code>add_system</code>:</p>
<pre class="language-rust hljs">struct App {
    systems: Vec&lt;System&gt;,
}

impl App {
    fn new() -&gt; App {
        App { systems: Vec::new() }
    }

    fn add_system(&amp;mut self, system: System) {
        self.systems.push(system);
    }
}

struct System; // What is this?
</pre>
<p>但是，这就引出了第一个问题。什么是系统？在Bevy中，我们可以用一个有一些有用参数的函数来调用这个方法，但是我们如何在自己的代码中做到这一点呢？</p>
<h2 id="add-functions-systems">将功能添加为系统</h2>
<p>Rust中的<a href="https://blog.logrocket.com/rust-traits-a-deep-dive/">主要抽象之一是特征</a>，类似于其他语言中的接口或类型类。我们可以定义一个trait，然后为任意类型实现它，这样trait的方法就可以在这些类型上使用。让我们创建一个允许我们运行任意系统的<code>System</code>特征:</p>
<pre class="language-rust hljs">trait System {
    fn run(&amp;mut self);
}
</pre>
<p>现在，我们的系统有了一个特征，但是要在我们的函数中实现它，我们需要使用类型系统的一些附加特性。</p>
<p>Rust使用特征来抽象行为，函数自动实现一些特征，比如<a href="https://doc.rust-lang.org/1.62.1/std/ops/trait.FnMut.html"> <code>FnMut</code> </a>。我们可以为满足约束的所有类型实现特征:</p>
<p>让我们使用下面的代码:</p>
<pre class="language-rust hljs">impl&lt;F&gt; System for F where F: Fn() -&gt; () {
    fn run(&amp;mut self) {
        self(); // Yup, we're calling ourselves here
    }
}
</pre>
<p>如果您不习惯Rust，这段代码可能看起来很难读懂。没关系，这不是你在日常Rust代码库中看到的东西。</p>
<p>第一行实现了所有类型的系统特征，这些类型是带有返回某些内容的参数的函数。在下面的代码行中，<code>run</code>函数获取项目本身，因为这是一个函数，所以调用它。</p>
<p>这个虽然管用，但是相当没用。只能调用不带参数的函数。但是，在我们深入研究这个例子之前，让我们先对它进行修改，以便能够运行它。</p>
<h2 id="interlude-running-example">插曲:运行一个例子</h2>
<p>我们上面对<code>App</code>的定义只是一个草稿；为了让它使用我们新的<code>System</code>特征，我们需要让它更复杂一点。</p>
<p>由于<code>System</code>现在是特征而不是类型，我们不能再直接存储它了。我们甚至不知道<code>System</code>有多大，因为它可能是任何东西！相反，我们需要把它放在一个指针后面，或者如Rust所说，把它放在一个<code>Box</code>中。不用存储实现<code>System</code>的具体东西，只存储一个指针。</p>
<p>这是Rust类型系统的一个技巧:您可以使用trait对象来存储实现特定特征的任意项目。</p>
<p>首先，我们的应用程序需要存储一个盒子列表，其中包含的东西是一个<code>System</code>。实际上，它看起来像下面的代码:</p>
<pre class="language-rust hljs">struct App {
    systems: Vec&lt;Box&lt;dyn System&gt;&gt;,
}
</pre>
<p>现在，我们的<code>add_system</code>方法也需要接受任何实现<code>System</code>特征的东西，并将其放入列表中。现在，参数类型是通用的。我们使用<code>S</code>作为实现<code>System</code>的占位符，因为Rust希望我们确保它对整个程序都有效，所以我们也被要求添加<code>'static</code>。</p>
<p>现在，让我们添加一个方法来实际运行应用程序:</p>
<pre class="language-rust hljs">impl App {
    fn new() -&gt; App { // same as before
        App { systems: Vec::new() }
    }

    fn add_system&lt;S: System + 'static&gt;(mut self, system: S) -&gt; Self {
        self.systems.push(Box::new(system));
        self
    }

    fn run(&amp;mut self) {
        for system in &amp;mut self.systems {
            system.run();
        }
    }
}
</pre>
<p>有了这个，我们现在可以写一个如下的小例子:</p>
<pre class="language-rust hljs">fn main() {
    App::new()
        .add_system(example_system)
        .run();
}

fn example_system() {
    println!("foo");
}
</pre>
<p>到目前为止，你可以使用<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=3fe777f4a178aac4568c05dd621644b6">的全部代码</a>。现在，让我们回到更复杂的系统功能的问题上来。</p>
<h2 id="system-functions-parameters">带参数的系统功能</h2>
<p>让我们让下面的函数成为一个有效的<code>System</code>:</p>
<pre class="language-rust hljs">fn another_example_system(q: Query&lt;Position&gt;) {}

// Use this to fetch entities
struct Query&lt;T&gt; { output: T }

// The position of an entity in 2D space
struct Position { x: f32, y: f32 }
</pre>
<p>看似简单的选择是为<code>System</code>添加另一个实现，以添加带有一个参数的函数。但是，可悲的是，Rust编译器会告诉我们有两个问题:</p>
<ol>
<li>如果我们为一个具体的函数签名添加一个实现，<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=851bba8bbe9b29df018b2d30c8d9f838">两个实现将会冲突</a>。按下<strong>运行</strong>查看错误</li>
<li>如果我们使接受的函数通用，它将是一个<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ddc7b3af90e6af418bc99fd9b351c9ee">无约束类型参数</a></li>
</ol>
<p>我们需要用不同的方法来解决这个问题。让我们首先为我们接受的参数引入一个特征:</p>
<pre class="language-rust hljs">trait SystemParam {}

impl&lt;T&gt; SystemParam for Query&lt;T&gt; {}
</pre>
<p>为了区分不同的<code>System</code>实现，我们可以添加类型参数，这成为其签名的一部分:</p>
<pre class="language-rust hljs">trait System&lt;Params&gt; {
    fn run(&amp;mut self);
}

impl&lt;F&gt; System&lt;()&gt; for F where F: Fn() -&gt; () {
    //         ^^ this is "unit", a tuple with no items
    fn run(&amp;mut self) {
        self();
    }
}

impl&lt;F, P1: SystemParam&gt; System&lt;(P1,)&gt; for F where F: Fn(P1) -&gt; () {
    //                             ^ this comma makes this a tuple with one item
    fn run(&amp;mut self) {
        eprintln!("totally calling a function here");
    }
}
</pre>
<p>但是现在，问题变成了在所有我们接受<code>System</code>的地方，我们需要添加这个类型参数。更糟糕的是，当我们试图存储<code>Box&lt;dyn System&gt;</code>时，我们也必须在那里添加一个:</p>
<pre class="language-rust hljs">error[E0107]: missing generics for trait `System`
  --&gt; src/main.rs:23:26
   |
23 |     systems: Vec&lt;Box&lt;dyn System&gt;&gt;,
   |                          ^^^^^^ expected 1 generic argument
…
error[E0107]: missing generics for trait `System`
  --&gt; src/main.rs:31:42
   |
31 |     fn add_system(mut self, system: impl System + 'static) -&gt; Self {
   |                                          ^^^^^^ expected 1 generic argument
…
</pre>
<p>如果您创建所有实例<code>System&lt;()&gt;</code>并注释掉<code>.add_system(another_example_system)</code>，我们的代码将会编译。</p>
<h2 id="storing-generic-systems">存储通用系统</h2>
<p>现在，我们的挑战是达到以下标准:</p>
<ol>
<li>我们需要一个知道其参数的通用特征</li>
<li>我们需要在一个列表中存储通用系统</li>
<li>我们需要能够在迭代时调用这些系统</li>
</ol>
<p>这是研究Bevy代码的好地方。函数不实现<code><a href="https://docs.rs/bevy/0.8.0/bevy/ecs/system/trait.System.html">System</a></code>，而是实现<a href="https://docs.rs/bevy/0.8.0/bevy/ecs/system/trait.SystemParamFunction.html"> <code>SystemParamFunction</code> </a>。另外，<a href="https://docs.rs/bevy/0.8.0/bevy/app/struct.App.html#method.add_system"> <code>add_system</code> </a>不带一个<code>impl System</code>，而是一个<code>impl</code> <a href="https://docs.rs/bevy/0.8.0/bevy/ecs/schedule/trait.IntoSystemDescriptor.html"> <code>IntoSystemDescriptor</code> </a>，进而使用一个<a href="https://docs.rs/bevy/0.8.0/bevy/ecs/system/trait.IntoSystem.html"> <code>IntoSystem</code> </a>性状。</p>
<p><a href="https://docs.rs/bevy/0.8.0/bevy/ecs/system/struct.FunctionSystem.html"> <code>FunctionSystem</code> </a>，一个struct，会实现<code>System</code>。</p>
<p>让我们从中获得灵感，让我们的特性再次变得简单。我们之前的代码继续作为一个叫做<code>SystemParamFunction</code>的新特性。我们还将引入一个<code>IntoSystem</code>特征，我们的<code>add_system</code>函数将接受它:</p>
<pre class="language-rust hljs">trait IntoSystem&lt;Params&gt; {
    type Output: System;

    fn into_system(self) -&gt; Self::Output;
}
</pre>
<p>我们使用一个<a href="https://doc.rust-lang.org/1.62.1/book/ch19-03-advanced-traits.html">关联类型</a>来定义这个转换将输出什么类型的<code>System</code>类型。</p>
<p>这种转换特性仍然输出一个具体的系统，但那是什么呢？魔力来了。我们添加一个将实现<code>System</code>的<code>FunctionSystem</code>结构，并且我们将添加一个创建它的<code>IntoSystem</code>实现:</p>
<pre class="language-rust hljs">/// A wrapper around functions that are systems
struct FunctionSystem&lt;F, Params: SystemParam&gt; {
    /// The system function
    system: F,
    // TODO: Do stuff with params
    params: core::marker::PhantomData&lt;Params&gt;,
}

/// Convert any function with only system params into a system
impl&lt;F, Params: SystemParam + 'static&gt; IntoSystem&lt;Params&gt; for F
where
    F: SystemParamFunction&lt;Params&gt; + 'static,
{
    type System = FunctionSystem&lt;F, Params&gt;;

    fn into_system(self) -&gt; Self::System {
        FunctionSystem {
            system: self,
            params: PhantomData,
        }
    }
}

/// Function with only system params
trait SystemParamFunction&lt;Params: SystemParam&gt;: 'static {
    fn run(&amp;mut self);
}
</pre>
<p><code>SystemParamFunction</code>是上一章我们称之为<code>System</code>的一般特质。如你所见，我们还没有对函数参数做任何事情。我们只是保留它们，这样一切都是通用的，然后将它们存储在<a href="https://doc.rust-lang.org/1.62.1/core/marker/struct.PhantomData.html"> <code>PhantomData</code> </a>类型中。</p>
<p>为了满足来自<code>IntoSystem</code>的约束，即它的输出必须是一个<code>System</code>，我们现在在我们的新类型上实现trait:</p>
<pre class="language-rust hljs">/// Make our function wrapper be a System
impl&lt;F, Params: SystemParam&gt; System for FunctionSystem&lt;F, Params&gt;
where
    F: SystemParamFunction&lt;Params&gt; + 'static,
{
    fn run(&amp;mut self) {
        SystemParamFunction::run(&amp;mut self.system);
    }
}
</pre>
<p>这样，我们就差不多准备好了！让我们更新我们的<code>add_system</code>函数，然后我们可以看到这一切是如何工作的:</p>
<pre class="language-rust hljs">impl App {
    fn add_system&lt;F: IntoSystem&lt;Params&gt;, Params: SystemParam&gt;(mut self, function: F) -&gt; Self {
        self.systems.push(Box::new(function.into_system()));
        self
    }
}
</pre>
<p>我们的函数现在接受所有实现类型参数为<code>SystemParam</code>的<code>IntoSystem</code>的东西。</p>
<p>为了接受具有多个参数的系统，我们可以在本身就是系统参数的元组上实现<code>SystemParam</code>:</p>
<pre class="language-rust hljs">impl SystemParam for () {} // sure, a tuple with no elements counts
impl&lt;T1: SystemParam&gt; SystemParam for (T1,) {} // remember the comma!
impl&lt;T1: SystemParam, T2: SystemParam&gt; SystemParam for (T1, T2) {} // A real two-ple
</pre>
<p>但是，我们现在储存什么呢？实际上，我们将做与之前相同的事情:</p>
<pre class="language-rust hljs">struct App {
    systems: Vec&lt;Box&lt;dyn System&gt;&gt;,
}
</pre>
<p>让我们探索一下为什么我们的代码能够工作。</p>
<h2 id="boxing-up-generics">包装我们的泛型</h2>
<p>诀窍是我们现在将一个泛型<code>FunctionSystem</code>存储为一个<a href="https://doc.rust-lang.org/1.62.1/book/ch17-02-trait-objects.html">特征对象</a>，这意味着我们的<code>Box&lt;dyn System&gt;</code>是一个胖指针。它既指向内存中的<code>FunctionSystem</code>,也指向与该类型实例的<code>System</code>特征相关的所有内容的查找表。</p>
<p>当使用通用函数和数据类型时，编译器将<a href="https://rustc-dev-guide.rust-lang.org/backend/monomorph.html">单态化</a>它们来为实际使用的类型生成代码。因此，如果您将同一个泛型函数与三个不同的具体类型一起使用，它将被编译三次。</p>
<p>现在，我们已经满足了所有三个标准。我们已经为泛型函数实现了我们的trait，我们存储了一个泛型<code>System</code>盒子，我们仍然在它上面调用<code>run</code>。</p>
<h2 id="fetching-parameters">获取参数</h2>
<p>遗憾的是，我们的代码还不能工作。我们无法获取参数并使用它们调用系统函数。不过没关系。在<code>run</code>的实现中，我们可以只打印一行而不调用函数。这样，我们可以证明它编译并运行了一些东西。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>结果看起来有点像下面的代码:</p>
<pre class="language-rust hljs">fn main() {
    App::new()
        .add_system(example_system)
        .add_system(another_example_system)
        .add_system(complex_example_system)
        .run();
}

fn example_system() {
    println!("foo");
}

fn another_example_system(_q: Query&lt;&amp;Position&gt;) {
    println!("bar");
}

fn complex_example_system(_q: Query&lt;&amp;Position&gt;, _r: ()) {
    println!("baz");
}


   Compiling playground v0.0.1 (/playground)
    Finished dev [unoptimized + debuginfo] target(s) in 0.64s
     Running `target/debug/playground`
foo
TODO: fetching params
TODO: fetching params
</pre>
<p>你可以在这里找到本教程的完整代码。按下<strong>播放</strong>，你会看到上面的输出和更多。请随意使用它，尝试一些系统的组合，也许还可以添加一些其他的东西！</p>

<p>我们现在已经看到Bevy是如何作为系统接受相当广泛的功能的。但是正如介绍中提到的，其他库和框架也使用这种模式。</p>
<p>Axum web框架就是一个例子，它允许您为特定的路由定义处理函数。下面的代码显示了来自<a href="https://docs.rs/axum/0.5.13/axum/extract/index.html">他们的文档</a>的一个例子:</p>
<pre class="language-rust hljs">async fn create_user(Json(payload): Json&lt;CreateUser&gt;) { todo!() }

let app = Router::new().route("/users", post(create_user));
</pre>
<p>有一个接受函数的<code>post</code>函数，甚至是<code>async</code>函数，其中所有参数都是提取器，就像这里的<code>Json</code>类型。正如你所看到的，这比我们目前看到的Bevy所做的要复杂一些。Axum必须考虑返回类型和如何转换，以及支持异步函数，即返回期货的函数。</p>
<p>但是，总的原则是一样的。<a href="https://docs.rs/axum/0.5.13/axum/handler/trait.Handler.html"> <code>Handler</code>特征</a>是为函数实现的:</p>

<p>特征被包装在路由器上的<code>HashMap</code>中存储的<a href="https://docs.rs/axum/0.5.13/axum/routing/struct.MethodRouter.html"> <code>MethodRouter</code> </a>结构中。调用时，<a href="https://github.com/tokio-rs/axum/blob/329bd5f9b4e3747d6601773895a99899169e2ba5/axum/src/handler/mod.rs#L238-L252"> <code>FromRequest</code>用于</a>提取参数值，这样就可以用它们调用底层函数。这也是一个关于Bevy如何工作的剧透！关于Axum提取器如何工作的更多信息，我推荐David Pedersen的演讲。</p>
<h2 id="conclusion">结论</h2>
<p>在这篇文章中，我们看了看Bevy，一个用Rust编写的游戏引擎。我们探索了它的ECS模式，熟悉了它的API，并通过一个例子进行了运行。最后，我们简要地看了一下Axum web框架中的ECS模式，考虑了它与Bevy的不同之处。</p>
<p>如果你想了解更多关于Bevy的知识，我推荐你查看一下<a href="https://docs.rs/bevy/0.8.0/bevy/ecs/system/trait.SystemParamFetch.html#"> <code>SystemParamFetch</code> </a>特征，探索如何从<code>World</code>获取参数。我希望你喜欢这篇文章，如果你遇到任何问题，一定要留下评论。编码快乐！</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

 <p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Understanding React fragments - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解 React 片段- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-react-fragments/#0001-01-01">https://blog.logrocket.com/understanding-react-fragments/#0001-01-01</a></blockquote><div><article class="article-post">
<p><strong> <em>编者按:</em> </strong> <em>这篇文章于 2022 年 1 月 25 日更新，以更新任何过时的信息，并添加了<a href="https://blog.logrocket.com/understanding-react-fragments/#react-fragment-vs-div"> React 片段与</a> <code><a href="https://blog.logrocket.com/understanding-react-fragments/#what-react-fragment">div</a></code>部分以及使用 <code><a href="https://blog.logrocket.com/understanding-react-fragments/#using-key-prop-react-fragments">key</a></code> <a href="https://blog.logrocket.com/understanding-react-fragments/#using-key-prop-react-fragments">道具的</a><a href="https://blog.logrocket.com/understanding-react-fragments/#using-key-prop-react-fragments">与 React 片段</a>部分。</em></p>
<p>React 片段是 React v16.2.0 发布的一个简单而优雅的特性。理解它们的存在将使您能够编写更好的 React 组件，并在创建和设计布局时节省大量时间。</p>
<p>本教程旨在帮助您理解 React 片段以及它们派上用场的各种用例。</p>
<p>以下是我们将要介绍的内容:</p>

<h2 id="what-react-fragment">什么是反应片段？</h2>
<p>片段是一种语法，允许我们向 React 组件添加多个元素，而无需将它们包装在额外的 DOM 节点中。</p>
<p>让我们来看看下面的代码:</p>
<pre class="language-javascript hljs">const App = () =&gt; {
  return (
    &lt;h1&gt;This is heading1 text&lt;/h1&gt;
  );
}

export default App
</pre>
<p>这是一个简单的 React 组件。当我们在一个组件中只返回一个 JSX 时，我们可以避免用另一个包装元素包装 JSX，如上所示。然而，当我们像这样添加多个 JSX 元素时:</p>
<pre class="language-javascript hljs">const App = () =&gt; {
  return (
    &lt;h1&gt;This is heading1 text&lt;/h1&gt;
    &lt;p&gt;This is paragraph text&lt;/p&gt;
  );
}

export default App
</pre>
<p>我们会遇到一个<code>SyntaxError</code>。从而使我们的应用程序崩溃。</p>
<p>在 React 中，当一个组件返回多个元素时，我们必须将它们包装在类似于<code>div</code>的容器元素中，这样代码才能工作:</p>
<pre class="language-javascript hljs">const App = () =&gt; {
  return (
    &lt;div&gt;
      &lt;h1&gt;This is heading1 text&lt;/h1&gt;
      &lt;p&gt;This is paragraph text&lt;/p&gt;
    &lt;/div&gt;
  );
};
export default App;
</pre>
<p>虽然这很好，但是它可能会在我们的组件中引起意想不到的问题。</p>
<h2 id="react-fragment-vs-div">反应片段与<code>div</code></h2>
<p>如果容器的用途是为 JSX 添加样式，那么它就没有问题。然而，他们并不总是需要包装我们的 JSX。在这种情况下，当我们这样做时，它们变成了额外的节点，使 DOM 树变得混乱。</p>
<p>有时当我们使用嵌套组件时，这些包装器会导致代码异常。例如，当使用 CSS Flexbox 和 Grid 时，<code>div</code>会导致布局中断。对于必须遵循特定结构(如<code>ul &gt; li</code>和<code>table&gt;tr&gt;td</code>)的元素，我们也可能会遇到无效的 HTML。</p>
<p>说到这里，我们将看看实践中的一些问题，看看 React 片段是如何解决这些问题的。从 Flexbox 的 CSS 布局开始。</p>
<h3>在 CSS 布局中使用<code>div</code>包装器</h3>
<p>考虑下面的例子，使用<a href="https://blog.logrocket.com/flexbox-vs-css-grid/"> Flexbox </a>创建一个简单的行和列布局:</p>
<pre class="language-css hljs">import "./styles.css";

const Row = ({ children }) =&gt; &lt;div className="row"&gt;{children}&lt;/div&gt;;

const Column = ({ children }) =&gt; &lt;div className="col"&gt;{children}&lt;/div&gt;;

const Box = ({ color }) =&gt; (
  &lt;div className="box" style={{ backgroundColor: color }}&gt;&lt;/div&gt;
);

export default function App() {
  return (
    &lt;Row&gt;
      &lt;Column&gt;
        &lt;Box color="#007bff" /&gt;
      &lt;/Column&gt;
      &lt;Column&gt;
        &lt;Box color="#fc3" /&gt;
      &lt;/Column&gt;
      &lt;Column&gt;
        &lt;Box color="#ff3333" /&gt;
      &lt;/Column&gt;
    &lt;/Row&gt;
  );
}
</pre>
<p>每个<code>Row</code>呈现一个<code>div</code>，将内容排列成一行，一个<code>Column</code>以垂直方式呈现内容。在每个<code>Column</code>中，都有一个<code>Box</code>组件来呈现一个简单的<code>div</code>，它有一个固定宽度的容器和一个作为道具传递给它的背景色:</p>
<pre class="language-css hljs">/* styles.css */
.row {
  display: flex;
}
.col {
  flex: 1;
}
.box {
  min-width: 100px;
  min-height: 100px;
}
</pre>
<p>上面的代码在一行中呈现三列，如下所示:</p>
<p><img data-attachment-id="92034" data-permalink="https://blog.logrocket.com/understanding-react-fragments/code-render-three-color-columns/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns.png" data-orig-size="730,175" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Code render three color columns" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns-300x72.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns.png" decoding="async" class="aligncenter size-full wp-image-92034 jetpack-lazy-image" src="../Images/f278b5afaeaa835942c9a87f975580da.png" alt="The Code Renders Three Columns In Blue, Yellow, And Red From Left To Right" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns-300x72.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="92034" data-permalink="https://blog.logrocket.com/understanding-react-fragments/code-render-three-color-columns/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns.png" data-orig-size="730,175" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Code render three color columns" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns-300x72.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-92034" src="../Images/f278b5afaeaa835942c9a87f975580da.png" alt="The Code Renders Three Columns In Blue, Yellow, And Red From Left To Right" srcset="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns-300x72.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/Code-render-three-color-columns.png"/></noscript>
<p>在 CodeSandbox 上亲自查看<a href="https://codesandbox.io/s/pedantic-dream-ec2w4?file=/src/App.js">。</a></p>
<p>让我们重构上面的代码，将前两列分成不同的组件<code>ChildComponent</code>。设想这是一个您可能想要解耦的可重用组件:</p>
<pre class="language-javascript hljs">export default function App() {
  return (
    &lt;Row&gt;
      &lt;ChildComponent /&gt;
      &lt;Column&gt;
        &lt;Box color="#ff3333" /&gt;
      &lt;/Column&gt;
    &lt;/Row&gt;
  );
}

const ChildComponent = () =&gt; (
  &lt;div&gt;
    &lt;Column&gt;
      &lt;Box color="#007bff" /&gt;
    &lt;/Column&gt;
    &lt;Column&gt;
      &lt;Box color="#fc3" /&gt;
    &lt;/Column&gt;
  &lt;/div&gt;
);
</pre>
<p>预期的结果应该和以前一样，但事实并非如此。将前两列分离到一个单独的组件<code>ChildComponent</code>中，会破坏布局:</p>
<p><img data-attachment-id="92038" data-permalink="https://blog.logrocket.com/understanding-react-fragments/layout-break-child-component-result-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result.png" data-orig-size="730,306" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Layout break child component result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result-300x126.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result.png" decoding="async" class="aligncenter size-full wp-image-92038 jetpack-lazy-image" src="../Images/efab0e13dbd1d015256c5836a085202e.png" alt="With The Added Child Component, The Layout Breaks, Putting A Blue Box In The Left Corner, A Yellow Box Under The Blue, And A Red Rectangle To The Right Of The Blue" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result-300x126.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="92038" data-permalink="https://blog.logrocket.com/understanding-react-fragments/layout-break-child-component-result-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result.png" data-orig-size="730,306" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Layout break child component result" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result-300x126.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-92038" src="../Images/efab0e13dbd1d015256c5836a085202e.png" alt="With The Added Child Component, The Layout Breaks, Putting A Blue Box In The Left Corner, A Yellow Box Under The Blue, And A Red Rectangle To The Right Of The Blue" srcset="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result-300x126.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/Layout-break-child-component-result.png"/></noscript>
<p>在 CodeSandbox 上亲自查看<a href="https://codesandbox.io/s/gracious-noyce-4tjze?file=/src/App.js">。</a></p>
<p><code>ChildCompoent</code>有一个<code>div</code>包装所有的 JSX 元素，将它们组合在一起。然而，额外的<code>div</code>会导致布局中断，因为浏览器认为它是布局的一部分。</p>
<p>你的浏览器不知道你已经添加了<code>div</code>来避免出错，它仅仅被用作你的封装 HTML 的包装器。</p>
<p>随着组件树嵌套得越来越深，调试和跟踪额外节点的来源可能会很困难。同样，如果我们使用<a href="https://blog.logrocket.com/full-bleed-layout-css-grid/"> CSS 网格</a>来设计我们的布局，不必要的<code>div</code>会导致布局中断。</p>
<h3>为什么我们在 React 中使用片段？</h3>
<p>React 片段是在我们的代码中使用不必要的<code>divs</code>的一种更干净的替代方式。这些片段不会在 DOM 中产生任何额外的元素，这意味着片段的子组件将在没有任何包装 DOM 节点的情况下呈现。</p>
<p>React 片段使我们能够对多个兄弟组件进行分组，而不会在呈现的 HTML 中引入任何不必要的标记。</p>
<h4>在 CSS Flexbox 布局中使用片段</h4>
<p>现在，回到我们的代码，我们可以通过将组件的 JSX 包装在 React 片段而不是<code>div</code>中来修复布局问题:</p>
<pre class="language-javascript hljs">import React from 'react';

const ChildComponent = () =&gt; (
  &lt;React.Fragment&gt;
    &lt;Column&gt;
      &lt;Box color="#007bff" /&gt;
    &lt;/Column&gt;
    &lt;Column&gt;
      &lt;Box color="#fc3" /&gt;
    &lt;/Column&gt;
  &lt;/React.Fragment&gt;
);
</pre>
<p>在 CodeSandbox 上亲自查看<a href="https://codesandbox.io/s/ecstatic-pine-rdwl2?file=/src/App.js">。</a></p>
<h4>在 React 中创建和渲染片段</h4>
<p>有许多方法可以创建和渲染片段。您可以通过在导入的 React 对象上使用<code>Fragment</code>属性来创建片段，如上所示。您还可以从 React 导入一个片段作为 React 组件，并以类似的方式使用它:</p>
<pre class="language-javascript hljs">import React, {Fragment} from 'react';

const ChildComponent = () =&gt; (
  &lt;Fragment&gt;
    &lt;Column&gt;
      &lt;Box color="#007bff" /&gt;
    &lt;/Column&gt;
    &lt;Column&gt;
      &lt;Box color="#fc3" /&gt;
    &lt;/Column&gt;
  &lt;/Fragment&gt;
);
</pre>
<p>最后，您可以使用简写语法动态地创建一个 React 片段，使用一个空的 HTML 元素如语法<code>&lt;&gt;&lt;/&gt;</code>来包装组件。这是使用片段最干净、最简单的方法；感觉就像你在使用一个普通的 HTML 元素:</p>
<pre class="language-javascript hljs">const ChildComponent = () =&gt; (
  &lt;&gt;
    &lt;Column&gt;
      &lt;Box color="#007bff" /&gt;
    &lt;/Column&gt;
    &lt;Column&gt;
      &lt;Box color="#fc3" /&gt;
    &lt;/Column&gt;
  &lt;/&gt;
);
</pre>
<p>使用以上三种方法中的任何一种都可以恢复原始布局，因为它消除了 DOM 中无意义的<code>div</code>。</p>
<h3>在一个<code>div</code>包装器中呈现列表</h3>
<p>让我们看看片段的另一个常见用例。假设您想要在页面上呈现一个项目列表。这个列表可以是静态的，从本地 JSON 文件生成，或者从 API 检索。</p>
<p>为了简洁起见，我们将使用一个静态列表:</p>
<pre class="language-javascript hljs">&gt;import React from 'react';

const items = ["Item 1", "Item 2", "Item 3"];

const ItemRenderer = ({ item }) =&gt; (
  &lt;div&gt;
    &lt;p&gt;Rendering item:&lt;/p&gt;
    &lt;p&gt;{item}&lt;/p&gt;
  &lt;/div&gt;
);

const renderItem = () =&gt; items.map((item, index) =&gt;
  &lt;ItemRenderer key={index} item={item} /&gt;
);
</pre>
<p>在这里，您只需遍历 items 数组并将每个项目作为道具传递给<code>ItemRenderer</code>组件，该组件呈现页面上的每个项目。如果您在浏览器上检查上面的代码，您将得到下面的 DOM 结构:</p>
<pre class="language-javascript hljs">&lt;div&gt;
  &lt;p&gt;Rendering item:&lt;/p&gt;
  &lt;p&gt;Item 1&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;p&gt;Rendering item:&lt;/p&gt;
  &lt;p&gt;Item 2&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;p&gt;Rendering item:&lt;/p&gt;
  &lt;p&gt;Item 3&lt;/p&gt;
&lt;/div&gt;
</pre>
<p>每个条目都在一个没有包装意义的父条目<code>div</code>中呈现。由于封闭的<code>div</code>没有附加样式或数据，因此可以安全地用 React 片段替换它。</p>
<h3>使用 React 片段呈现列表</h3>
<p>让我们用 React 片段替换<code>div</code>包装器，如下所示:</p>
<pre class="language-javascript hljs"> import React from 'react';

const items = ["Item 1", "Item 2", "Item 3"];

const ItemRenderer = ({ item }) =&gt; (
  &lt;&gt;
    &lt;p&gt;Rendering item:&lt;/p&gt;
    &lt;p&gt;{item}&lt;/p&gt;
  &lt;/&gt;
);

const renderItem = () =&gt; items.map((item, index) =&gt;
  &lt;ItemRenderer key={index} item={item} /&gt;
);
</pre>
<p>DOM 结构现在看起来干净多了:</p>
<pre class="language-javascript hljs">  &lt;p&gt;Rendering item:&lt;/p&gt;
  &lt;p&gt;Item 1&lt;/p&gt;
  &lt;p&gt;Rendering item:&lt;/p&gt;
  &lt;p&gt;Item 2&lt;/p&gt;
  &lt;p&gt;Rendering item:&lt;/p&gt;
  &lt;p&gt;Item 3&lt;/p&gt;
</pre>
<p>这是一个非常简单的用例，您可能会在 DOM 上呈现一个额外的<code>div</code>。你的列表越大，影响就越大。</p>
<p>随着您的应用程序变得越来越大，架构越来越复杂，您可能会发现自己在应用程序中呈现大量不必要的<code>div</code>来呈现大型列表。这可能会使您的 HTML 膨胀，导致旧设备上的性能问题。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>它可能一点也不重要，但是呈现不必要的 HTML 元素总是不好的做法。如果您的应用程序有一个通用的列表组件，可以考虑使用片段作为包装器，以避免脱离干净的代码和语义。</p>
<h2 id="using-key-prop-react-fragments">对 React 片段使用<code>key</code>道具</h2>
<p>有些场景需要在片段中使用<code>key</code>道具。让我们来看看下面的代码:</p>
<pre class="language-javascript hljs">const items = [
  {name: "Ibas", title: "developer"},
  {name: "John", title: "teacher"},
];

const App = () =&gt; (
  &lt;&gt;
    &lt;h1&gt;List of all items:&lt;/h1&gt;
    {items.map(({name, title}, index) =&gt; (
      &lt;div key={index}&gt;
        &lt;p&gt;{name}&lt;/p&gt;
        &lt;p&gt;{title}&lt;/p&gt;
      &lt;/div&gt;
    ))}
  &lt;/&gt;
);

export default App;
</pre>
<p>这里的重点是使用<code>map()</code>方法的迭代。正如我们所知，每当我们在 React 中映射条目以呈现列表时，React 使用<code>key</code>属性来标识哪些条目被更改、删除或添加。</p>
<p>此外，每当我们映射项目以呈现多个 JSX 时，我们必须将 JSX 包装在容器元素中。</p>
<p>在上面的代码中，我们用<code>div</code>包装了 JSX，并分配了所需的<code>key</code>道具。它工作得很好，但是让我们假设<code>div</code>在 DOM 树中是多余的，我们不想渲染它。你可以猜到，我们必须用一个碎片来替换它。</p>
<p>但是，使用简写符号<code>&lt;&gt;&lt;/&gt;</code>在这里不起作用，因为它不能接受属性。相反，我们可以使用<code>React.Fragment</code>或<code>Fragment</code>语法。请注意，该语法目前只接受<code>key</code>属性。</p>
<p>因此，通过对片段应用<code>key</code>属性，我们的代码现在看起来像这样:</p>
<pre class="language-javascript hljs">import React from "react";

// ...
const App = () =&gt; (
  &lt;&gt;
    &lt;h1&gt;List of all items:&lt;/h1&gt;
    {items.map(({ name, title }, index) =&gt; (
      &lt;React.Fragment key={index}&gt;
        &lt;p&gt;{name}&lt;/p&gt;
        &lt;p&gt;{title}&lt;/p&gt;
      &lt;/React.Fragment&gt;
    ))}
  &lt;/&gt;
);

export default App;
</pre>
<p>在 CodeSandbox 上亲自查看<a href="https://codesandbox.io/s/aged-silence-gy0hy?file=/src/App.js">。不会变得更简单。</a></p>
<h2>结论</h2>
<p>片段允许你写更干净，可读和可维护的代码。它们不是 HTML 中的<code>div</code>的替代品，但是如果您在代码中使用不必要的<code>div</code>，它们提供了一种更好的方法来组织和呈现您的标记。</p>
<p>您可以避免破坏布局的问题，或者使用片段优化标记呈现时间。但是，您应该只在需要的时候使用它们。如果你需要一个包装你的 JSX 的样式，使用<code>div</code>代替。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Level up your state management with Rematch - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>通过复赛提升你的状态管理</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/level-up-state-management-rematch/#0001-01-01">https://blog.logrocket.com/level-up-state-management-rematch/#0001-01-01</a></blockquote><div><article class="article-post">
<p>状态管理决定了数据如何在应用程序中创建、更新和传递，是前端开发的一个重要方面。在不断变化的技术世界中，用于完成状态管理的库<a href="https://blog.logrocket.com/react-hooks-state-management/">并不缺乏，以至于决定使用哪一个变得令人困惑和不知所措。</a></p>
<p>在本文中，我将向您介绍<a href="https://rematchjs.org"> Rematch </a>，这是一个我已经使用了一段时间的状态管理库。如果你已经喜欢使用 Redux，那么你一定会爱上 Rematch。建立在 Redux 之上，Rematch 是 Redux 的一切，没有许多令人困惑的配置和样板。</p>
<p>这篇文章是为那些希望探索新的状态管理库和已经在使用 Redux 的前端开发人员准备的。我们将探索 Rematch 是如何工作的，详细说明它的特性，然后构建一个简单的待办事项应用程序来演示如何使用 Rematch。我们开始吧！</p>
<h3>目录</h3>

<h2 id="what-is-rematch">什么是复赛？</h2>
<p>复赛是建立在 Redux 上的状态管理库。根据官方文件，<a href="https://rematchjs.org/docs/">复赛是没有样板文件</a>的重复最佳实践。</p>
<p>Redux 是一个非常棒的状态管理工具，具有优秀的开发工具，但是要在项目中使用它是相当麻烦的。你必须添加很多配置，甚至安装一些其他的助手库，比如<a href="https://github.com/reduxjs/redux-thunk"> Redux Thunk </a>来让它工作。</p>
<p>Rematch 使用相同的 Redux 概念，但提供了一种更简单的方式来设置中央存储和管理应用程序中的状态，这意味着不需要使用 Redux Thunk 进行配置，也不需要其他 Redux 样板，如 switch 语句和操作创建器。相反，Rematch 提供了这些现成的东西，这对前端开发人员来说绝对是个好消息。Rematch 还有一个持久化器来持久化存储数据。</p>
<p>在我们学习如何使用 Rematch 之前，让我们来看看它的一些很酷的特性。</p>
<h2 id="notable-rematch-features">显著的复赛特征</h2>
<p>Rematch 构建于 Redux 之上，允许轻松迁移、代码互操作性、使用 Redux 开发工具等等。然而，与普通的 Redux 不同，Rematch 只需要一个文件就可以处理 Thunks、switch 语句、动作类型和动作创建者。因此，您不需要添加任何复杂的配置，减少了样板文件的整体大小。</p>
<p>复赛包括内置的副作用，支持本地 JavaScript async/await 调用外部 API。Rematch 公开了一个 API 接口，用于创建扩展其功能的自定义插件。</p>
<p>用 TypeScript 编写，Rematch 很容易支持 TypeScript，并为所有方法、状态和 reducers 提供了自动完成功能。最后，重匹配是框架不可知的。它与 React 配合使用效果很好，但也与 Vue、Angular 等配合使用。</p>
<h2 id="getting-started-rematch">重新比赛入门</h2>
<p>为了理解 Rematch 的工作原理，让我们构建一个使用 Rematch 来管理状态的待办事项应用程序。首先，让我们安装一个新的 React 应用程序模板:</p>
<pre class="&quot;language-bash">npx create-react-app my-todo
</pre>
<p>app 模板安装完成后，<code>cd</code>进入<code>my-todo</code>。让我们继续安装重赛:</p>
<pre class="&quot;language-bash">npm install @rematch/core
</pre>
<p>我们还将使用 React Redux 的一些功能，所以让我们安装:</p>
<pre class="&quot;language-bash">npm install react-redux
</pre>
<p>最后，用<code>npm start</code>启动开发服务器。</p>
<h3 id="models">模型</h3>
<p>要使用重匹配，我们首先必须定义模型。模型将状态、reducers 和异步操作集中在一个地方，显示 Redux 存储的快照以及它是如何变化的。模型是在状态管理中起核心作用的对象。</p>
<p>这些问题有助于您理解模型中需要包含哪些内容:</p>
<ul>
<li>我的初始状态是什么？<code>state</code></li>
<li>我如何改变状态？<code>reducers</code></li>
<li>我如何处理异步动作？<code>effects with async/await</code></li>
</ul>
<p>让我们为我们的待办事项应用程序创建模型:</p>
<pre class="&quot;language-react">export const myTodos = {
    state: {
        1: { todo: 'Learn React' },
    },

    reducers: {
        addTodo(state, todo) {
            return {
                ...state,
                [Date.now()]: { todo }
            }
        },
        removeTodo(state, id) {
            delete state[id]
            return {
                ...state
            }
        }
    },

    effects: {
        async asyncRemoveTodo(id) {
            await new Promise(resolve =&gt; setTimeout(() =&gt; resolve(), 1000))
            this.removeTodo(id)
        }
    }
}
</pre>
<p>我们创建了一个包含初始状态的<code>state</code>对象，这是一个<code>todo</code>任务。我们还在<code>reducer</code>中创建了更新状态的方法。最后，我们设置了一个承诺，模拟一秒钟后解析的<code>effects</code>内的 API 调用。<code>effects</code>用于运行 API 调用之类的副作用。接下来，我们需要初始化存储。</p>
<h3 id="initialize-redux-store">用<code>init()</code>初始化 Redux 存储</h3>
<p>通过调用<code>init()</code>方法，您构建了一个完全配置的 Redux 存储。它接受一个具有模型和插件等属性的<code>config</code>对象，返回一个具有附加重匹配功能的完全配置的 Redux 存储。</p>
<p>创建的存储具有 Redux 存储的所有功能，包括<code>dispatch()</code>和<code>subscribe()</code>方法。此外，Rematch 还提供定制特性，比如用于延迟加载新模型的<code>addModel()</code>方法。</p>
<p>让我们初始化<code>index.js</code>文件中的存储:</p>
<pre class="&quot;language-javascript">import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

import { Provider } from "react-redux";

import { init } from "@rematch/core";
import * as models from "./model";

const store = init({ models });

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;Provider store={store}&gt;
      &lt;App /&gt;
    &lt;/Provider&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);
</pre>
<p>注意，我们使用了 React Redux 中的<code>Provider</code>组件，这是 React 的官方 Redux UI 绑定库。<code>Provider</code>组件使得需要访问它的嵌套组件可以使用这个存储。我们还导入了模型，并用它初始化了商店。</p>
<p>现在，我们将创建两个新组件，一个用于显示待办事项，另一个用于创建待办事项。在<code>src</code>中创建一个名为<code>components</code>的文件夹，并在其中创建两个文件，<code>Todo.js</code>和<code>AddTodo.js</code>。</p>
<p>在<code>Todo.js</code>文件中，我们将访问状态以获取和显示待办事项:</p>
<pre class="&quot;language-react">// Todo.js
import React from 'react';
import { useSelector } from 'react-redux'

function Todo() {

    const todosArray = useSelector((state) =&gt; {
        let todosIds = Object.keys(state.myTodos)
        return todosIds.map(id =&gt; ({
            ...state.myTodos[id],
            id,
        }))
    })

return (
        &lt;ul&gt;
            {
                todosArray?.map(val =&gt; {
                    return (
                        &lt;div key={val.id}&gt;
                            &lt;li&gt;{val.todo}&lt;/li&gt;
                        &lt;/div&gt;
                    )
                })
            }
        &lt;/ul&gt;
    )
}

export default Todo;
</pre>
<p>在上面的代码中，我们从 React Redux 导入了<code>useSelector</code>钩子，以便从我们的组件访问商店。我们获取状态，这是一个对象，并将其转换为一个数组，这样我们就可以轻松地遍历并显示它。</p>
<p>让我们继续在<code>AddTodo.js</code>组件中创建一个添加待办事项的表单:</p>
<pre class="&quot;language-react">// AddTodo.js

import React, { useState } from 'react'

function AddTodo() {
    const [myTodo, setMyTodo] = useState('')

    const handleChange = (event) =&gt; {
        setMyTodo(event.target.value)
    }


    return (
        &lt;div&gt;
            &lt;form&gt;
                &lt;input type='text' placeholder='Enter todo' value={myTodo} onChange={handleChange} /&gt;
                &lt;button type="submit"&gt;Add Todo&lt;/button&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    )
}


export default AddTodo;
</pre>
<h3 id="dispatch-action">派遣行动</h3>
<p>您可以使用 dispatch 在模型中触发 reducers 和 effects，就像 plain Redux 一样。您可以直接调用 dispatch 或者使用<code>dispatch\[model][action\](payload)</code>简写，这允许您标准化您的操作，而无需编写操作类型或操作创建者。</p>
<p>让我们导入<code>useDispatch</code>钩子，并在用户提交表单时分派一个动作来创建一个<code>todo</code>:</p>
<pre class="&quot;language-react">// AddTodo.js

import { useDispatch } from 'react-redux'

    const dispatch = useDispatch()

    const handleSubmit = event =&gt; {
        event.preventDefault();
        dispatch.myTodos.addTodo(myTodo)
        setMyTodo('')
    }

// call the `handleSubmit` on form submit

 &lt;form onSubmit={handleSubmit}&gt;
          &lt;input type='text' placeholder='Enter todo' value={myTodo} onChange={handleChange} /&gt;
           &lt;button type="submit"&gt;Add Todo&lt;/button&gt;
   &lt;/form&gt;
</pre>
<p><code>AddTodo.js</code>的完整代码如下所示:</p>
<pre class="&quot;language-react">// AddTodo.js

import React, { useState } from 'react'
import { useDispatch } from 'react-redux'


function AddTodo() {
    const [myTodo, setMyTodo] = useState('')

    const dispatch = useDispatch()

    const handleChange = (event) =&gt; {
        setMyTodo(event.target.value)
    }
    const handleSubmit = event =&gt; {
        event.preventDefault();
        dispatch.myTodos.addTodo(myTodo)
        setMyTodo('')
    }

    return (
        &lt;div&gt;
            &lt;form onSubmit={handleSubmit}&gt;
                &lt;input type='text' placeholder='Enter todo' value={myTodo} onChange={handleChange} /&gt;
                &lt;button type="submit"&gt;Add Todo&lt;/button&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    )
}


export default AddTodo;
</pre>
<p>真的就这么简单。让我们回到<code>Todo.js</code>来实现<code>delete</code>和<code>async</code>删除功能。像往常一样，我们将导入<code>useDispatch</code>钩子来调度<code>delete</code>动作。</p>
<p>下面是<code>Todo.js</code>的完整代码:</p>
<pre class="&quot;language-react">// Todo.js

import React from 'react';
import { useSelector, useDispatch } from 'react-redux'

function Todo() {

    const todosArray = useSelector((state) =&gt; {
        let todosIds = Object.keys(state.myTodos)
        return todosIds.map(id =&gt; ({
            ...state.myTodos[id],
            id,
        }))
    })

    const dispatch = useDispatch()

    const handleDelete = (id) =&gt; {
        dispatch.myTodos.removeTodo(id)
    }

    const handleAsyncDelete = (id) =&gt; {
        dispatch.myTodos.asyncRemoveTodo(id)
    }

    return (
        &lt;ul&gt;
            {
                todosArray?.map(val =&gt; {
                    return (
                        &lt;div key={val.id}&gt;
                            &lt;li&gt;{val.todo}&lt;/li&gt;
                            &lt;button onClick={() =&gt; handleDelete(val.id)}&gt;Delete&lt;/button&gt;
                            &lt;button onClick={() =&gt; handleAsyncDelete(val.id)}&gt;Async Delete&lt;/button&gt;
                        &lt;/div&gt;
                    )
                })
            }
        &lt;/ul&gt;
    )
}

export default Todo;
</pre>
<p>我们可以将这两个组件导入到<code>App.js</code>中，并保存它们以便在浏览器中查看。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<h2 id="conclusion">结论</h2>
<p>由于 Redux 的复杂性和繁琐性，许多前端开发人员都避免学习它。然而，Rematch 很好地抽象出了大部分工作，使得建立 Redux 商店变得容易和快速。</p>
<p>由于 Rematch 的极简和平易近人的 API，您可以开发美丽和健壮的应用程序，并利用 Redux 的既定功能。我希望你喜欢这篇文章！如果你有任何问题，一定要留下评论。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
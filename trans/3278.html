<html>
<head>
<title>Using GStreamer in Node.js - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Node.js - LogRocket博客中使用GStreamer</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-gstreamer-node-js/#0001-01-01">https://blog.logrocket.com/using-gstreamer-node-js/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>GStreamer是一个创建流媒体应用程序的框架。使用GStreamer框架，可以设计和构建能够处理任何类型的流数据流的低延迟应用程序，包括音频和视频功能。</p>
<p>GStreamer core为插件、数据流和媒体类型处理提供了一个框架。它还提供了一个API来使用各种插件编写应用程序。</p>
<p>基于插件的框架提供了各种编解码器和其他功能，这些功能可以在管道中链接和安排，从而定义了数据流。但是，在撰写本文时，GStreamer应用程序还没有正式的Node.js端口/绑定。</p>
<p>在本帖中，我们将通过以下几节讨论GStreamer的功能以及如何用Node设置它:</p>

<h2 id="features-use-cases">功能和使用案例</h2>
<p>GStreamer的一个主要用例是构建媒体播放器。作为开发人员，您可以使用大量强大的工具来创建媒体管道，而无需编写一行代码。</p>
<p>默认情况下，GStreamer包含用于构建支持多种格式的媒体播放器的组件，包括MP3、Ogg/Vorbis、MPEG-1/2、AVI、QuickTime、mod等等。</p>
<p>然而，GStreamer提供了比其他媒体播放器更多的功能。它的主要优点是可插入组件可以混合到任意管道中，因此可以编写视频或音频编辑应用程序。具体来说，GStreamer提供了:</p>
<ul>
<li>用于多媒体应用的API</li>
<li>插件架构</li>
<li>流水线结构</li>
<li>用于媒体类型处理/协商的机制</li>
</ul>
<h2 id="gstreamer-plugin-architecture">GStreamer插件架构</h2>
<p>通过插件，GStreamer可以连接到其他多媒体框架，以重用现有的组件(如编解码器)和其他平台输入/输出机制。</p>
<p>GStreamer的核心本质上是与媒体无关的。它只知道字节和块，只包含基本元素。所有的媒体处理功能都由内核外部的插件提供。这些告诉核心如何处理特定类型的媒体。</p>
<p>GStreamer插件可以分为以下几组:</p>
<ul>
<li>协议处理</li>
<li>来源:用于音频和视频(涉及协议插件)</li>
<li>格式:解析器、格式化器、复用器、解复用器、元数据、字幕</li>
<li>编解码器:编码器和解码器</li>
<li>滤镜:转换器、混音器、效果</li>
<li>接收器:用于音频和视频(涉及协议插件)</li>
</ul>
<h2 id="gstreamer-installation">GStreamer安装</h2>
<p>要安装GStreamer，文档提供了各种方法，供您根据操作系统的选择进行选择。</p>
<p>对于macOS X，我们需要安装OS X雪豹(10.6)或更高版本以及XCode 3.2.6或更高版本。不过推荐的系统版本是macOS Sierra带XCode 8。我们可以从GStreamer下载页面安装运行时和开发安装程序，我们可以在这里找到<a href="https://gstreamer.freedesktop.org/download/#macos" target="_blank" rel="noopener"/>。</p>
<p>对于其他操作系统/环境，包括Windows、iOS、Android和Linux，我们可以查看文档中的<a href="https://gstreamer.freedesktop.org/documentation/installing/index.html?gi-language=javascript#" target="_blank" rel="noopener">下载页面</a>，其中包含所有受支持的生态系统和构建GStreamer SDKs的方式的列表。</p>
<p>我们可以导航到系统路径上的<code>/Library/Frameworks/GStreamer.framework/Commands</code>,看看可用的命令来使用GStreamer。一些流行的命令包括<code>gst-launch-1.0</code>、<code>gst-inspect-1.0</code>、<code>gst-play-1.0</code>。</p>
<h2 id="setting-gstreamer-nodejs">使用Node.js设置GStreamer</h2>
<p>安装完成后，我们可以继续使用Node.js运行时来使用GStreamer管道，并将结果输出到web浏览器。</p>
<p>让我们创建一个我们选择的文件夹，并使用npm或Yarn安装Express.js，然后按照说明用一个<code>package.json</code>文件设置一个基本项目:</p>
<pre class="language-bash hljs">npm install express or yarn add express
</pre>
<p>然后继续创建一个<code>index.js</code>文件来保存我们使用GStreamer的流示例的JavaScript代码。参见下面的<code>index.js</code>文件:</p>
<pre class="language-javascript hljs">const express = require('express')
const http = require('http')
const net = require('net');
const child = require('child_process');

const app = express();
app.use(express.static(__dirname + '/'));

const httpServer = http.createServer(app);
const port = 3000;  

//send the html page which holds the video tag
app.get('/', function (req, res) {
    res.send('index.html');
});

//stop the connection
app.post('/stop', function (req, res) {
    console.log('Connection closed using /stop endpoint.');
    if (gstMuxer != undefined) {
        gstMuxer.kill();    //kill the GStreamer Pipeline
    }
    gstMuxer = undefined;
    res.end();
});

//send the video stream
app.get('/stream', function (req, res) {
    res.writeHead(200, {
        'Content-Type': 'video/webm',
    });

    const tcpServer = net.createServer(function (socket) {
        socket.on('data', function (data) {
            res.write(data);
        });
        socket.on('close', function () {
            console.log('Socket closed.');
            res.end();
        });
    });

    tcpServer.maxConnections = 1;

    tcpServer.listen(function () {
        console.log("Connection started.");
        if (gstMuxer == undefined) {
            console.log("inside gstMuxer == undefined");
            const cmd = 'gst-launch-1.0';
            const args = getGstPipelineArguments(this);
            const gstMuxer = child.spawn(cmd, args);
            gstMuxer.stderr.on('data', onSpawnError);
            gstMuxer.on('exit', onSpawnExit);
        }
        else {
            console.log("New GST pipeline rejected because gstMuxer != undefined.");
        }
    });
});

httpServer.listen(port);
console.log(`Camera Streaming App listening at http://localhost:${port}`)

process.on('uncaughtException', function (err) {
    console.log(err);
});

//functions
function onSpawnError(data) {
    console.log(data.toString());
}

function onSpawnExit(code) {
    if (code != null) {
        console.log('GStreamer error, exit code ' + code);
    }
}

function getGstPipelineArguments(tcpServer) {
    const args =
        ['/Users/alexandernnakwue/Downloads/samplevideo.mp4', 'pattern=ball',
            '!', 'video/x-raw,width=320,height=240,framerate=100/1',
            '!', 'vpuenc_h264', 'bitrate=2000',
            '!', 'mp4mux', 'fragment-duration=10',
            '!', 'tcpclientsink', 'host=localhost',
            'port=' + tcpServer.address().port];
    return args;
}
</pre>
<p>正如我们在上面的文件中看到的，我们有三个端点:</p>
<ol>
<li>发送包含视频标签的HTML页面的端点</li>
<li>发送视频流的端点</li>
<li>结束连接的终结点</li>
</ol>
<p>接下来，创建HTML页面(<code>index.html</code>)，它包含视频标签，如下所示。</p>
<pre class="language-html hljs">&lt;!DOCTYPE html&gt;
&lt;head&gt;
    &lt;title&gt;GStreamer with NodeJS Demo&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=0.9"&gt;
    &lt;style&gt;
        html,
        body {
            overflow: hidden;
        }
    &lt;/style&gt; 
    &lt;script&gt;
        function buffer() {
            //Start playback as soon as possible to minimize latency at startup 
            const dStream = document.getElementById('vidStream');
            try {
                dStream.play();
            } catch (error) {
                console.log(error);
            }

        }
    &lt;/script&gt;
&lt;/head&gt;

&lt;body onload="buffer();"&gt;
    &lt;video id="vidStream" width="640" height="480" muted&gt;
        &lt;source src="/stream" type="video/mp4" /&gt;
        &lt;source src="/stream" type="video/webm" /&gt;
        &lt;source src="/stream" type="video/ogg" /&gt;
        &lt;!-- fallback --&gt;
        Your browser does not support the <code>video</code> element. &lt;/video&gt; &lt;/body&gt;</pre>
<p>正如我在简介中提到的，Node.js目前没有官方的端口或绑定，上面的代码改编自这篇<a href="https://stackoverflow.com/questions/63946535/how-to-use-gstreamers-webrtcbin-with-a-web-browser" target="_blank" rel="noopener">栈溢出帖子</a>。</p>
<p>我们可以继续使用<code>gst-launch-1.0</code>命令来启动流媒体应用程序和参数，包括流媒体的视频或音频源、TCP端口和地址、设置等等。当页面加载时，我们用<code>play()</code>方法尽快播放视频流。</p>
<p>注意:这只适用于基于Chromium的浏览器。我将在下面详细解释</p>
<h2 id="some-gstreamer-limitations">Gstreamer的一些限制</h2>
<p>今天，GStreamer for Node.js的当前实现是非标准化的，仍然缺乏。例如，当前的实现并不完全兼容浏览器，只能在基于Chrome的浏览器中工作，因为Chrome中加载资源所需的一些HTTP头不可用。此外，在某些系统架构上构建GStreamer仍然是一项困难的任务，因为它仍然包含许多bug。</p>
<p>GStreamer还不直接支持多种不同编程语言的端口。这意味着打算在Node.js应用程序中使用GStreamer的开发人员需要使用<code>node-addon-api</code>直接从Node调用<code>C</code>代码。然而，这种方法需要大量的工作，并且在使用<a href="https://github.com/nodejs/node-gyp" target="_blank" rel="noopener"> node-gyp </a>构建时尤其容易出错。</p>
<h2 id="conclusion">结论</h2>
<p>正如我们可能已经注意到的，目前对于Node.js的GStreamer绑定是有限的。</p>
<p>还有其他可用的绑定，如<a href="https://github.com/dturing/node-gstreamer-superficial" target="_blank" rel="noopener">node-gstreamer-surfacial</a>，但根据文档，它并不试图成为GStreamer的完整JS绑定，并且有望在某一天被<code>node-gir</code>所取代(或实现)。</p>
<p>其他可用的绑定或黑客只是不能像预期的那样工作，不是标准化的，就是容易出错。这确实是一个巨大的挑战，在不久的将来，需要构建Node.js绑定的标准化和行业范围的端口。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
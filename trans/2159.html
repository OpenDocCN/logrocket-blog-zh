<html>
<head>
<title>Next.js automatic image optimization with next/image - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Next.js 使用 next/image - LogRocket 博客进行自动图像优化</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/next-js-automatic-image-optimization-next-image/#0001-01-01">https://blog.logrocket.com/next-js-automatic-image-optimization-next-image/#0001-01-01</a></blockquote><div><article class="article-post">
<p>一张图胜过千言万语，图像是网络与用户沟通的重要组成部分。以最基本的形式定义它们很简单，只需要简单的<code>&lt;img&gt;</code>元素:</p>
<pre>&lt;img src="image.jpg"&gt;</pre>
<p>通常，源图像<code>image.jpg</code>被嵌入到一个网页中，假设该图像与 HTML 页面在同一个目录中。</p>
<p>如果浏览器或屏幕阅读器不能加载图像，您可以——也应该——通过添加描述图像的替代文本(<code>alt</code>)来进一步完善这种图像定义的规范形式:</p>
<pre>&lt;img src="image.jpg alt="describe the image here"/&gt;
</pre>
<p>但是对于网络上的图片，魔鬼就在细节中。随着 web 的发展，图像优化的需求也在增长，无论是为了用户体验还是开发者体验。</p>
<p>为了确保为用户提供最佳可用图像，必须解决图像大小、web 格式和响应能力等方面的问题。</p>
<p>通过<code>img</code>元素的大量优化 API 可以解决用户的需求。然而，它们很快会变得难以打开。这就是自动图像优化可以让开发人员受益的地方。</p>
<h2>Next.js 中的自动图像优化案例</h2>
<p>像 Next.js 这样的框架提供了一种抽象，可以解决最常见、最普通、最复杂的任务，比如路由、内部化和图像优化。</p>
<p>根据 Next.js 团队的说法，Next.js 的<a href="https://nextjs.org/blog/next-10#built-in-image-component-and-automatic-image-optimization">目标是改善两件事:开发者和用户体验</a>。虽然大多数优化都集中在减少发送给用户的 JavaScript 数量上，但是还有其他方面也需要优化，比如图像。输入 Next.js 10。</p>
<p>Next.js 10 欢迎一个内置的图像优化 API，<code>next/image</code>，作为原生自动图像优化的规范形式，提供了五个好处。</p>
<h3>改善用户体验</h3>
<p>通过默认情况下延迟加载的优化图像，用户可以期待网站加载时间的性能提升，最终改善整体用户体验。</p>
<h3>良好的开发者体验</h3>
<p>有了<code>next/image</code>简单易用的 API，开发人员可以更好地定义基本图像，根据自己的喜好进行调整，或者深入研究缓存和加载器等高级配置选项。</p>
<h3>不受影响的构建时间</h3>
<p>构建时间的增加并不是优化的副作用，因为 Next.js 会在用户请求时按需优化图像，而不是在构建时。</p>
<h3>现代图像技术和格式</h3>
<p>默认情况下，图像是延迟加载的，可以在受支持的浏览器中以 WebP 等现代格式提供。</p>
<h3>未来证明</h3>
<p>Next.js 还可以自动采用未来的图像格式，并将其提供给支持这些格式的浏览器。</p>
<h2>使用<code>next/image</code> API</h2>
<p>在 Next.js 中，<code>next/image</code> API 是图像优化的最佳点。它将<code>&lt;Image/&gt;</code>组件公开为传统的单一事实来源。这意味着您只需要学习如何使用一个 API 来处理 Next.js 中的图像优化。</p>
<p>从设计上来说，在其最基本的形式中，<code>&lt;image/&gt;</code>组件基本上类似于 HTML <code>img</code>元素，因为它们都接受<code>src</code>和<code>alt</code>属性/特性:</p>
<pre>// 1. Import the `Image` component from the `next/image` API
import Image from 'next/image';

export default function CardImage({imageSrc, imageAltText}) {
    return (
        &lt;div classname="cardImageWrapper"&gt;
            {/* 2. Use the `Image` component as you would any other component  */}
            &lt;Image src={imageSrc} alt={imageAltText}/&gt;
        &lt;/div&gt;
    )
}
</pre>
<p>组件<code>&lt;Image/&gt;</code>的功能可以通过许多可用的道具来扩展。让我们来看看它们。</p>
<h3><code>src</code>道具</h3>
<p><code>src</code>是<code>&lt;Image/&gt;</code>组件的唯一真实来源:</p>
<pre>&lt;Image src="image.webp"/&gt;
</pre>
<p>要使用图像<code>src</code>，它必须是以下之一:</p>
<ol>
<li>作为内部路径的路径字符串，就像上面的代码片段一样，<a href="https://nextjs.org/docs/api-reference/next/image#loader">取决于加载器</a></li>
<li>作为绝对外部 URL 的路径字符串，在<code>next.config.js</code>中设置了域选项</li>
<li>静态导入的图像文件</li>
</ol>
<p>在这种情况下，我们将导入一个静态图像文件:</p>
<pre>import Image from 'next/image';
// Import a static image file
import defaultCardImage from '../public/defaultCardImage.webp';

export default function CardImage({imageSrc = defaultCardImage, imageAltText}) {
    return (
        &lt;div classname="cardImageWrapper"&gt;
            &lt;Image src={imageSrc} alt={imageAltText}/&gt;
        &lt;/div&gt;
    )
}
</pre>
<h3><code>width</code>和<code>height</code>道具</h3>
<p>图像的绝对宽度以像素为单位。除静态导入的图像或布局属性设置为<code>fill</code>的图像外，这是必需的:</p>
<pre>&lt;Image
    src="image-src"
    alt="image-alt-text"
    width={40}
    height={40}
/&gt;
</pre>
<h3><code>loader</code>道具</h3>
<p><code>loader</code>是一个自定义函数，用于解析 URL。给定<code>src</code>、<code>width</code>和<code>quality</code>参数，它返回一个 URL 字符串:</p>
<pre>import Image from 'next/image'

// You can add as many loader as you want, and use them conditionally.
// See https://nextjs.org/docs/basic-features/image-optimization#loader
const sanityIoImageLoader = ({ src, width, quality }) =&gt; {
  return `https://cdn.sanity.io/${src}?w=${width}&amp;q=${quality || 75}`
}

function CardImage() {
  return (
    &lt;Image
      loader={sanityIoImageLoader}
      src="image-src"
      alt="image-alt-text"
      width={500}
      height={500}
    /&gt;
  )
}
</pre>
<h3><code>sizes</code>道具</h3>
<p>属性类似于 HTML 元素的属性。这样，大小被设置为指示一组<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-sizes">源大小，如 MDN 文档</a>中所述:</p>
<pre>&lt;img src="image-src" alt="image-alt-text" srcset="(max-height: 500px) 1000px"/&gt;
</pre>
<p>这意味着如果视口小于 500 像素，则使用 1000 像素宽度的源。使用<code>&lt;Image/&gt;</code>组件，您可以如下指定<code>sizes</code>:</p>
<pre>&lt;Image
    src="image-src"
    alt="image-alt-text"
    sizes="320 640 750"
    layout="responsive"
/&gt;
</pre>
<p>请记住，建议仅在使用<code>responsive</code>或<code>fill</code>布局时定义<code>sizes</code>。</p>
<h3><code>quality</code>道具</h3>
<p><code>quality</code>属性提供了一个介于<code>1</code>和<code>100</code>之间的整数，用于定义优化图像的质量；<code>1</code>质量最差，<code>100</code>最好。默认为<code>75</code>:</p>
<pre>&lt;Image
    src="image-src"
    alt="image-alt-text"
    quality={100}
    layout="fill"
/&gt;
</pre>
<h3><code>priority</code>道具</h3>
<p>默认情况下，图像没有优先级(因为它们是延迟加载的)，这意味着<code>priority</code>默认为<code>false</code>。当<code>true</code>时，图像被认为是高优先级的，并且<a href="https://web.dev/preload-responsive-images/">预载</a>。</p>
<p>仅当图像在折叠上方可见时，才应使用此选项:</p>
<pre>&lt;Image
    src="image-src"
    alt="image-alt-text"
    width={500}
    height={300}
    priority
/&gt;
</pre>
<h3><code>layout</code>道具</h3>
<p>当视窗尺寸改变时，<code>layout</code>道具控制图像的布局行为。接受的值是一个字符串，可以是<code>intrinsic</code>、<code>fixed</code>、<code>responsive</code>或<code>fill</code>。</p>
<p>每个布局值在以下方面都有细微差别:</p>
<ol>
<li>生成的<code>srcSet</code>和<code>sizes</code></li>
<li>对于使用它们的相应的<code>&lt;Image/&gt;</code>元素，期望在父元素上有<code>display</code>或<code>position</code>值</li>
<li>有时必须与其他道具配对，以获得适当的行为</li>
</ol>
<p>让我们来看看可能的布局<code>values</code></p>
<h4><code>intrinsic</code>布局</h4>
<p><code>intrinsic</code>布局是四个布局值的默认值。将此布局用于较小的视口会缩小图像尺寸，而用于较大的视口会保持原始图像尺寸。你可以在这里看到<a href="https://image-component.nextjs.gallery/layout-intrinsic"><code>intrinsic</code>布局的一个例子。</a></p>
<h4><code>fixed</code>布局</h4>
<p><code>fixed</code>布局在行为上类似于本地<code>img</code>元素。使用它，无论视口如何变化，图像尺寸都保持固定在原始尺寸，这意味着没有响应。你可以在这里看到<a href="https://image-component.nextjs.gallery/layout-fixed">一个<code>fixed</code> </a>一个<a href="https://image-component.nextjs.gallery/layout-fixed">布局的例子。</a></p>
<h4><code>responsive</code>布局</h4>
<p><code>responsive</code>布局借鉴并覆盖了<code>fixed</code>和<code>intrinsic</code>布局。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>为了覆盖<code>fixed</code>布局，它响应视窗的变化，但是为了覆盖更大视窗的<code>intrinsic</code>布局，其中图像尺寸按比例增加，父元素必须是<code>display: block</code>。你可以在这里看到<a href="https://image-component.nextjs.gallery/layout-responsive">一个</a> <code><a href="https://image-component.nextjs.gallery/layout-responsive">responsive</a></code> <a href="https://image-component.nextjs.gallery/layout-responsive">布局的例子。</a></p>
<h4><code>fill</code>布局</h4>
<p><code>fill</code>布局响应其父尺寸。使用它，图像尺寸被拉伸到父尺寸，假设父尺寸是<code>position: relative</code>。</p>
<p>这通常与<code>objectFit</code>属性成对出现。你可以在这里看到<a href="https://image-component.nextjs.gallery/layout-fill"><code>responsive</code></a><a href="https://image-component.nextjs.gallery/layout-fill">布局的一个例子</a>。</p>
<h3><code>placeholder</code>道具</h3>
<p>这个<code>placeholder</code>属性被用作加载图像时的后备图像。它的可能值是<code>blur</code>或<code>empty</code>。</p>
<p><code>placeholder</code>默认为<code>empty</code>，当它为<code>empty</code>时，图像加载时没有占位符，只有空白。</p>
<p>然而，当它是<code>blur</code>时，<code>blurDataURL</code>属性被用作占位符。如果图像<code>src</code>是带有 MIME 类型<code>jpg</code>、<code>png</code>或<code>webp</code>的静态导入，那么<code>blurDataURL</code>会自动填充。</p>
<p>对于动态图像，必须提供<code>blurDataURL</code>属性。像<a href="https://github.com/joe-bell/plaiceholder">牌架</a>这样的解决方案可以帮助<code>base64</code>代。</p>
<h3><code>objectFit</code>支柱</h3>
<p><code>objectFit</code>属性类似于<a href="https://blog.logrocket.com/cropping-images-css-in-depth/#using-object-fit-object-position">对象适配 CSS 属性</a>，该属性设置图像应该如何调整大小以适合其容器。它与<code>layout=fill</code>一起使用，或者与设置了<code>width</code>和<code>height</code>的图像一起使用，可能值为<code>contain</code>、<code>cover</code>、<code>fill</code>、<code>none</code>和<code>scale-down</code>:</p>
<pre>&lt;Image 
    src="image-src"
    alt="image-alt-text"
    layout="fill"
    objectFit="contain"
/&gt;
</pre>
<h3><code>objectPosition</code>道具</h3>
<p>这类似于指定图像在其容器中的位置的<code>object-position</code> CSS 属性。它与<code>layout=fill</code>一起使用，或者与设置了<code>width</code>、<code>height</code>和<code>position</code>值的图像一起使用；</p>
<pre>&lt;Image 
    src="image-src"
    alt="image-alt-text"
    layout="fill"
    objectPosition="top right"
/&gt;
</pre>
<h3><code>loading</code>道具</h3>
<p><code>loading</code>属性类似于用于延迟加载的 HTML <code>img</code>元素的<code>loading</code>属性。可能的值是一串<code>lazy</code>或<code>eager</code>:</p>
<pre>&lt;Image 
    src="image-src"
    alt="image-alt-text"
    layout="fill"
    loading="lazy"
/&gt;
</pre>
<p>建议使用<code>priority</code>而不是<code>loading=“eager”</code>加载折叠上方的图像，因为这会影响性能。</p>
<h3><code>onLoadingComplete</code>道具</h3>
<p><code>onLoadingComplete</code> prop 是一个回调函数，在图像完全加载并移除占位符后立即执行:</p>
<pre>&lt;Image
    src="image-src"
    alt="image-alt"
    layout="fill"
    // returns:
    // {naturalWidth: &lt;imageNaturalWidth&gt;, naturalHeight: &lt;imageNaturalHeight&gt;}
   onLoadingComplete={(imageDimension) =&gt; console.log(imageDimension)}
/&gt;
</pre>
<h3><code>blurDataURL</code>道具</h3>
<p><code>blurDataURL</code>属性是一个占位符图像，在<code>src</code>图像成功加载之前加载，并且必须是 base64 编码的数据 URL 图像，只有与<code>placeholder=“blur”</code>结合使用时才有效:</p>
<pre>import Image from 'next/image';
import cardImage from '../public/defaultCardImage.webp';

export default function CardImage() {
    return (
        &lt;div classname="cardImageWrapper"&gt;
            &lt;Image
                src={cardImage}
                alt="image-alt-text"
                placeholder="blur"
                // width, height, and blurDataURL are automatically provided
            /&gt;
        &lt;/div&gt;
    )
}
</pre>
<p>这些数据是为静态导入的图像自动提供的。对于动态或远程图像，您必须手动提供<code>width</code>、<code>height</code>和<code>blurDataURL</code>。</p>
<p>你可以看到这个<a href="https://image-component.nextjs.gallery/placeholder">默认</a> <code><a href="https://image-component.nextjs.gallery/placeholder">blurDataURL</a></code> <a href="https://image-component.nextjs.gallery/placeholder">道具</a>的例子，以及 <code><a href="https://image-component.nextjs.gallery/shimmer">blurDataURL</a></code> <a href="https://image-component.nextjs.gallery/shimmer">道具</a>的<a href="https://image-component.nextjs.gallery/shimmer">微光效果。</a></p>
<h3><code>lazyBoundary</code>道具</h3>
<p><code>lazyBoundary</code>道具类似于交叉点观察器 API 中的<code><a href="https://blog.logrocket.com/lazy-loading-using-the-intersection-observer-api/">rootMargin</a></code> <a href="https://blog.logrocket.com/lazy-loading-using-the-intersection-observer-api/">，在触发惰性加载之前充当检测交叉点的边际阈值。默认为<code>200px</code>。</a></p>
<h3><code>unoptimized</code>道具</h3>
<p>当<code>unoptimized</code>道具为<code>true</code>时，<code>src</code>图像将保持原样，而不会改变质量、大小或格式:</p>
<pre>&lt;Image
    src="image-src"
    alt="image-alt-text"
    width={700}
    height={450}
    unoptimized
/&gt;
</pre>
<p>这个道具默认为<code>false</code>。</p>
<h2>其他属性的注意事项</h2>
<p>除了上面列出的属性之外，传递给<code>&lt;Image/&gt;</code>组件的其他属性将传递给底层的<code>img</code>元素，但以下属性除外:</p>
<ol>
<li><code>decoding</code>始终是<code>"async"</code></li>
<li>对于<code>ref</code>，使用<code>onLoadingComplete</code>代替</li>
<li>对于<code>srcSet</code>，使用<code>deviceSizes</code>代替</li>
<li>对于<code>style</code>，使用<code>className</code>代替</li>
</ol>
<h2>设置源图像属性的样式</h2>
<p>为了保持图像的<a href="https://blog.logrocket.com/a-closer-look-at-the-css-aspect-ratio/">纵横比，防止</a><a href="https://web.dev/vitals/#core-web-vitals">核心网页关键</a>和<a href="https://vercel.com/blog/core-web-vitals#cumulative-layout-shift">累积布局偏移</a>，<code>next/image</code>用其他<code>div</code>元素包裹<code>img</code>元素。</p>
<p>要对源图像进行<a href="https://www.smashingmagazine.com/2020/09/comparison-styling-methods-next-js/">样式化，用<code>className</code>属性命名它，然后在你的 CSS 中定位它:</a></p>
<pre>&lt;Image
    src="image-src"
    alt="image-alt-text"
    width={700}
    height={450}
    // You can style this image component with the `cardImage` class name
    className="cardImage"
/&gt;
</pre>
<h2><code>next.config.js</code>中<code>next/image</code>的配置</h2>
<p><code>next/image</code>可以通过<a href="https://nextjs.org/docs/api-reference/next.config.js/introduction"> next.config.js </a>进行配置。我们来看看其中的一些配置。</p>
<h3><code>domains</code></h3>
<p>默认情况下，Next.js 仅优化与您的 Next.js 应用程序位于同一域的图像。例如，如果您的映像在 CMS 外部托管，您必须指定允许优化哪些域。为了防止外部 URL 的滥用，需要这种特定级别:</p>
<pre>module.exports = {
    images: {
        // assuming you were using the Sanity.io image CDN
        // domains is an array of comma-separated strings
        // ['cdn.sanity.io', 'cdn.not-sanity.io', 'another domain']
        domains: ['cdn.sanity.io'],
    }
}
</pre>
<p>请记住，当<code>loader</code>被设置为外部图像服务时，<code>domains</code>配置将被忽略。</p>
<h3><code>loader</code></h3>
<p>默认情况下，Next.js 处理图像优化，但您可以将这一职责交给 Cloudinary 或 imgix 等云提供商，他们更专注于图像，而不仅仅是一般的优化。</p>
<p>为此，设置<code>loader</code>和<code>path</code>以允许使用相对 URL:</p>
<pre>module.exports = {
    images: {
        loader: 'cloudinary',
        path: 'https://your-site.com/assets/images/'
    }
}
</pre>
<h3>贮藏</h3>
<p>缓存是相当复杂的，有人说是计算机科学中最难的两件事情之一。<br/>在这种情况下，缓存加快了图像传送给用户的速度，因为它避免了网络上的重取。</p>
<p><a href="https://nextjs.org/docs/basic-features/image-optimization#caching">next . js 文档对默认加载器上的缓存</a>有充分的解释。但是，如果您使用不同的加载器，比如 Cloudinary，那么您必须参考该文档来了解如何启用缓存。</p>
<h2>高级用例的配置</h2>
<p>虽然不总是必要的，但有一些高级用例可用于优化图像。但是，请注意，如果在本节中配置任何属性，它将在未来的更新中覆盖对 Next.js 默认值的任何更改。</p>
<p>然而，让我们看看他们是什么。</p>
<h3><code>deviceSizes</code>和<code>imageSizes</code></h3>
<p>设备和图像大小相似，但有细微差别。这两种方法的优点是，网站用户的设备宽度是预先知道的。它们表示设备宽度断点列表:</p>
<pre>module.exports = {
    images: {
        // the sizes define below are the defaults
        deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
        imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    }
}
</pre>
<p><code>&lt;Image/&gt;</code>采用<code>responsive</code>或<code>fill</code>布局时<code>deviceSizes</code>有效，<code>&lt;Image/&gt;</code>采用<code>fixed</code>或<code>intrinsic</code>布局时<code>imageSizes</code>有效。</p>
<h3><code>minimumCacheTTL</code></h3>
<p>您还可以使用<code>minimumCacheTTL</code>为缓存的优化图像配置多长时间或以秒为单位的生存时间(TTL):</p>
<pre>module.exports = {
    image: {
        // This is 60 seconds
        minimumCacheTTL: 60,
    }
}
</pre>
<p>文档建议最好使用静态图像导入，它可以自动处理散列文件内容并永久缓存文件。但是，请记住，您可以禁用静态导入，所以明智地选择您的战斗。</p>
<h3><code>disableStaticImports</code></h3>
<p>如果您有自己的理由(我个人还没有遇到过)，可以禁用静态导入:</p>
<pre>module.exports = {
    images: {
        disableStaticImages: true
    }
}
</pre>
<h2>图像格式，如 WebP 和核心 Web Vitals</h2>
<p>为了确保您的用户在他们的设备上获得最佳图像，图像在受支持的浏览器中以<a href="https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types#webp"> WebP 等格式提供，允许开发人员向用户提供较亮的图像以提高速度，同时尽可能保持保真度和质量。</a></p>
<p>不同的图像格式有其使用案例。WebP 得到了很好的支持，是动画图像的最佳选择，提供了比 PNG 或 JPEG 更好的压缩。</p>
<p>由于 Next.js 优化了这种格式的图像，Next.js 网站的视觉稳定性不会受到累积布局变化的影响，并且您可以在核心网站生命体征上获得高分。</p>
<h2>结论</h2>
<p>Next.js 中的图像优化通过易于使用和扩展的改变游戏规则的强大 API 改善了用户和开发人员的体验。这无意中解决了一个主要的核心网站需求，帮助网站获得更高的搜索引擎优化排名，一切都以<code>next/image</code>开始和结束。</p><div class="code-block code-block-30">
<div class="blog-plug inline-plug next-plug"><h2><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank"> LogRocket </a>:全面了解生产 Next.js 应用</h2><p>调试下一个应用程序可能会很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪状态、自动显示 JavaScript 错误、跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-lazy-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/></noscript></a><a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你的 Next.js 应用上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用程序的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p><p>让您调试 Next.js 应用的方式现代化— <a class="signup" href="https://lp.logrocket.com/blg/nextjs-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Converting tables to grids with React compound components - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 React 复合组件将表格转换为网格</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/converting-tables-to-grids-with-react-compound-components/#0001-01-01">https://blog.logrocket.com/converting-tables-to-grids-with-react-compound-components/#0001-01-01</a></blockquote><div><article class="article-post">
<p>假设您必须构建一个用户管理仪表板，通过一个简单的 UI 来激活和停用用户，该 UI 包括一个表格和一个按钮来切换每个用户的活动状态。然而，并不是所有的用户都喜欢表格，那么如果我们允许用户在表格和网格布局之间动态切换会怎么样呢？虽然这可能会给应用程序添加额外的代码，但它也可以提供用户满意度，这是任何产品的主要目标。</p>
<p>在本文中，我们将通过利用<a href="https://blog.logrocket.com/creating-compound-components-in-react-and-angular/"> React compound components </a>模式和少量<a href="https://blog.logrocket.com/react-reference-guide-context-api/"> Context API 的</a>风格来构建一个简单的<code>LayoutSwitch</code>组件，以使我们的生活更加轻松。</p>
<p>这是一张 GIF 图，展示了我们将在本文结束时构建的完整的<code>LayoutSwitch</code>组件。</p>
<p><img data-attachment-id="51335" data-permalink="https://blog.logrocket.com/converting-tables-to-grids-with-react-compound-components/layout-switch-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/layout-switch-demo.gif" data-orig-size="730,445" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Layout switch demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/layout-switch-demo-300x183.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/layout-switch-demo.gif" decoding="async" class="aligncenter wp-image-51335 size-full jetpack-lazy-image" src="../Images/958d2867520abf130955da4759f2bef9.png" alt="Layout Switches From List To Grid By Clicking Button" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/05/layout-switch-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/layout-switch-demo.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="51335" data-permalink="https://blog.logrocket.com/converting-tables-to-grids-with-react-compound-components/layout-switch-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/05/layout-switch-demo.gif" data-orig-size="730,445" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Layout switch demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/05/layout-switch-demo-300x183.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/05/layout-switch-demo.gif" decoding="async" loading="lazy" class="aligncenter wp-image-51335 size-full" src="../Images/958d2867520abf130955da4759f2bef9.png" alt="Layout Switches From List To Grid By Clicking Button" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/05/layout-switch-demo.gif"/></noscript>
<h2>入门指南</h2>
<p>理想情况下，<code>LayoutSwitch</code>组件应该是现有 React 应用程序的一部分。为了这篇文章和实验，让我们用<a href="https://blog.logrocket.com/getting-started-with-create-react-app-d93147444a27/"> Create React App </a>样板文件创建一个新的 React 应用。</p>
<pre># using yarn
yarn create react-app react-layout-switch
# using npx
npx create-react-app react-layout-switch
</pre>
<p>切换到应用程序目录并启动 React 应用程序:</p>
<pre># switch to app directory
cd react-layout-switch
# start using yarn
yarn start
# start using npm
npm run start
</pre>
<p>这篇文章主要关注于构建<code>LayoutSwitch</code>组件；由于时间关系，我们不会在本教程中编写任何样式，所以将<code>App.css</code>和<code>index.css</code>中的样式替换为<a href="https://gist.github.com/KRRISH96/496d482a2385e9e35e951bf93ed8c862">这个 Gist 文件</a>中的样式。</p>
<h2>组件概述</h2>
<p>下面是我们将要构建的组件的概述。</p>
<h3>基础组件</h3>
<ul>
<li><code>App</code>是根组件(在这个用例中，这将是<code>AdminDashboard</code>或类似的东西)</li>
<li><code>UsersTable</code>是用于呈现表格布局的 JSX</li>
<li><code>UsersGrid</code>是生成网格布局的 JSX</li>
</ul>
<p>可以为每个业务逻辑添加更多的布局，例如 Trello 式的下拉板，用户可以在活动和非活动状态之间移动，或者使用投诉管理系统进行打开/暂停/关闭状态控制。表格或网格布局可以提供数据的快速概览，而电路板布局可以提供更多的控制。这个用例没有限制。</p>
<h3>布局控制组件</h3>
<ul>
<li><code>LayoutSwitch</code>是保存布局状态并控制子组件呈现的父组件</li>
<li><code>Options</code>是布局选项按钮的包装组件</li>
<li><code>Button</code>是每个布局选项的单独按钮</li>
<li><code>Content</code>是所有布局组件的包装器组件，包括网格、表格等等</li>
</ul>
<p><code>Options</code>和<code>Content</code>将各自的组件组合在一起，提供对渲染逻辑和样式的更多控制。</p>
<h2>获取数据和初始布局设置</h2>
<p>设置<code>App</code>组件，该组件显示从<a href="https://jsonplaceholder.typicode.com/"> JSON 占位符 API </a>获取的用户列表。</p>
<p>将以下代码添加到<code>App.jsx</code>:</p>
<pre>import React from 'react';
import { useFetch } from './hooks/useFetch';
import './App.scss';

function App() {
  const {
    data: users,
    error,
    loading,
  } = useFetch('/users');
  if (error) {
    return &lt;h2 className="error"&gt;{error}&lt;/h2&gt;;
  }
  return (
    &lt;main className="container app"&gt;
      &lt;h1&gt;Users&lt;/h1&gt;
      {loading &amp;&amp; &lt;h3&gt;Loading Users...&lt;/h3&gt;}
      {users !== null ? (
        &lt;React.Fragment&gt;
          {/** Coming Soon... Table, Grid and what not */}
        &lt;/React.Fragment&gt;
      ) : (
        &lt;h3&gt;No Users Yet&lt;/h3&gt;
      )}
    &lt;/main&gt;
  );
}
export default App;
</pre>
<p><code>useFetch</code>是一个简单的定制钩子，它接受一个端点并使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">获取 API </a>来获取并返回一个具有<code>data</code>、<code>error</code>和<code>loading</code>值的对象。</p>
<p>在<code>src/hooks</code>下创建一个名为<code>useFetch.js</code>的新文件，并从<a href="https://gist.github.com/KRRISH96/e6e3f6524545bc29b47838215795e851">这个 GitHub Gist </a>中复制代码。或者，您可以使用<a href="https://blog.logrocket.com/whats-new-in-react-query-3/"> React Query </a>、<a href="https://swr.vercel.app/"> SWR </a>或任何其他偏好来获取数据。</p>
<p>现在用户数据已经可用，让我们添加<code>UsersTable</code>和<code>UsersGrid</code>以在各自的布局中呈现用户列表。</p>
<p>首先，添加<code>UsersTable.jsx</code>:</p>
<pre>import React from 'react';

function UsersTable({ users }) {
  return (
    &lt;div className="users-table-container"&gt;
      &lt;table className="users-table"&gt;
        &lt;thead className="users-table__head"&gt;
          &lt;tr&gt;
            &lt;th&gt;#&lt;/th&gt;
            &lt;th&gt;Name&lt;/th&gt;
            &lt;th&gt;Company&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody className="users-table__body"&gt;
          {users.map(({ id, name, username, company }) =&gt; (
            &lt;tr key={username}&gt;
              &lt;td&gt;{id}&lt;/td&gt;
              &lt;td&gt;
                &lt;p&gt;{name}&lt;/p&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;p&gt;{company.name}&lt;/p&gt;
              &lt;/td&gt;
              &lt;td&gt;
                &lt;button&gt;View Posts&lt;/button&gt;
              &lt;/td&gt;
            &lt;/tr&gt;
          ))}
          {!users.length &amp;&amp; (
            &lt;tr&gt;
              &lt;td colSpan={4}&gt;No users....&lt;/td&gt;
            &lt;/tr&gt;
          )}
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  );
}
export default UsersTable;
</pre>
<p>然后，添加<code>UsersGrid.jsx</code>:</p>
<pre>import React from 'react';

function UsersGrid({ users }) {
  return (
    &lt;div className="user-grid-container"&gt;
      &lt;div className="user-cards__list"&gt;
        {users.map(({ id, name, username, company }) =&gt; (
          &lt;div key={username} className="user-card card"&gt;
            &lt;h3 className="user-name"&gt;
              &lt;p&gt;{name}&lt;/p&gt;
            &lt;/h3&gt;
            &lt;p className="company-name"&gt;
              Company: &lt;span&gt;{company.name}&lt;/span&gt;
            &lt;/p&gt;
            &lt;span className="user-posts-link"&gt;
              &lt;button&gt;View Posts&lt;/button&gt;
            &lt;/span&gt;
          &lt;/div&gt;
        ))}
        {!users.length &amp;&amp; &lt;h3&gt;No users....&lt;/h3&gt;}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
export default UsersGrid;
</pre>
<p>现在，更新<code>App.jsx</code>来渲染两个组件:</p>
<pre>.....
import UsersTable from './UsersTable';
import UsersGrid from './UsersGrid';

    .....
    {users !== null ? (
      &lt;React.Fragment&gt;
        &lt;UsersTable users={users} /&gt;
        &lt;UsersGrid users={users} /&gt;
      &lt;/React.Fragment&gt;
    ) : (
    ......
</pre>
<p>两种布局都将一个接一个地呈现。接下来我们将继续研究<code>LayoutSwitch</code>来控制布局。</p>
<h2><code>LayoutSwitch</code>及其子女</h2>
<p>通过利用复合组件模式，可以将交换逻辑抽象为专用组件<code>LayoutSwitch</code>。</p>
<p>让我们首先为<code>activeLayout</code>添加一个状态，该状态呈现包装在这个根组件下的子组件。用<code>defaultLayout</code>初始化<code>activeLayout</code>，这是这个组件的子组件旁边的唯一道具。</p>
<pre>import React, { useState } from 'react';

function LayoutSwitch({ children, defaultLayout }) {
  const [activeLayout, setActiveLayout] = useState(defaultLayout);

  return (
    &lt;React.Fragment&gt;
      {children}
    &lt;/React.Fragment&gt;
  );
}
</pre>
<p>为了与子组件共享该状态并允许从子组件(在本例中是按钮组件)更新状态，我们可以使用 React 的上下文 API。</p>
<p>创建一个<code>LayoutContext</code>，并添加<code>activeLayout</code>和<code>setActiveLayout</code>作为提供者的值。</p>
<pre>import React, { useState, createContext } from 'react';
const LayoutContext = createContext();

function LayoutSwitch({ children, defaultLayout }) {
  const [activeLayout, setActiveLayout] = useState(defaultLayout);
  const value = {
    activeLayout,
    setActiveLayout,
  };
  return (
    &lt;LayoutContext.Provider value={value}&gt;
      {children}
    &lt;/LayoutContext.Provider&gt;
  );
}</pre>
<p>使用<code>React.useContext</code>钩子，我们可以从其他组件的上下文中读取数据:</p>
<pre>const context = useContext(LayoutContext);
</pre>
<p>但是对于<code>LayoutSwitch</code>之外的组件，这个上下文将不可用，也不应该被允许。因此，让我们添加自定义钩子<code>useLayoutContext</code>，以便于阅读，并在根提供者组件之外使用时引发错误。</p>
<pre>function useLayoutContext() {
  const context = useContext(LayoutContext);
  if (!context) {
    throw new Error(
      `Components that require LayoutContext must be children of LayoutSwitch component`
    );
  }
  return context;
} 
</pre>
<p>例如:</p>
<pre># using useLayoutContext
const context = useLayoutContext();
</pre>
<p>既然已经设置了基本组件，让我们添加<code>Content</code>组件。这将呈现与<code>activeLayout</code>状态匹配的子组件，如<code>Table</code>或<code>Grid</code>。</p>
<p><code>UsersTable</code>和<code>UsersGrid</code>将是孩子，每个孩子有一个道具<code>layout</code>，让<code>Content</code>组件与状态进行比较，并呈现一个匹配的状态。</p>
<p>对于给定的活动布局状态，<code>Content</code>呈现器决定呈现哪个布局组件，是<code>Table</code>还是<code>Grid</code>。</p>
<pre>function Content({ children }) {
  const { activeLayout } = useLayoutContext();
  return (
    &lt;React.Fragment&gt;
      {children.map(child =&gt; {
        if (child.props.activeLayout !== activeLayout) return null;
        return child;
      })}
    &lt;/React.Fragment&gt;
  );
}
</pre>
<p>现在，我们有了存储<code>activeLayout</code>的内容和状态。但是我们实际上如何在布局之间切换呢？</p>
<p>为此，添加<code>Button</code>组件，该组件从上下文中获取布局的<code>setActiveLayout</code>，并相应地更新状态。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<pre>function Button({ children, layoutPreference, title }) {
  const { activeLayout, setActiveLayout } = useLayoutContext();
  return (
    &lt;button
      className={`layout-btn ${
        activeLayout === layoutPreference ? 'active' : ''
      }`}
      onClick={() =&gt; setActiveLayout(layoutPreference)}
      title={title}
    &gt;
      {children}
    &lt;/button&gt;
  );
}
</pre>
<p>我们还可以添加<code>Options</code>组件来设计样式，并获得对按钮的更多控制。</p>
<pre>function Options({ children }) {
  return (
    &lt;div className="layout-switch-container"&gt;
      {children}
    &lt;/div&gt;
  );
}
</pre>
<p>我们已经添加了所有必要的组件，一切看起来都很好。但还可以更好。</p>
<p><code>LayoutSwitch</code>应单独负责渲染和控制与布局相关的组件。任何不相关的东西都会破坏 UI 或组件本身。</p>
<p>因此，让我们使用<a href="https://reactjs.org/docs/react-api.html#isvalidelement">反应<code>isValidElement</code> </a>和<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name">child.type.name</a></code>来确保不相关的组件和元素不会与<code>LayoutSwitch</code>及其子元素一起呈现。</p>
<p>因此，要做到这一点，我们必须迭代子节点并验证每个子节点。如果它是一个有效的元素，渲染它。否则，忽略它或抛出一个错误说这是不允许的。</p>
<p>对于<code>LayoutSwitch</code>，只允许<code>Options</code>和<code>Content</code>组件作为子组件。</p>
<pre>function LayoutSwitch({ children, ... }) {
  ....
  return (
    &lt;LayoutContext.Provider value={value}&gt;
      {children.map(child =&gt; {
        if (!React.isValidElement(child)) return null;
        if (![Options.name, Content.name].includes(child.type.name)) {
          throw new Error(
            `${
              child.type.name || child.type
            } cannot be rendered inside LayoutSwitch
            Valid Components are [${Options.name}, ${Content.name}]`
          );
        }
        return child;
      })}
    &lt;/LayoutContext.Provider&gt;
  );
  ....
}
</pre>
<p>让我们也给<code>Options</code>组件类似的权力。只允许<code>Button</code>。</p>
<pre>function Options({ children }) {
  return (
    &lt;div className="layout-switch-container"&gt;
      {children.map(child =&gt; {
        if (!React.isValidElement(child)) return null;
        if (child.type.name !== Button.name) {
          throw new Error(
            `${
              child.type.name || child.type
            } cannot be rendered inside LayoutSwitch.Options
            Valid Components are [${Button.name}]`
          );
        }
        return child;
      })}
    &lt;/div&gt;
  );
}
</pre>
<h3><code>Component.name</code></h3>
<p>请注意，不要使用组件名称作为字符串来进行<code>child.type.name</code>的相等性检查。</p>
<pre># DO NOT DO THIS
child.type.name === "Options"
</pre>
<p>当通过<code>uglify/webpack</code>缩小代码时，组件名称在生产中不会保持不变。<code>Options</code>不会显示为“选项”；相反，它将显示为任何单个字符，例如本例中的<code>y</code>或<code>t</code>。</p>
<p>现在，当我们读取组件名并比较<code>child.type.name</code>和<code>Component.name</code>时，它总是为各自的子组件和组件产生相同的值。</p>
<pre>child.type.name === Options.name
# y === y or t === t or whatever === whatever
</pre>
<h3>导出<code>LayoutSwitch</code>和复合组件</h3>
<p>我们可以单独导出所有组件，并导入每个组件。</p>
<pre># export individually
export { LayoutSwitch, Options, Button, Content };

# usage
import { LayoutSwitch, Options, Button, Content } from './LayoutSwitch';
&lt;LayoutSwitch&gt;
  &lt;Options&gt;...&lt;/Options&gt;
  &lt;Content&gt;...&lt;/Content&gt;
&lt;/LayoutSwitch&gt;
</pre>
<p>另一个简单的方法是在<code>LayoutSwitch</code>下命名所有组件并导入一个组件。</p>
<pre># OR, export under single namespace
LayoutSwitch.Button = Button;
LayoutSwitch.Options = Options;
LayoutSwitch.Content = Content;

export default LayoutSwitch;

# usage
import LayoutSwitch from './LayoutSwitch';
&lt;LayoutSwitch&gt;
  &lt;LayoutSwitch.Options&gt;...&lt;/LayoutSwitch.Options&gt;
  &lt;LayoutSwitch.Content&gt;...&lt;/LayoutSwitch.Content&gt;
&lt;/LayoutSwitch&gt;
</pre>
<p>用什么方式进出口完全取决于你。</p>
<p>有了我们需要编写的所有组件，我们就可以把东西连接在一起了。</p>
<h2>收尾工作</h2>
<p>是时候将<code>LayoutSwitch</code>及其子复合组件放在一起了。我建议将所有选项作为一个<code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze</a></code>常量，这样子元素或任何外部因素都不能改变布局选项对象。更新后的<code>App</code>组件应该看起来像下面的代码:</p>
<pre>...
import { LayoutSwitch, Options, Button, Content } from './LayoutSwitch';
import { BsTable, BsGridFill } from 'react-icons/bs';

const LAYOUT_OPTIONS = Object.freeze({ table: 'table', grid: 'grid' });

function App() {
  return (
    .....
    {users !== null ? (
      &lt;LayoutSwitch defaultLayout={LAYOUT_OPTIONS.grid}&gt;
        &lt;Options&gt;
          &lt;Button
            layoutPreference={LAYOUT_OPTIONS.table}
            title="Table Layout"
          &gt;
            &lt;BsTable /&gt;
          &lt;/Button&gt;
          &lt;Button
            layoutPreference={LAYOUT_OPTIONS.grid}
            title="Grid Layout"
          &gt;
            &lt;BsGridFill /&gt;
          &lt;/Button&gt;
          &lt;/Options&gt;
          &lt;Content&gt;
            &lt;UsersTable activeLayout={LAYOUT_OPTIONS.table} users={users} /&gt;
            &lt;UsersGrid activeLayout={LAYOUT_OPTIONS.grid} users={users} /&gt;
          &lt;/Content&gt;
        &lt;/LayoutSwitch&gt;
      ) : (
    ......
  )
}
</pre>
<p>要保留用户选择的选项，请使用<code>localStorage</code>。虽然这超出了本教程的范围，但是您可以根据自己的喜好进行探索和坚持。</p>
<p>暂时就这些了！你可以在我的<a href="https://github.com/KRRISH96/react-layout-switch-blog-example/"> GitHub repo </a>中找到完整的代码，并且可以访问<a href="https://react-layout-switch-example.netlify.app/">这个演示的最终布局</a>来看看用户如何从表格切换到网格布局。</p>
<p>感谢您的阅读。我希望这篇文章对你有所帮助，请与那些可能从中受益的人分享。再见。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
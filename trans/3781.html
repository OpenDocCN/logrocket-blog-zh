<html>
<head>
<title>Building an app with Qwik </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Qwik构建应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/building-app-qwik/#0001-01-01">https://blog.logrocket.com/building-app-qwik/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按</strong>:本文由Qwik团队的一名成员进行了同行评审，以确保准确性。</em></p>
<p>Qwik是一个创建web应用程序的前端框架，无论你的站点大小和复杂程度如何，它都能提供闪电般的页面加载速度。</p>
<p>在本文中，我们将学习如何开始使用Qwik ，并通过创建一个简单的示例应用程序来探索Qwik应用程序的构建模块。我们还将回顾水合作用的概念，了解它为什么会降低我们应用程序的速度，并了解Qwik如何避免水合作用，从而提高我们应用程序的性能。我们开始吧！</p>

<h2 id="rendering-javascript-frameworks">JavaScript框架中的渲染</h2>
<p>在开始使用Qwik之前，我们首先需要了解JavaScript框架中可用的不同呈现选项。</p>
<h3 id="client-side-rendering">客户端渲染</h3>
<p>像<a href="https://angularjs.org/"> AngularJS </a>这样的早期JavaScript框架使用客户端渲染。在客户端呈现中，所有逻辑、数据获取、路由和模板化都发生在客户端。然而，客户端呈现的一个显著缺点是，随着应用程序的增长，呈现初始页面的时间会增加。</p>
<p>引入延迟加载的概念是为了加快第一次渲染的速度。通过延迟加载，你可以<a href="https://blog.logrocket.com/cross-browser-native-lazy-loading-javascript/">将你的应用分成多个更小的部分，称为块</a>，而不是一次将整个应用发送到浏览器。当应用程序第一次加载时，您将只在客户端发送和执行所需的代码，从而加快第一次渲染的速度。</p>
<h3 id="server-side-rendering">服务器端渲染</h3>
<p>在服务器端渲染中，应用程序的第一次渲染已经在服务器端完成，并以HTML格式发送到浏览器，大大加快了初始渲染的速度。</p>
<p>大多数网络应用程序都不是静态网页。因此，客户端框架必须在服务器端呈现后重新创建页面，方法是附加事件侦听器、创建DOM树并恢复应用程序状态以使其具有交互性。这个过程<a href="https://blog.logrocket.com/vue-3-lazy-hydration-from-scratch/">叫做水合</a>。水合作用的缺点是，即使页面呈现在用户的屏幕上，它也可能无法交互，直到水合作用再次下载并重新执行代码。</p>
<p>作为一个没有水化的框架，这正是Qwik试图解决的问题。</p>
<h2 id="getting-started-qwik">Qwik入门</h2>
<p>要开始使用，您需要安装Node.js ≥v16.8。</p>
<p>Qwik附带了一个CLI工具，可以帮助您搭建应用程序。首先，使用以下命令生成您的应用程序:</p>
<pre class="“language-bash">npm create <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8efff9e7e5cee2effaebfdfa">[email protected]</a>
</pre>
<p>上面的命令将提示您命名应用程序；我们选<code>dice-roller</code>。它还会提示您选择应用程序的类型；选择<strong>基础App(qwikicity)</strong>。这将在Qwik应用程序中生成一个名为<code>dice-roller</code>的目录。</p>
<p>让我们使用以下命令导航到<code>dice-roller</code>目录:</p>
<pre class="language-bash hljs">cd dice-roller
</pre>
<p>现在，让我们启动开发服务器来运行我们的应用程序:</p>
<pre>npm start
</pre>
<p>要查看应用程序的外观，请打开<code><a href="http://localhost:5174" rel="nofollow">http://localhost:5174</a></code>。</p>
<h2 id="qwik-app-structure">Qwik应用程序结构</h2>
<p>如果在代码编辑器中打开项目目录，您将看到以下文件夹结构:</p>
<pre class="language-javascript hljs">├── README.md
├── node_modules
├── package-lock.json
├── package.json
├── public
├── src
├── tsconfig.json
└── vite.config.ts
</pre>
<p>这里有几个重要的事情需要理解:</p>
<ul>
<li>TypeScript:默认情况下，Qwik应用程序支持TypeScript，如<code>tsconfig.json</code>所示</li>
<li>Vite:在开发过程中，Qwik使用<a href="https://vitejs.dev/">V</a>iteT2</li>
<li><code>src</code>:默认情况下，<code>src</code>目录用于存放源代码</li>
<li><code>public</code>:<code>public</code>目录用于静态资产</li>
</ul>
<h2 id="example-qwik-app-dice-roll-app">Qwik应用示例:掷骰子应用</h2>
<p>对于这个应用程序，我们使用的是<a href="https://qwik.builder.io/qwikcity/overview/"> QwikCity </a>，这是Qwik的元框架，就像Next.js是React一样。我们将使用QwikCity来提供基于目录的路由器和对组件树的访问。如果您打开<code>src/components/routes/index.tsx</code>，您将看到默认路由<code>/</code>导出一个带有一些内容的Qwik组件。</p>
<p>用下面的代码替换文件的内容，它模拟六面骰子的滚动:</p>
<pre class="language-javascript hljs">import { component$, useStore } from "@builder.io/qwik";

export const randomValue = () =&gt; Math.floor(Math.random() * 6) + 1;

export default component$(() =&gt; {
  const dice = useStore({
    value: 1,
  });

  return (
    &lt;div&gt;
      &lt;h2&gt;Dice roller&lt;/h2&gt;
      &lt;h3&gt;Dice value: {dice.value}&lt;/h3&gt;
      &lt;div&gt;
        &lt;button onClick$={() =&gt; (dice.value = randomValue())}&gt;Roll&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
});
</pre>
<p>如果您保存文件并在<code><a href="https://localhost:5174" rel="nofollow">https://localhost:5174</a></code>打开浏览器，您将看到以下应用程序:</p>
<p><img data-attachment-id="154074" data-permalink="https://blog.logrocket.com/building-app-qwik/attachment/qwik-dice-roller-example-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app.png" data-orig-size="730,213" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="qwik-dice-roller-example-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app-300x88.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app.png" decoding="async" class="aligncenter wp-image-154074 size-full jetpack-lazy-image" src="../Images/9b63e3266e73eba21b0ca47128b708bb.png" alt="Qwik Dice Roller Example App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app-300x88.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="154074" data-permalink="https://blog.logrocket.com/building-app-qwik/attachment/qwik-dice-roller-example-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app.png" data-orig-size="730,213" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="qwik-dice-roller-example-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app-300x88.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app.png" decoding="async" loading="lazy" class="aligncenter wp-image-154074 size-full" src="../Images/9b63e3266e73eba21b0ca47128b708bb.png" alt="Qwik Dice Roller Example App" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app-300x88.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/qwik-dice-roller-example-app.png"/></noscript>
<p>忽略页眉和页脚，它们是默认应用程序的一部分。您更改的代码用红框标出。我们来详细了解一下。</p>
<p>顾名思义，<code>component$</code>方法创建一个组件。<code>component$</code>方法来自<code>builder.io/qwik</code>包。注意<code>$</code>符号；它有一个特殊的意义，我们很快会讨论。</p>
<p>同样，像React一样，一个组件可以有<code>props</code>，您可以用它向组件传递输入。一个Qwik组件使用<code>jsx</code>。JSX模板是从创建UI的组件返回的。</p>
<p><a href="https://qwik.builder.io/docs/components/state/#usestore"> <code>useStore</code> </a>是一个Qwik钩子，可以让你创建一个类似React的<code>useState</code>的状态。每当应用程序读取或写入这些值时，Qwik都会意识到这一点，并相应地重新呈现UI。</p>
<p><a href="https://qwik.builder.io/docs/components/events/"> <code>onClick$</code> </a>是一个允许你在元素上绑定一个点击事件处理程序的属性。您可以为各种类型的事件创建事件处理程序。最后，<code>randomValue</code>方法生成一个1到6之间的随机值。</p>
<p>总之，在Qwik中，有组件、JSX、钩子和事件，比如React。然而，与React相比有一个显著的不同，这就是Qwik如何避免水合作用。</p>
<h2 id="dollar-sign">美元符号<code>$</code></h2>
<p>Qwik附带了一个<a href="https://qwik.builder.io/docs/advanced/dollar/">优化器</a>，它负责为延迟加载提取代码。这个优化器检查应用程序代码，当它<a href="https://qwik.builder.io/docs/advanced/dollar/">遇到美元<code>$</code>符号</a>时，它创建一个所谓的符号。这些符号可以很容易地被延迟加载。</p>
<p>在上面的组件示例中，<code>$</code>有两个位置；第一次在<code>component$</code>，第二次在<code>onClick$.</code></p>
<p>Qwik将为以下内容生成符号:</p>
<ul>
<li>对于组件</li>
<li>对于<code>onClick</code>事件处理程序</li>
</ul>
<p><code>$</code>符号也是给开发人员的一个信号，表明代码有特殊的含义。</p>
<h2 id="html">超文本标记语言</h2>
<p>在服务器端呈现代码后，Qwik将生成HTML并将其发送到浏览器。标记将如下所示:</p>
<pre class="language-javascript hljs">&lt;html&gt;
  &lt;body q:base="/build/"&gt;
    &lt;!--qv q:id=0 q:key=Ncbm:0t_0--&gt;
    &lt;div&gt;
      &lt;h2&gt;Dice roller&lt;/h2&gt;
      &lt;h3&gt;
        Dice value:
        &lt;!--t=1--&gt;1&lt;!----&gt;
      &lt;/h3&gt;
      &lt;div&gt;
        &lt;button
          on:click="app_component_div_div_button_onclick_yuuzzqjuatw.js#app_component_div_div_button_onClick_YuUzZQjuATw[0]"
          q:id="2"
        &gt;
          Roll
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!--/qv--&gt;
    &lt;script&gt;
      /*Qwikloader script*/
    &lt;/script&gt;
    &lt;script type="qwik/json"&gt;
      {...json...}
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>您可能会注意到HTML元素上没有JavaScript事件处理程序。这也是Qwik在第一次渲染时速度很快的原因之一。没有JavaScript就意味着没有水化。那么，交互性是如何工作的呢？</p>
<h2 id="qwikloader">qwikiloader</h2>
<p>查看<code>&lt;button&gt;</code>元素，您会注意到它有一个奇怪的属性<code>on:click</code>。浏览器会自行忽略该属性。然而，Qwik通过使用<a href="https://qwik.builder.io/docs/advanced/qwikloader/"> Qwikloader </a>利用了这个属性，Qwikloader是一个小的JavaScript代码，作为一个内联的<code>&lt;script&gt;</code>标签提供。</p>
<p>这个属性有一个看起来很奇怪的值:</p>
<pre class="language-javascript hljs">app_component_div_div_button_onclick_yuuzzqjuatw.js#app_component_div_div_button_onClick_YuUzZQjuATw[0]
</pre>
<p>这个奇怪的值被称为<a href="https://qwik.builder.io/docs/advanced/qrl/"> QRL </a>，或者Qwik URL。此URL提供以下信息:</p>
<ul>
<li>要延迟加载的JavaScript块</li>
<li>要从块中获取的符号的名称</li>
</ul>
<p>使用这个URL，Qwikloader将知道从优化器生成的块中获取和执行什么代码。但是国家呢？新获取的代码如何知道应用程序的当前状态？</p>
<h2 id="state">状态</h2>
<p>Qwik还使用HTML中的一个<code>&lt;script&gt;</code>标签以序列化的形式保存应用程序的状态。它看起来像下面这样:</p>
<pre class="language-html hljs">&lt;script type="qwik/json"&gt;{
  "refs": {
    "8": "0!"
  },
  "ctx": {},
  "objs": [
    {
      "value": "1"
    },
    1
  ],
  "subs": [
    [
      "2 #6 0 #7 data"
    ]
  ]
}&lt;/script&gt;
</pre>
<p>Qwik使用序列化状态的原因如下:</p>
<ul>
<li>在服务器上暂停执行后，在客户端重新开始执行</li>
<li>在客户端创建订阅以仅重新呈现已更改的组件</li>
</ul>
<p>这种使用延迟加载恢复应用程序并访问序列化状态而无需下载所有应用程序代码的能力被称为<a href="https://qwik.builder.io/docs/concepts/resumable/">可恢复性</a>。</p>
<h2 id="deploying">部署</h2>
<p>一旦您完成了应用程序，您就可以<a href="https://blog.logrocket.com/free-services-deploy-node-js-app/">将它部署到任何有Node.js可用的环境中</a>。Qwik提供内置集成，允许您快速部署到Netlify、Vercel等托管服务。</p>
<p>您可以通过运行以下命令来添加任何集成:</p>
<pre class="language-bash hljs">npm run qwik add
</pre>
<p>在撰写本文时，Qwik支持以下集成:</p>

<p>例如，如果要在Netlify上部署，可以运行以下命令:</p>
<pre>npm run qwik add netlify-edge
</pre>
<p>然后，您可以运行以下命令将您的应用程序部署到Netlify:</p>
<pre class="language-bash hljs">npm run build
npm run deploy
</pre>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们学习了如何开始使用Qwik。我们讲述了一些渲染技术，并探索了一些Qwik的关键API，包括组件、钩子和事件。</p>
<p>我们学习了Qwik如何通过使用Optimizer、Qwikloader和QRL使应用程序可恢复。这只是冰山一角。了解更多，请前往<a href="https://qwik.builder.io"> https://qwik.builder.io </a>了解更多关于<a href="https://qwik.builder.io/qwikcity/overview/"> QwikCity </a>、<a href="https://www.builder.io/"> Builder </a>、<a href="https://partytown.builder.io/"> Partytown </a>等等。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
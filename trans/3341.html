<html>
<head>
<title>How to use configurable module builders in NestJS v9 - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何在NestJS v9 - LogRocket博客中使用可配置模块生成器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/use-configurable-module-builders-nest-js-v9/#0001-01-01">https://blog.logrocket.com/use-configurable-module-builders-nest-js-v9/#0001-01-01</a></blockquote><div><article class="article-post">
<p>NestJS是专门用TypeScript构建的web框架。大多数有经验的开发人员会在NestJS中发现一些熟悉的东西；这是一个强大的面向对象的编程模型，它的语法与另一个框架Angular 非常相似。</p>
<p>NestJS代码经常迫使您创建一个最佳的设计模式。从Java或ASP.NET背景过渡到Node.js和TypeScript的开发人员将很快理解NestJS是如何构造的。像依赖注入、封装、类和类注释或装饰器这样的概念在NestJS中都是可用的。</p>
<p>在NestJS中，创建一个可重用的定制模块非常简单，而且最重要的是，我们鼓励这样做。将模块封装成小的、可重用的块将有助于提高NestJS应用程序的开发速度。而且，如果您决定将这些模块作为开源包发布，您会得到一些好感。</p>
<p>在本文中，我们将探索NestJS中的模块，创建我们自己的基本的、可配置的模块。为了跟进，您可以在GitHub 上访问<a href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-4">的完整代码。我们开始吧！</a></p>

<h2 id="what-nest-js-modules">什么是NestJS模块？</h2>
<p>一个模块是一组代码<span>,封装后注入到一个NestJS应用程序中。您可以使用模块来创建旨在执行特定任务的定制服务。</span>例如，<a href="https://github.com/nestjs/typeorm"> TypeORM </a>就是一个基于类型脚本的ORM。NestJS团队创建了一个模块，该模块将注入一个开放的数据库连接，允许来自注入模块的数据库命令和查询。</p>
<p>NestJS模块是框架健壮的依赖注入机制的支柱。依赖注入是一种应用程序开发模式，旨在分离两个类或模块之间的依赖关系。</p>
<p>不用为每个类都严格定义依赖关系，您可以使用一个接口来指定一种契约，说明依赖关系应该如何表现，同时没有它应该如何运行的文字定义。最后，解耦架构支持多种应用，并为应用中的每个模块创建了即插即用的行为。</p>
<h2 id="nest-js-module-state-management">NestJS模块状态管理</h2>
<p>默认情况下，NestJS模块是单例的，这意味着您只需要初始化一个模块一次。虽然从工程的角度来看，为每个模块创建单例似乎有些过分，但是NestJS <a href="https://github.com/nestjs/nest/issues/47#issuecomment-300283919">在组件级别</a>初始化单例。</p>
<h3 id="module-scopes-nest-js">NestJS中的模块范围</h3>
<p>在NestJS中，模块有三个注入范围:</p>
<ol>
<li>请求级模块</li>
<li>组件级模块或瞬态模块</li>
<li>共享应用程序级模块</li>
</ol>
<p>默认情况下，大多数NestJS模块是应用程序级模块，也称为全局共享模块。但是，不是每个模块都可以是全局模块。其中一些需要保持瞬态或请求级模块。</p>
<p>例如，如果您需要一个应用程序级的只读模块，您最好的选择是使用全局共享模块。存储在模块中的数据不会经常改变，所以它可以作为应用程序级的单例对象被延迟，以节省内存并创建一个全局可访问的类。带有<code>@Global</code>装饰器的模块消除了代码和组件级的冗余，因为你不需要重新初始化模块。</p>
<p>为了更好地理解模块级的状态保持，如果在一个具有瞬态或请求范围的模块中有一个常量，它将是一个不可变的变量，直到模块在垃圾收集时销毁它。但是，当使用跨整个应用程序的全局模块时，它只会在应用程序的生命周期结束时被销毁。</p>
<h2 id="preventing-data-racing-conditions-singletons">使用单例时防止数据竞争</h2>
<p>使用单例时要小心的另一件事是数据竞争问题。<a href="https://stackoverflow.com/questions/21438207/can-node-js-code-result-in-race-conditions"> Node.js不能免受</a>数据竞争条件的影响，NestJS也是如此。</p>
<p>当两个独立的进程试图同时更新同一个数据块时，就会出现数据争用情况。因为对象是全局可访问的，同时执行数据可能会导致执行时丢失数据点。</p>
<p>避免数据竞争情况的最佳实践包括创建一个全局只读模块，并对每个模块的注入范围更加谨慎。全局模块最容易受到数据竞争条件的影响，使用全局模块在组件之间通信或管理状态将导致反模式。</p>
<p>但是，为什么瞬态组件级模块不能这样说呢？在组件级别，封装障碍只扩展到组件的需求。每个瞬态模块提供程序都有一个专用的实例。组件级的关注点分离通常更细粒度，这使得它比大规模应用程序更容易预测。请求级的单例也是如此，尽管规模较小。</p>
<h3 id="injection-scopes-modules-nest-js">NestJS模块注入范围</h3>
<p>总之，在NestJS中有三种模块注入范围:</p>
<ol>
<li>请求级模块</li>
<li>组件级模块:瞬态</li>
<li>共享应用程序级模块:全局</li>
</ol>
<p>每一种都有其优点和缺点，数据竞争是全局模块最常见的问题。大多数全局模块应该是只读的，NestJS在初始化时只会设置一次原始状态。</p>
<p>组件级模块有更多的细微差别。更具体地说，由于它们的可预测性，您可以将它们用于较小规模的状态管理。单例在组件级提供的粒度封装使其成为组件级状态管理的完美选择。</p>
<p>请记住，数据竞争条件只限于每个独立模块的状态。修改数据库等外部应用程序中的数据应该不成问题，因为数据库有自己的数据竞争解决方案。</p>
<h2 id="dynamic-modules-nestjs">NestJS中的动态模块</h2>
<p>默认的NestJS模块是静态的，不可配置。可配置模型构建器本质上是动态模块工厂，可以根据初始化时传递的变量生产不同的模块。</p>
<p>在开始使用可配置模块之前，您需要了解动态模块的基础知识。它们的用例通常围绕创建非静态模块，这些模块可以从外部API接收参数，以改变模块的行为方式，特别是每个模块处理数据的方式。</p>
<p>例如，假设您创建了一个从数据库中查询数据的模块，但是您不想为特定的数据库提供者硬编码它。你如何解决这个问题？</p>
<p>首先，您需要创建一个具有配置功能的模块。配置函数将有一个数据库提供者接口作为参数，它拥有应用程序连接和查询数据库所需的所有基本功能。因为使用接口作为参数，所以只要提供者扩展了接口，就可以注入不同的数据库提供者。</p>
<p>底层的业务逻辑仍然是相同的，但是数据库提供者将根据您在初始化时提供的而改变。因此，您的模块将不再是静态的，而是动态的。这就是为什么所有的可配置模块都是动态模块的原因。</p>
<h2 id="architecting-basic-configurable-nest-js-module">构建一个基本的可配置NestJS模块</h2>
<p>例如，我们将创建一个定制的NestJS模块，它使用<code>dotenv</code>包中的<code>process.env</code> API从<code>.env</code>文件中读取数据。该模块将作为可配置的代理，您可以在您的项目中使用:</p>
<p> </p>
<p> </p>
<p><img data-attachment-id="132127" data-permalink="https://blog.logrocket.com/use-configurable-module-builders-nest-js-v9/attachment/basic-nestjs-configurable-module-architecture/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture.png" data-orig-size="730,502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="basic-nestjs-configurable-module-architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture-300x206.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture.png" decoding="async" class="aligncenter wp-image-132127 size-full jetpack-lazy-image" src="../Images/1f793520f37595ef719599fde0efff2d.png" alt="Basic NestJS Configurable Module Architecture" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture-300x206.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="132127" data-permalink="https://blog.logrocket.com/use-configurable-module-builders-nest-js-v9/attachment/basic-nestjs-configurable-module-architecture/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture.png" data-orig-size="730,502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="basic-nestjs-configurable-module-architecture" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture-300x206.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture.png" decoding="async" loading="lazy" class="aligncenter wp-image-132127 size-full" src="../Images/1f793520f37595ef719599fde0efff2d.png" alt="Basic NestJS Configurable Module Architecture" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture-300x206.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/basic-nestjs-configurable-module-architecture.png"/></noscript>
<p> </p>
<p> </p>
<p><a href="https://mermaid.live/edit#pako:eNqNkUFuwyAQRa-CZpWo8SJZWt21OUG3SAjB2EGywYIhtZX67h2FOHXTVior-P_BH2YuYIJFqMF0OqVXp9uoe-kFr1H1weYOxfNHVQn0ZzXEME43tTCPamFZMZiSYvfhqVo8meATscLQgJEmtf8Hc_jOMDKqJnuj9pvtX9Zhsa5f-1HqpZhCVCXtXiwrLdLRnzfFGDS3ZHv33h2dXoJvXPuLP68TV234CutwFTUvclmwgx5jr53lgVyvSKAT9iih5q3FRueOJEg_M5oHqwmP1lGIUFPMuAOdKbxN3iznwtzGWsT5E4s7pd8">模块架构</a></p>
<p>代理模块的架构似乎是多余的，因为您可以直接访问<code>process.env</code>变量，而无需依赖注入。但是，为了简单起见，您将使用这个架构来完全掌握NestJS模块是如何工作的。</p>
<p>您的代理模块将在初始化时检索<code>process.env</code>，并将其存储在其<code>env</code>属性中。默认情况下，NestJS模块是单例的，所以只需要初始化一次。您可以执行<code>getEnv</code>函数来检索您的<code>env</code>变量。它将作为动态<code>env</code>属性的获取器。</p>
<p>您可以在初始化时添加一个函数来接受参数并创建一个动态模块，使其可配置。在这种情况下，<code>withConfig</code>功能将是可配置的<code>init</code>功能。</p>
<h2 id="create-basic-configurable-nest-js-module">如何创建一个基本的可配置NestJS模块</h2>
<p>使用以下命令全局安装<code>@nest/cli</code>:</p>
<pre class="language-bash hljs">npm i -g @nest/cli
</pre>
<p>然后，生成新的NestJS应用程序:</p>
<pre class="language-javascript hljs">nest new configurable-module-builder-examples
</pre>
<p>你可以选择你喜欢的包管理器，但是在本教程中，我们将主要使用Yarn。通过进入<a href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-1"> <code>step-1</code>分支</a>，你可以看到你已经生成的代码。</p>
<p>新的NestJS项目在一个层次上包含了所有的模块；您需要在继续之前重构它。将模块、控制器和服务复制到名为<code>api-modules</code>和<a href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-2/src/api-module">的文件夹中，并将所有文件和变量名</a>从<code>App</code>重命名为<code>Api</code>。</p>
<p>创建一个新的<code>AppModule</code>文件，并在导入中注入<code>ApiModule</code>，如下所示:</p>
<pre class="language-javascript hljs">import { Module } from '@nestjs/common';
import { ApiModule } from './api-module/api.module';
@Module({
  imports: [ApiModule],
})
export class AppModule {}
</pre>
<p>如果你没有跟上，检查存储库中的<a href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-2"> <code>step-2</code>分支</a>。现在，您可以开始创建<code>process.env</code>代理模块了。您需要<code>dotenv</code>包来访问<code>.env</code>文件，所以通过运行下面的命令来安装依赖项:</p>
<pre class="language-bash hljs">yarn add dotenv
</pre>
<p>创建一个名为<code>src/env-proxy-module</code>的新文件夹，并从<code>env-proxy.module.ts</code>开始创建两个文件:</p>
<pre class="language-javascript hljs">import { Global, Module } from '@nestjs/common';
import { EnvProxyService } from './env-proxy.service';
@Global()
@Module({
  providers: [EnvProxyService],
  exports: [EnvProxyService],
})
export class EnvProxyModule {}
</pre>
<p>注意,<code>@Global</code> decorator用于自动将模块的输出注入到注入组件的任何子组件中。您不必在每个模块上重复导入<code>EnvProxyModule</code>。相反，您只需要将它作为导入添加到主<code>AppModule</code>中:</p>
<pre class="language-javascript hljs">import { EnvProxyModule } from './env-proxy-module/env-proxy.module';
@Module({
  imports: [ApiModule, EnvProxyModule],
})
export class AppModule {}
</pre>
<p>然后，创建服务文件，<code>env-proxy.service.ts</code>:</p>
<pre class="language-javascript hljs">import { Injectable } from '@nestjs/common';
require('dotenv').config(); // eslint-disable-line
@Injectable()
export class EnvProxyService {
  public readonly env: NodeJS.ProcessEnv;
  constructor() {
    this.env = process.env;
  }
}
</pre>
<p>为了测试<code>EnvProxyModule</code>，您可以创建一个<code>.env</code>文件，其中包含一个<code>DATA</code>参数:</p>
<pre class="language-javascript hljs">DATA=Hello World
</pre>
<p>通过在<code>GET</code>请求中返回环境变量来试用该模块:</p>
<pre class="language-javascript hljs">import { EnvProxyService } from '../env-proxy-module/env-proxy.service';
@Injectable()
export class ApiService {
  constructor(private readonly envProxy: EnvProxyService) {}
  getHello(): string {
    return this.envProxy.env.DATA;
  }
}
</pre>
<p>现在，运行开发服务器:</p>
<pre class="language-bash hljs">yarn start:dev
</pre>
<p>打开浏览器并转到<code>localhost:3000</code>。你应该得到一句“你好，世界！”回短信。你可以在<a href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-3"> <code>step-3</code>分支</a>中看到这一步的完整代码。</p>
<p>我们已经创建了一个简单的模块，但它还不可配置。你可以使用<a href="https://docs.nestjs.com/fundamentals/dynamic-modules#configurable-module-builder"> <code>ConfigurationModuleBuilder</code> </a>来这样做。<code>ConfigurableModuleBuilder</code>是NestJS v9中提供的新特性，其目的是减少创建可配置动态模块所需编写的样板代码的数量。</p>
<p>在<code>src/env-proxy-module</code>中，创建一个名为<code>env-proxy.definition.ts</code>的新文件:</p>
<pre class="language-javascript hljs">import { ConfigurableModuleBuilder } from '@nestjs/common';
export interface EnvProxyModuleOptions {
  exclude: string[];
}
export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
  new ConfigurableModuleBuilder&lt;EnvProxyModuleOptions&gt;({
    moduleName: 'EnvProxy',
  })
    .build();
</pre>
<p><code>EnvProxyModuleOptions</code>接口表示您在初始化时通过配置文件传递的对象。在这种情况下，您将传递一个要从模块中排除的环境变量数组。</p>
<p>使<code>EnvProxyModule</code>伸出<code>ConfigurableModuleBuilder</code>，如下所示:</p>
<pre class="language-javascript hljs">@Global()
@Module({
  providers: [EnvProxyService],
  exports: [EnvProxyService],
})
export class EnvProxyModule extends ConfigurableModuleClass {}
</pre>
<p>继续到<code>EnvProxyService</code>类并实现下面的代码:</p>
<pre class="language-javascript hljs">@Injectable()
export class EnvProxyService {
  public readonly env: NodeJS.ProcessEnv;
  constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: EnvProxyModuleOptions) {
    this.env = process.env;
    options.exclude.forEach(val =&gt; {
      delete this.env[val];
    });
  }
}
</pre>
<p>我们从构造函数和<code>@Inject</code>装饰器中检索<code>EnvProxyModuleOptions</code>对象。然后，我们将排除环境变量的主要业务逻辑添加到<code>EnvProxyService</code>构造函数中。为了进行测试，您可以创建第二个名为<code>DATA2</code>的环境变量:</p>
<pre class="language-javascript hljs">DATA=Hello World
DATA2=Hello World2
</pre>
<p>在<code>AppModule</code>导入上，添加一个<code>register</code>函数并插入一个<code>EnvProxyModuleOptions</code>:</p>
<pre class="language-javascript hljs">imports: [ApiModule, EnvProxyModule.register({
  exclude: [
    "DATA"
  ]
})],
</pre>
<p>模块将排除<code>DATA</code>变量，以检查排除是否有效。如下编辑<code>ApiService</code>:</p>
<pre class="language-javascript hljs">getHello(): string {
  return this.envProxy.env.DATA ?? this.envProxy.env.DATA2;
}
</pre>
<p>当你访问<code>localhost:3000</code>时，你会得到<code>Hello World2</code>。</p>
<p>至此，您已经使用可配置模块生成器创建了您的第一个可配置模块！你可以在这里查看<a href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-4">最终代码库。</a></p>
<p>如果您的配置比前一个示例更复杂，您可以依赖工厂模式:</p>
<pre class="language-javascript hljs">import { EnvProxyModule } from './env-proxy-module/env-proxy.module';
@Module({
  imports: [ApiModule, EnvProxyModule.registerAsync({
    useFactory: async () =&gt; {
      return {
        exclude: [
          "DATA"
        ]
      }
    }
  })],
})
export class AppModule {}
</pre>
<p><code>useFactory</code>允许你调用异步代码来帮助你配置你的构建器。你可以在GitHub 上找到最终的异步例子<a href="https://github.com/agustinustheo/configurable-module-builder-example/tree/step-4-async">。</a></p>
<h2 id="summary">摘要</h2>
<p>NestJS是一个内置于TypeScript中的面向对象的web框架。NestJS使用了强大的面向对象原则，并提供了许多功能，包括依赖注入、类、通过decorators的类注释和强大的封装。</p>
<p>NestJS中的状态管理在模块级别上有所不同。大多数模块的封装仅限于组件级，而很少有模块在应用程序级具有全局共享状态。所有的NestJS模块都使用单件。如果处理不当，拥有可以全局使用的共享模块会导致数据竞争。</p>
<p>大多数共享模块应该是只读的，但是也有一些情况下共享模块是实用的，记录和连接到消息队列。否则，您将只需要组件级的模块。</p>
<p>动态模块是非静态的可配置模块。本质上，所有可配置的模块都是动态的。可配置模块使用工厂模式根据初始化期间给定的参数创建不同的模块。</p>
<p>编写定制的NestJS模块非常简单。您可以访问GitHub上的代码示例，并且您可以使用不同的分支<a href="https://github.com/agustinustheo/configurable-module-builder-example">来导航项目</a>的每个阶段。我希望你喜欢这篇文章，如果你有任何问题，请留下评论。编码快乐！</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
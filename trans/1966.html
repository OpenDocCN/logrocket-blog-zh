<html>
<head>
<title>Ditching try...catch and null checks with Rust - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>尝试开沟...Rust - LogRocket 博客的捕获和空检查</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/ditching-try-catch-and-null-checks-in-rust/#0001-01-01">https://blog.logrocket.com/ditching-try-catch-and-null-checks-in-rust/#0001-01-01</a></blockquote><div><article class="article-post">
<p>这篇文章是由一个刚进入 Rust 世界的 JavaScript 开发者写的。从这篇文章中获取价值并不需要 JS 背景！但是，如果你是一个由网络开发人员转型而来的农村人，你会更理解我的观点。</p>
<p/>
<p>似乎在过去十年中构建的语言都在遵循一个共同的趋势:淘汰面向对象模型，引入<a href="https://blog.logrocket.com/functional-programming-in-go/" target="_blank" rel="noopener">函数式编程</a> (FP)。</p>
<p>Web 开发人员可能已经看到 FP 模式出现在现代前端框架中，比如 React 使用<a href="https://blog.logrocket.com/react-hooks-cheat-sheet-unlock-solutions-to-common-problems-af4caf699e70/" target="_blank" rel="noopener">他们的钩子模型</a>。但是转到 Rust，当你围绕它构建一个完整的编程语言时，你会看到 FP 是多么强大——而接近<code>try...catch</code>和<code>null</code>只是冰山一角！</p>
<p>让我们探索抛出和捕捉异常的缺陷，Rust 的<code>Result</code>枚举和模式匹配能为你做什么，以及这如何扩展到处理<code>null</code>值。</p>
<h2>什么是铁锈？</h2>
<p>给你新的<a href="https://www.rust-lang.org/" target="_blank" rel="noopener"> Rustaceans </a> (yee-claw！🦀)，Rust 是一种底层的类型化语言，对所有程序员来说都足够友好。很像 C，Rust 直接编译成机器码(原始二进制)，所以 Rust 程序可以编译和运行得非常快。他们也非常重视交流和文档，拥有繁荣的<a href="https://www.rust-lang.org/community" target="_blank" rel="noopener">贡献者社区</a>和<a href="https://www.rust-lang.org/learn" target="_blank" rel="noopener">过多的优秀教程</a>。</p>
<h2>为什么不应该在生锈时使用<code>try...catch</code>块</h2>
<p>如果你像我一样，你已经习惯了在你的 JavaScript 代码库中跳<code>catch</code>舞。以这个场景为例:</p>
<pre>// Scenario 1: catching a dangerous database call
app.get('/user', async function (req, res) {
  try {
    const user = await dangerousDatabaseCall(req.userId)
    res.send(user)
  } catch(e) {
    // couldn't find the user! Time to tell the client
    // it was a bad request
    res.status(400)
  }
})
</pre>
<p>这是典型的服务器模式。去调用数据库，当它工作时发送响应给用户，当它不工作时发送一些类似<code>400</code>的错误代码。</p>
<p>但是我们怎么知道在这里使用<code>try...catch</code>呢？嗯，有了像<code>dangerousDatabaseCall</code>这样的名字和对数据库的一些直觉，我们<em>知道</em>它可能会在出错时抛出一个异常。</p>
<p>现在让我们来看看这个场景:</p>
<pre>// Scenario 2: forgetting to catch a dangerous file reading
app.get('/applySepiaFilter', async function (req, res) {
  const image = await readFile("/assets/" + req.pathToImageAsset)
  const imageWithSepiaFilter = applySepiaFilter(image)
  res.send(imageWithSepiaFilter)
})
</pre>
<p>当然，这是一个人为的例子。但是，简而言之，每当我们调用<code>applySepiaFilter</code>时，我们都希望从服务器的<code>/assets</code>中读取所请求的文件，并应用颜色过滤器。</p>
<p>但是等等，我们忘了在这上面加上一个<code>try...catch</code>！因此，每当我们请求一些不存在的文件时，我们都会收到一个讨厌的内部服务器错误。这最好是一种<code>400</code>“错误请求”状态。😕</p>
<p>现在你可能会想，“好吧，但是<em>我</em>不会忘记那个<code>try...catch</code>……”可以理解！一些 Node.js 程序员可能会立即意识到<code>readFile</code>抛出了异常。</p>
<p>但是当我们使用库函数<em>而没有</em>记录异常或者使用我们自己的抽象(如果你像我一样好斗，可能根本没有记录)时，这变得更加难以预测😬).</p>
<p>总结 JS 异常处理的一些核心问题:</p>
<ul>
<li><strong>如果一个函数曾经</strong> <code>throw</code> <strong> s，调用者必须<em>记住</em>来处理那个异常。</strong>不，你的花式<a href="https://eslint.org/" target="_blank" rel="noopener"> ESlint </a>设置在这里帮不了你！这可能会导致我称之为<code>try...catch</code>的焦虑:把一切都包在<code>try</code>块中，以防出错。或者更糟的是，你会完全忘记<code>catch</code>一个异常，导致像我们未被捕获的<code>readFile</code>调用那样的令人窒息的失败</li>
<li><strong>异常的类型是不可预测的。对于围绕多个故障点的<code>try...catch</code>包装器来说，这可能是个问题。例如，如果我们的<code>readFile</code>爆炸应该返回一个状态代码，而<code>applySepiaFilter</code>失败应该返回另一个状态代码，那该怎么办？我们有多个<code>try...catch</code>区块吗？如果我们需要查看异常的<code>name</code>字段(哪个<a href="https://stackoverflow.com/questions/3656854/javascript-list-of-exceptions" target="_blank" rel="noopener">可能不可靠</a>浏览器端)呢？</strong></li>
</ul>
<p>我们来看看 Rust 的<code>Result</code> enum。</p>
<h2>使用 Rust 的<code>Result</code>枚举和模式匹配</h2>
<p>这里有个惊喜:Rust 没有<code>try...catch</code>块。见鬼，就我们所知，他们甚至没有“例外”。</p>
<h3>了解<code>match</code>铁锈</h3>
<p>💡如果您已经了解模式匹配，请随意跳到下一部分。</p>
<p>在探索这怎么可能之前，让我们先理解 Rust 的模式匹配思想。这里有一个场景:</p>
<p>一位饥饿的顾客从我们的韩国街头食品菜单上点了一份<code>meal</code>，我们希望根据他们选择的<code>orderNumber</code>为他们提供不同的<code>meal</code>。</p>
<p>在 JavaScript 中，您可能会遇到一系列这样的条件:</p>
<pre>let meal = null
switch(orderNumber) {
  case 1:
    meal = "Bulgogi"
    break
  case 2:
    meal = "Bibimbap"
    break
  default:
    meal = "Kimchi Jjigae"
    break
}
return meal
</pre>
<p>这足够易读，但是它有一个明显的缺陷(除了使用难看的<code>switch</code>语句):在我们的<code>switch</code>案例中，我们的<code>meal</code>需要以<code>null</code> <em>开始，而</em>需要使用<code>let</code>进行重新分配。要是<code>switch</code>真的能像这样<em>返回</em>一个值就好了…</p>
<pre>// Note: this is not real JavaScript!
const meal = switch(orderNumber) {
  case 1: "Bulgogi"
  case 2: "Bibimbap"
  default: "Kimchi Jjigae"
}
</pre>
<p>你猜怎么着？Rust 让你做到了这一点！</p>
<pre>let meal = match order_number {
  1 =&gt; "Bulgogi"
  2 =&gt; "Bibimbap"
  _ =&gt; "Kimchi Jjigae"
}
</pre>
<p>神圣的语法，蝙蝠侠！😮</p>
<p>这就是 Rust 的表情驱动设计的妙处。在这种情况下，<code>match</code>被认为是一个表达式，可以:</p>
<ol>
<li>动态执行一些逻辑(将订单号与餐串匹配)</li>
<li>最后返回该值(可分配给<code>meal</code>)</li>
</ol>
<p>条件句也可以是表达式。JavaScript 开发人员可能会触及三元组:</p>
<pre>const meal = orderNumber === 1 ? "Bulgogi" : "Something else"
</pre>
<p>Rust 只是让你写一个<code>if</code>语句:</p>
<pre>let meal = if order_number == 1 { "Bulgogi" } else { "Something else" }
</pre>
<p>是的，你可以跳过<code>return</code>这个词。Rust 表达式的最后一行总是返回值。🙃</p>
<h3>将<code>match</code>应用于异常</h3>
<p>好的，那么这如何应用于异常呢？</p>
<p>这次让我们先来看一个例子。假设我们正在编写与前面相同的<code>applySepiaFilter</code>端点。为了清楚起见，我将使用相同的<code>req</code>和<code>res</code>助手:</p>
<pre>use std::fs::read_to_string;

// first, read the requested file to a string
match read_to_string("/assets/" + req.path_to_image_asset) {
  // if the image came back ay-OK...
  Ok(raw_image) =&gt; {
    // apply the filter to that raw_image...
    let sepia_image = apply_sepia_filter(raw_image)
    // and send the result.
    res.send(sepia_image)
  }
  // otherwise, return a status of 400
  Err(_) =&gt; res.status(400)
}
</pre>
<p>嗯，那些<code>Ok</code>和<code>Err</code>包装纸是怎么回事？让我们比较一下 Rust 的<code>read_to_string</code>和 Node 的<code>readFile</code>的返回类型:</p>
<ul>
<li>在 Node land 中，<code>readFile</code>返回一个<code>string</code>你可以立即<em>使用</em></li>
<li>在 Rust 中，<code>read_to_string</code>不是<em>返回一个字符串，而是返回<a href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html" target="_blank" rel="noopener">一个<code>Result</code>类型的</a>在</em>周围缠绕<em>一个字符串。完整的返回类型看起来像这样:<code>Result&lt;std::string::String, std::io::Error&gt;</code>。换句话说，这个函数返回的结果是一个字符串或者 I/O 错误</em></li>
</ul>
<p>这意味着我们不能处理<code>read_to_string</code>的结果，直到我们“解开”它(即，弄清楚它是一个字符串还是一个错误)。如果我们试图把一个<code>Result</code>当作一个字符串来处理，会发生以下情况:</p>
<pre>let image = read_to_string("/assets/" + req.path_to_image_asset)
// ex. try to get the length of our image string
let length = image.len()
// 🚨 Error: no method named `len` found for enum
// `std::result::Result&lt;std::string::String, std::io::Error&gt;`
</pre>
<p>第一种更危险的方法是自己调用<code>unwrap()</code>函数:</p>
<pre>let raw_image = read_to_string("/assets/" + req.path_to_image_asset).unwrap()
</pre>
<p>🚨但是这不太安全！如果你试图调用<code>unwrap</code>而<code>read_to_string</code>返回某种错误，整个程序将会因为所谓的<a href="https://doc.rust-lang.org/std/macro.panic.html" target="_blank" rel="noopener">恐慌</a>而崩溃。记住，Rust 没有<code>try...catch</code>，所以这可能是一个非常棘手的问题。</p>
<p>第二种也是更安全的方法是通过模式匹配来解开我们的结果。让我们用一些澄清性的评论来回顾一下前面的内容:</p>
<pre>match read_to_string("/assets/" + req.path_to_image_asset) {
  // check whether our result is "Ok," a subtype of Result that
  // contains a value of type "string"
  Result::Ok(raw_image) =&gt; {
    // here, we can access the string inside that wrapper!
    // this means we're safe to pass that raw_image to our filter fn...
    let sepia_image = apply_sepia_filter(raw_image)
    // and send the result
    res.send(sepia_image)
  }
  // otherwise, check whether our result is an "Err," another subtype
  // that wraps an I/O error. 
  Result::Err(_) =&gt; res.status(400)
}
</pre>
<p>注意我们在最后的<code>Err</code>中使用了下划线<code>_</code>。这是“我们不关心这个值”的一种老套说法，因为我们总是返回一个状态<code>400</code>。如果我们真的关心那个错误对象，我们可以像我们的<code>raw_image</code>一样获取它，甚至通过异常类型做另一层模式匹配。</p>
<h3>为什么模式匹配是处理异常的更安全的方法</h3>
<p>那么，为什么要处理像<code>Result</code>这样不方便的“包装器”呢？乍一看，这似乎很烦人，但从设计上看，它们确实很烦人，因为:</p>
<ol>
<li>无论何时出现错误，您都必须处理，用模式匹配定义成功和失败案例的行为。而且，如果你真的想得到结果并继续前进，你可以使用<code>unwrap()</code>选择加入不安全行为</li>
<li>根据函数的返回类型，你总是知道函数<em>何时会</em>出错，这意味着不再有<code>try...catch</code>焦虑，也不再有简单的类型检查👍</li>
</ol>
<h2>如何在 Rust 中使用<code>null</code></h2>
<p>这又是 Rust 能解决的 JS 的一个毛角落。对于函数返回值，当我们需要考虑某种特殊或默认情况时，我们会用到<code>null</code>(或<code>undefined</code>)。当一些转换失败，一个对象或数组元素不存在，等等，我们可能会抛出一个<code>null</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>但是在这些上下文中，null 只是一个无名的异常！我们可能会接触到 JS 中的<code>null</code>返回值，因为<code>throw</code>出现异常感觉不安全或极端。我们想要的是一种引发异常的方法，但是没有错误类型或错误消息的麻烦，并且希望调用者使用一个<code>try...catch</code>。</p>
<p>拉斯特也意识到了这一点。因此，Rust 将<code>null</code>从语言中驱逐出去，并引入了<a href="https://doc.rust-lang.org/std/option/" target="_blank" rel="noopener">的<code>Option</code>包装器</a>。✨</p>
<p>假设我们有一个<code>get_waiter_comment</code>函数，它根据顾客留下的小费来给予顾客称赞。我们可以用这样的东西:</p>
<pre>fn get_waiter_comment(tip_percentage: u32) -&gt; Option&lt;String&gt; {
    if tip_percentage &lt;= 20 {
        None
    } else {
        Some("That's one generous tip!".to_string())
    }
}
</pre>
<p>当我们不想要称赞时，我们可以返回一个空字符串。但是通过使用<code>Option</code>(很像使用<code>null</code>)，更容易判断我们是否有赞美要展示。看看这个<code>match</code>语句的可读性如何:</p>
<pre>match get_waiter_comment(tip) {
  Some(comment) =&gt; tell_customer(comment)
  None =&gt; walk_away_from_table()
}
</pre>
<h3>何时使用<code>Option</code>与<code>Result</code></h3>
<p><code>Result</code>和<code>Option</code>之间的界限很模糊。我们可以很容易地将前面的例子重构为:</p>
<pre>fn get_waiter_comment(tip_percentage: u32) -&gt; Result&lt;String&gt; {
    if tip_percentage &lt;= 20 {
        Err(SOME_ERROR_TYPE)
    } else {
        Result("That's one generous tip!".to_string())
    }
}
...
match get_waiter_comment(tip) {
  Ok(comment) =&gt; tell_customer(comment)
  Err(_) =&gt; walk_away_from_table()
}
</pre>
<p>唯一的区别是我们需要为我们的<code>Err</code>案例提供一些错误对象，这可能是一个麻烦，因为被调用者需要提供一个错误<code>type /</code>消息来使用，调用者需要检查错误消息是否真的值得阅读和匹配。</p>
<p>但是在这里，很明显错误消息不会给我们的<code>get_waiter_comment</code>函数增加多少价值。这就是为什么我通常会选择<code>Option</code>，直到我有一个很好的理由换成<code>Result</code>类型。不过，决定权在你！</p>
<h2>总结(没有双关语)</h2>
<p>Rust 处理<code>exception</code>和<code>null</code>的方法是类型安全的巨大胜利。有了表达式、模式匹配和包装器类型的概念，我希望您已经准备好在整个应用程序中安全地处理错误！</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust 应用的 web 前端的全面可见性</h2><p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录你的 Rust 应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket 还可以监控应用的性能，报告客户端 CPU 负载、客户端内存使用等指标。</p><p>现代化调试 Rust 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
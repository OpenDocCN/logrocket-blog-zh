<html>
<head>
<title>A deep dive into CSS Module - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>深入 CSS 模块- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/a-deep-dive-into-css-modules/#0001-01-01">https://blog.logrocket.com/a-deep-dive-into-css-modules/#0001-01-01</a></blockquote><div><article class="article-post">
<h2 id="introduction">介绍</h2>
<p>根据<a href="https://github.com/css-modules/css-modules">官方 CSS 模块 GitHub 库</a>的定义，CSS 模块是一个 CSS 文件，默认情况下所有的类名和动画名都在本地作用域。相比之下，在典型的 CSS 文件中，所有的 CSS 选择器都位于全局范围内。</p>
<p>在本教程中，我们将研究编写 CSS 时经常出现的一些常见问题，并了解 CSS 模块如何帮助我们避免这些问题。然后，我们将 CSS 模块集成到 React 应用程序中。</p>
<p>我们开始吧！</p>
<h2 id="prerequisites">先决条件</h2>
<ul>
<li>HTML 和 CSS 知识</li>
<li>React 的工作知识</li>
</ul>
<p>熟悉 CSS 模块是一个额外的奖励！</p>
<h2 id="understandingcommoncssissues">了解常见的 CSS 问题</h2>
<p>CSS 中的所有选择器都是全局变量。随着应用程序的扩展，处理全局变量和管理依赖关系变得越来越困难。当几个开发者一起开发这个应用时，事情变得更加棘手。</p>
<p>原因如下:</p>
<h3>名称冲突</h3>
<p>假设在设计博客时，我们添加了类名<code>post</code>来表示主页上的帖子。另一个开发人员创建了侧边栏，并为侧边栏上的帖子添加了类名<code>post</code>。像这样的错误会导致名称冲突，如下所示:</p>
<pre>/* styles */
.main .post {
  color: #000000;
  font-size: 2rem;
}

.sidebar .post {
  color: #FFFFFF;
  font-size: 1rem;
}
</pre>
<p><span class="ace-line-pocket-zws" data-faketext="" data-contentcollector-ignore-space-at="end"> </span> <span class="ace-line-pocket-zws" data-faketext="" data-contentcollector-ignore-space-at="start"> </span> <span class="added">作为</span> <span class="added">一个</span> <span class="added">应用 s </span> <span class="added thread-259037507796500470640471"> cales </span> <span class="added">，</span> <span class="added">你更容易遇到 n </span> <span class="added"> ame 碰撞</span> <span class="added h-lparen"> ( </span> <span class="added h-lparen">潜在的</span> <span class="added">危害性表现</span><span class="added"/><span class="added longkeep">。</span></p>
<h3>清除死代码的困难</h3>
<p>当从我们的代码中删除一个元素或一个 React 组件时，我们也需要删除它的样式。然而，在大型应用程序中，很难确定一个类是否在使用中。CSS 没有提供现成的解决方案。</p>
<h3>依赖性管理</h3>
<p>当处理全局变量时，没有明确定义依赖关系，这使得很难确定哪些样式将通过<a href="https://github.com/css-modules/css-modules#composition">合成</a>来继承或应用。</p>
<p>CSS 中还有其他隐含的依赖关系，仅仅通过扫描代码是不容易识别的。例如，带有<code>position: absolute</code>的元素与其带有<code>position: relative</code>的父元素相关。</p>
<p>依赖关系是一个很大的问题，维护 CSS 代码的容易程度很大程度上取决于依赖关系的结构。</p>
<h2 id="evaluatingsolutions">评估解决方案</h2>
<p>BEM-Block Element 修饰符是 HTML 和 CSS 中一种流行的类命名约定，旨在帮助开发人员理解两种语言之间的关系。BEM 通过提供严格的命名规则解决了上述问题。</p>
<p>在 BEM 中，<code>Block</code>是一个独立的元素，它本身就有意义；往往是类似<code>.btn{}</code>的父元素。一个<code>Element</code>是指一个<code>Block</code>的子元素；它没有独立的含义，由跟在<code>Block</code>(例如<code>.btn__text</code>)名称后面的两个下划线表示。</p>
<p>修改器是<code>Block</code>或<code>Element</code>上的一个标志，用于设置样式。它由<code>Block</code>或<code>Element</code>(如<code>.btn--primary {}</code>)名称的两个连字符表示。</p>
<pre>// Block Element
.btn {}

// Element that depends on the Block often a child element
.btn__text {
  // rules
}

// Modifiers that changes the styles of the block
.btn--primary {}
.btn--small {}
</pre>
<p>BEM 命名方法的好处是，尽管所有的选择器都是全局的，但它们都被修饰符限定了作用域。然而，手动添加 BEM 命名是重复的、相当乏味的，并且容易出现人为错误。</p>
<p>你可能最终会花费大量的时间来判断某样东西是<code>Block</code>还是<code>Element</code>。在我看来，<a href="https://bulma.io/">布尔玛 CSS </a>的创作者，<a href="https://twitter.com/jgthms">杰瑞米·托马斯</a>完美地总结了这个问题:</p>
<p><img data-attachment-id="53339" data-permalink="https://blog.logrocket.com/a-deep-dive-into-css-modules/bulma-css-jeremy-thomas-css-time-writing/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing-.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bulma-css-jeremy-thomas-css-time-writing-graph" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing--300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing-.png" decoding="async" class="aligncenter wp-image-53339 size-full jetpack-lazy-image" src="../Images/0e5d051908001adfedf4aaadb26d663b.png" alt="Bulma CSS Jeremy Thomas CSS Time Writing Graph" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing-.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing--300x169.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing-.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing-.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="53339" data-permalink="https://blog.logrocket.com/a-deep-dive-into-css-modules/bulma-css-jeremy-thomas-css-time-writing/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing-.png" data-orig-size="730,411" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="bulma-css-jeremy-thomas-css-time-writing-graph" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing--300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing-.png" decoding="async" loading="lazy" class="aligncenter wp-image-53339 size-full" src="../Images/0e5d051908001adfedf4aaadb26d663b.png" alt="Bulma CSS Jeremy Thomas CSS Time Writing Graph" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing-.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing--300x169.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/bulma-css-jeremy-thomas-css-time-writing-.png"/></noscript>
<p>开发包括自动化困难的问题，所以我们应该能够用正确的工具轻松地自动化命名。</p>
<blockquote><p>注意:虽然 CSS 模块使我们能够确定样式的范围，但是我们仍然可以通过在类名前面加上<code>:global:</code>来声明全局类</p></blockquote>
<pre>:global .title {
font-size: 2rem;
}</pre>
<h2 id="benefitsofcssmodule">CSS 模块的优势</h2>
<p>大多数现代的 JavaScript 和 CSS 工作流已经趋向于基于组件的架构，但是 CSS 的发展一直是纯传统的，并没有得到该语言的实际支持。</p>
<p>如前所述，边界元法是一个完美的例子。众所周知的软件工程基本定理宣称“计算机科学中的每个问题都可以通过一个额外的抽象层来解决”。</p>
<p>CSS 模块是一个抽象的薄层，它封装了引入到语言中的新概念。因此，CSS 模块就像普通 CSS 一样编写，如下面的代码片段所示:</p>
<pre>/* styles.css */
.title {
  font-size: 2rem;
  font-weight: bold;
  color: red;
}
.text {
  font-size: 1.2rem;
  font-weight: 500;
  color: blue;
}
</pre>
<p>一个不同之处是，在 CSS 模块中，我们所有的标记都是在一个类似<code>index.js</code>的 JavaScript 文件中编写的:</p>
<pre>import styles from "./styles.css";
document.getElementById("app").innerHTML = `
&lt;h1 class=${styles.title}&gt;Hello Vanilla!&lt;/h1&gt;
&lt;div class=${styles.text}&gt;
  We use the same configuration as Parcel to bundle this sandbox, you can find more
  info about Parcel 
&lt;/div&gt;
`;
</pre>
<p>当我们从<code>index.js</code>文件导入 CSS 模块时，CSS 模块导出一个对象，该对象具有从本地名称到全局名称的映射:</p>
<pre>{
  title: "_src_styles__title",
  text: "_src_styles__text"
}
</pre>
<p/>
<p>我们可以看到 CSS 模块动态生成唯一的类名，为我们整个团队自动命名。</p>
<h2 id="howcssmoduleworks">CSS 模块如何工作</h2>
<p>像 webpack、Browsify 和 JSPM 这样的现代工具使我们能够明确定义跨语言依赖。因此，我们可以明确地描述每个文件的依赖关系，而不管源文件的类型。</p>
<p>在下面的代码片段中，每当加载或捆绑<code>MyComponent</code>时，相应的 CSS 就像任何其他依赖项一样被加载:</p>
<pre>import './my-component-name.css';
const MyComponent = () =&gt; {
  // component codes
}
export default MyComponent;
</pre>
<p>CSS 模块包含了这项新技术，这是现代装载机的关键功能。然而，在基本层面上，需要一个新的规范来描述这些符号是如何被共享的。</p>
<h3>了解 ICSS</h3>
<p>虽然 CSS 模块编写得像普通的 CSS，但它实际上编译成一种低级的可互换格式，称为 ICSS <a href="https://github.com/css-modules/icss"> (I </a> <a href="https://github.com/css-modules/icss">不可操作的 CSS </a> <a href="https://github.com/css-modules/icss"> ) </a>，它是为加载器实现者而不是最终用户设计的。它是标准 CSS 的超集，是增强 CSS 的低级文件格式。</p>
<p>你可以将 CSS 模块整合到一个<a href="https://github.com/css-modules/css-modules/blob/master/docs/get-started.md#setting-up-css-modules">广泛的应用程序</a>中，但是，我们将设计一个 React 应用程序。</p>
<h2 id="stylingareactapplicationwithcssmodule">用 CSS 模块设计 React 应用程序的样式</h2>
<p><a href="https://github.com/facebook/create-react-app">创建 React App v2 </a>(及更高版本)支持开箱即用的 CSS 模块。我们所要做的就是使用以下命名约定:</p>
<pre>[name].module.css
</pre>
<p>让我们通过构建一个简单的 React 应用程序来看看它的实际应用吧！首先，让我们引导并运行我们的应用程序:</p>
<pre>npx create-react-app button-stack
cd botton-stack
npm start
</pre>
<p>接下来，我们将通过简单地将<code>App.css</code>文件重命名为<code>App.module.css</code>来为我们的应用程序添加 CSS 模块支持。更新<code>App.js</code>文件中的导入语句以避免错误:</p>
<pre>.shadow {
  box-shadow: rgba(50, 50, 50, 0.2) 0 5px 5px 0;
}
.app {
  display: flex;
  justify-content: space-around;
}
.title {
  margin-top: 25%;
  text-align: center;
}
</pre>
<p>将<code>Index.css</code>文件更新为<code>Index.module.css</code>，以及<code>Index.js</code>文件中的导入语句。接下来，在我们的<code>App.js</code>文件中，添加以下代码:</p>
<pre>import { title, app } from './App.module.css';
import Button from './components/Button';
function App() {
    return (
        &lt;div&gt;
            &lt;h1 className={title}&gt;CSS Module Buttons&lt;/h1&gt;
            &lt;article className={app}&gt;
                &lt;Button /&gt;
            &lt;/article&gt;
        &lt;/div&gt;
    );
}
export default App;
</pre>
<p>虽然大部分代码应该是熟悉的，但有几件事我们需要注意。首先，我们正在析构<code>title</code>和<code>app</code>。我们需要的样式来自于由 CSS 模块导出的<code>styles</code>对象。</p>
<p>现在，我们需要创建<code>Button component</code>。在<code>src</code>目录下，创建一个<code>components</code>文件夹。在文件夹内，创建一个<code>Button.js</code>和一个<code>Button.module.css</code>文件；在<code>Button.module.css</code>文件中添加以下代码:</p>
<pre>.normal-button {
    display: inline-flex;
    line-height: 2;
    text-align: center;
    padding: 1px 60px;
    font-family: "IBM Plex Sans";
    font-size: 1rem;
    font-weight: 500;
    border-radius: 4px;
    cursor: pointer;
    composes: shadow from "../App.module.css"
  }

  .danger {
    composes: normal-button;
    background-color: rgb(255, 8, 8);
    border: 2px solid rgb(255, 8, 8);
    color: white;
  }

  .secondary {
    composes: normal-button;
    background-color: rgb(128, 118, 118);
    border: 2px solid rgb(128, 118, 118);
    color: white;
  }

  .info {
    composes: normal-button;
    background-color: rgb(6, 218, 255);
    border: 2px solid rgb(6, 218, 255);
    color: white;
  }

  .warning {
    composes: normal-button;
    background-color: rgb(248, 202, 49);
    border: 2px solid rgb(248, 202, 49);
    color: #ffffff;
  }

  .success {
    composes: normal-button;
    background-color: rgba(30, 156, 41, 0.966);
    border: 2px solid rgba(30, 156, 41, 0.966);
    color: white;
  }

  .primary {
    composes: normal-button;
    background-color: rgba(33, 124, 243, 0.849);
    border: 2px solid rgba(33, 124, 243, 0.849);
    color: #FFFFFF;
  }
</pre>
<p>在这个文件中，我们有一个普通的按钮类<code>.normal-button</code>，它由<code>App.module.css</code>组成<code>shadow class</code>。</p>
<p>组合是 CSS 模块中的一个特性，它使我们能够组合选择器。因此，我们可以通过从另一个类继承样式来构建一个类，但是这些<code>composes</code>规则必须在其他规则之前。</p>
<p>例如，<code>.danger</code>、<code>.info</code>、<code>.primary</code>、<code>.warning</code>、<code>.success</code>类都是通过 composition 从<code>.normal-botton</code>继承样式。</p>
<p>我们的<code>App.js</code>文件现在应该看起来像下面的代码:</p>
<pre>import { title, app } from './App.module.css';
import Button from './components/Button';
function App() {
    return (
        &lt;div&gt;
            &lt;h1 className={title}&gt;CSS Module Buttons&lt;/h1&gt;
            &lt;article className={app}&gt;
                &lt;Button /&gt;
            &lt;/article&gt;
        &lt;/div&gt;
    );
}
export default App;
</pre>
<p>我们的应用程序显示应该如下图所示:</p>
<p><img data-attachment-id="53341" data-permalink="https://blog.logrocket.com/a-deep-dive-into-css-modules/css-module-final-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app.png" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="css-module-final-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app.png" decoding="async" class="aligncenter wp-image-53341 size-full jetpack-lazy-image" src="../Images/eb09116a430bc776a3d524356eca6531.png" alt="CSS Module Final App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app-300x157.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="53341" data-permalink="https://blog.logrocket.com/a-deep-dive-into-css-modules/css-module-final-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app.png" data-orig-size="730,381" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="css-module-final-app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app-300x157.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app.png" decoding="async" loading="lazy" class="aligncenter wp-image-53341 size-full" src="../Images/eb09116a430bc776a3d524356eca6531.png" alt="CSS Module Final App" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app-300x157.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/css-module-final-app.png"/></noscript>
<p>可以查看<a href="https://github.com/lawrenceagles/css-module-demo">完整代码</a>进行教程。</p>
<h2 id="conclusion">结论</h2>
<p>毫无疑问，CSS 模块为 CSS 语言提供了多年来最重要的改进之一！CSS 模块最大的好处之一就是我们可以编写优秀的老 CSS，并且可以集成到各种应用程序中。它只是给 CSS 增加了更多的功能！</p>
<p>如果您的 React 应用程序不使用 Create React 应用程序，或者它使用低于版本 2 的版本，您仍然可以通过使用<code><a href="https://github.com/gajus/babel-plugin-react-css-modules">babel-plugin-react-css-module</a></code>添加对 CSS 模块的支持。</p>
<p> </p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的 CPU？</h2><p>随着 web 前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端 CPU 使用情况、内存使用情况等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>
 
</div>    
</body>
</html>
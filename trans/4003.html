<html>
<head>
<title>Build an accessible modal with focus-trap-react </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用焦点-陷阱-反应建立一个可访问的模型</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-accessible-modal-focus-trap-react/#0001-01-01">https://blog.logrocket.com/build-accessible-modal-focus-trap-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>构建一个可访问的模型可能是一项棘手的任务，但是使用正确的工具和技术，这是可行的。可访问性的一个重要方面是确保用户可以只使用键盘在模态中导航。实现这一点的一种方法是使用focus-trap-react库。</p>
<p>在深入技术细节之前，让我们先了解一下什么是可访问模态。可访问模式也称为对话框，是一种用户界面组件，用于在当前视图顶部的单独窗口或覆盖层中显示内容。这些模态通常用于显示表单、确认或对网页主要内容不重要的附加信息。</p>
<p>无障碍模式旨在供所有用户使用，包括残障人士。实现可访问模态的方法之一是使用<a href="https://github.com/focus-trap/focus-trap-react"> focus-trap-react </a>包。</p>
<p>focus-trap-react是一个简单、轻量级的库，帮助在特定的DOM元素中捕获焦点，比如模态对话框或菜单。这确保了用户可以只使用键盘在模态中导航，而不会意外地与模态之外的元素交互。</p>
<p>您可以使用该组件来构建各种类型的用户界面，如模式、下拉菜单和工具提示，这些界面对于所有用户(包括残障人士)来说都是易于访问和使用的。</p>
<p><em>向前跳跃</em>:</p>

<h2 id="requirements">要求</h2>
<p>要学习本教程，您必须安装以下软件:</p>
<ul>
<li>Node.js是一个JavaScript运行时，支持在服务器端执行JavaScript。你可以在这里得到它</li>
<li>代码编辑器:为了编写和编辑你的代码，你需要一个像<a href="https://code.visualstudio.com/"> Visual Studio Code </a>这样的代码编辑器</li>
</ul>
<p>需要注意的是，教程使用的是<a href="https://github.com/facebook/react/blob/main/CHANGELOG.md#1820-june-14-2022"> React 18.2.0 </a>和<a href="https://www.npmjs.com/package/focus-trap-react"> focus-trap-react v10 </a>。如果您想在本文中看到完整的项目开发，请看一下<a href="https://github.com/hulyak/modal-focus-trap"> GitHub项目</a>。请随意克隆它、派生它或提交一个问题。</p>
<h2 id="setting-up-project">设置我们的项目</h2>
<p>打开命令行，导航到要创建项目的目录。然后，执行以下命令，使用<a href="https://create-react-app.dev/"> Create React App </a>创建一个新的React项目:</p>


<pre class="language-bash hljs">npx create-react-app focus-trap-example&#13;
</pre>
<p>这将创建一个名为<code>focus-trap-example</code>的新目录，其中包含构建React应用程序所需的基本文件结构和配置。接下来，导航到新项目目录:</p>
<pre class="language-shell hljs">cd focus-trap-example&#13;
</pre>
<p>然后，使用npm或Yarn安装focus-trap-react软件包:</p>

<pre class="language-bash hljs">npm install focus-trap-react&#13;
# or&#13;
yarn add focus-trap-react&#13;
</pre>


<h2 id="building-modal">建立模型</h2>


<p>一旦安装了库，就可以开始构建模态组件了。</p>


<p>首先，在项目的<code>src</code>目录下创建一个名为<code>Modal.js</code>的新文件。</p>


<p>然后，通过在文件顶部添加以下行，将focus-trap-react库导入到新文件中:</p>


<pre class="language-javascript hljs">import FocusTrap from "focus-trap-react"&#13;
</pre>
<p>接下来，创建一个名为<code>Modal</code>的新功能组件，并使用<code>FocusTrap</code>组件包装模态的内容。<code>FocusTrap</code>创建一个焦点陷阱，当它打开时在模态中保持焦点，当它关闭时将焦点返回到打开模态的元素:</p>
<pre class="language-javascript hljs">const Modal = () =&gt; {&#13;
  return (&#13;
    &lt;FocusTrap&gt;&#13;
      &lt;div className="modal-content"&gt;&#13;
        &lt;h2&gt;Modal Title&lt;/h2&gt;&#13;
        &lt;p&gt;Modal content goes here...&lt;/p&gt;&#13;
        &lt;button className="link-button"&gt;Close Modal&lt;/button&gt;&#13;
        &lt;a href="#" className="link-href"&gt;&#13;
          Some tabbable element&#13;
        &lt;/a&gt;&#13;
      &lt;/div&gt;&#13;
    &lt;/FocusTrap&gt;&#13;
  )&#13;
}&#13;
</pre>
<p>使用<code>FocusTrap</code>时，确保组件至少有一个可制表的子元素，或者一个可聚焦的元素。可聚焦元素是HTML文档中可以获得焦点的元素，例如按钮、链接、输入字段和其他交互式元素，如复选框或选择框。可以使用键盘的Tab键导航到这些元素，也可以通过用鼠标或触摸设备点击它们来激活它们。</p>
<p>主要的可聚焦元素是:</p>
<ul>
<li><code>&lt;a&gt;</code>(锚)</li>
<li><code>&lt;button&gt;</code></li>
<li><code>&lt;input&gt;</code>(所有类型)</li>
<li><code>&lt;select&gt;</code></li>
<li><code>&lt;textarea&gt;&lt;/code</code></li>
<li><code>&lt;label&gt;</code></li>
</ul>
<p>您还可以通过给其他元素一个<code><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex">tabindex</a></code>属性来使它们成为焦点。正整数值将使元素按照数字指定的顺序成为焦点。0的<code>tabindex</code>将使元素成为焦点，但是将在所有具有正<code>tabindex</code>的元素之后被导航。</p>
<p>在这个例子中，<code>FocusTrap</code>用于在模态中捕获焦点。模态内容包括一个<code>button</code>和一个<code>a</code>标签，目的是使其可制表，以便<code>FocusTrap</code>可以关注它:</p>
<figure class="wp-block-video"><video src="https://blog.logrocket.com/wp-content/uploads/2023/02/modal-content.mov" controls="controls"/></figure>
<h2 id="adding-focustrapoptions">添加焦点选项</h2>
<p>要定制<code>FocusTrap</code>的行为，您可以使用<code><a href="https://github.com/focus-trap/focus-trap-react#focustrapoptions">focusTrapOptions</a></code>属性来指定当模态第一次打开时应该聚焦哪个元素。</p>
<p><code>initialFocus</code>选项允许您指定当陷阱被激活时，焦点陷阱中的哪个元素应该接收焦点。例如，您可能希望将焦点设置在模式中的link元素上:</p>
<pre class="language-javascript hljs">const Modal = () =&gt; {&#13;
  return (&#13;
    &lt;FocusTrap focusTrapOptions={{ initialFocus: "#modal-link" }}&gt;&#13;
      &lt;div className="modal-content"&gt;&#13;
        &lt;h2&gt;Modal Title&lt;/h2&gt;&#13;
        &lt;p&gt;Modal content goes here...&lt;/p&gt;&#13;
        &lt;button className="link-button"&gt;Close Modal&lt;/button&gt;&#13;
        &lt;a href="#" className="link-href" id="modal-link"&gt;&#13;
          Some tabbable element&#13;
        &lt;/a&gt;&#13;
      &lt;/div&gt;&#13;
    &lt;/FocusTrap&gt;&#13;
  )&#13;
}&#13;
export default Modal&#13;
</pre>
<p>在本例中，当模态打开时，<code>a href</code>链接将被聚焦:</p>
<figure class="wp-block-image aligncenter"><img data-attachment-id="161298" data-permalink="https://blog.logrocket.com/?attachment_id=161298" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open.png" data-orig-size="730,479" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The a href link will be focused when modal is open" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open-300x197.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open.png" decoding="async" class="wp-image-161298 aligncenter jetpack-lazy-image" src="../Images/689e2697617821387899df5d0ca1cec9.png" alt="The A Href Link Focused When Modal Is Open" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open-300x197.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="161298" data-permalink="https://blog.logrocket.com/?attachment_id=161298" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open.png" data-orig-size="730,479" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="The a href link will be focused when modal is open" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open-300x197.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open.png" decoding="async" loading="lazy" class="wp-image-161298 aligncenter" src="../Images/689e2697617821387899df5d0ca1cec9.png" alt="The A Href Link Focused When Modal Is Open" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open-300x197.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/ahref-focused-modal-open.png"/></noscript></figure>
<p>我们将在另一部分探讨其他选项。</p>
<h2 id="making-modal-functional">使模态函数化</h2>
<p>目前，我们的modal没有打开按钮，关闭按钮也不起作用。让我们使用钩子和函数使模态函数化:</p>
<pre class="language-javascript hljs">import { useState } from "react"&#13;
import FocusTrap from "focus-trap-react"&#13;
&#13;
const Modal = () =&gt; {&#13;
  const [isOpen, setIsOpen] = useState(false)&#13;
&#13;
  const openModal = () =&gt; setIsOpen(true)&#13;
  const closeModal = () =&gt; setIsOpen(false)&#13;
&#13;
  return (&#13;
    &lt;&gt;&#13;
      &lt;button onClick={openModal} className="button"&gt;&#13;
        Open Modal&#13;
      &lt;/button&gt;&#13;
      {isOpen &amp;&amp; (&#13;
        &lt;FocusTrap focusTrapOptions={{ initialFocus: "#modal-link" }}&gt;&#13;
          &lt;div className="modal-content"&gt;&#13;
            &lt;h2&gt;Modal Title&lt;/h2&gt;&#13;
            &lt;p&gt;Modal content goes here...&lt;/p&gt;&#13;
            &lt;button className="link-button" onClick={closeModal}&gt;&#13;
              Close Modal&#13;
            &lt;/button&gt;&#13;
            &lt;a href="#" className="link-href" id="modal-link"&gt;&#13;
              Some tabbable element&#13;
            &lt;/a&gt;&#13;
          &lt;/div&gt;&#13;
        &lt;/FocusTrap&gt;&#13;
      )}&#13;
    &lt;/&gt;&#13;
  )&#13;
}&#13;
export default Modal&#13;
</pre>
<p>在这个例子中，<code>useState</code>钩子被用来创建一个状态变量<code>isOpen</code>，它跟踪模态当前是打开的还是关闭的。默认情况下，这个变量被设置为<code>false</code>，这意味着当页面第一次加载时模态是关闭的。</p>
<p>定义了两个函数<code>openModal</code>和<code>closeModal</code>，分别将<code>isOpen</code>的值改为true和false。这些函数作为处理程序传递给<code>Open Modal</code>和<code>Close Modal</code>按钮，这样当按钮被点击时，模态就会打开或关闭。当<code>isOpen</code>状态为真时，模态在屏幕上变得可见:</p>
<figure class="wp-block-video"><video src="https://blog.logrocket.com/wp-content/uploads/2023/02/modal-visible-screen-isopen-state.mov" controls="controls"/></figure>
<h2 id="adding-more-focustrapoptions">添加更多内容<code>focusTrapOptions</code></h2>
<p>我们在前面的章节中已经看到了<code>initialFocus</code>选项。再来看看其他几个。</p>
<p>首先考虑<code>onPostActivate</code>。该选项在焦点陷阱激活后和初始焦点设置后调用。这是在打开模式并设置焦点后执行附加操作的一种方式:</p>
<pre class="language-javascript hljs">import { useRef } from 'react';&#13;
import FocusTrap from "focus-trap-react"&#13;
&#13;
const Modal = () =&gt; {&#13;
  const firstInputRef = useRef(null);&#13;
  &#13;
  return (&#13;
    &lt;&gt;&#13;
      &lt;button onClick={openModal}&gt;Open Modal&lt;/button&gt;&#13;
      {isOpen &amp;&amp; (&#13;
        &lt;FocusTrap&#13;
          focusTrapOptions={{&#13;
            onPostActivate: () =&gt; {&#13;
              firstInputRef.current.focus();&#13;
            },&#13;
          }}&#13;
        &gt;&#13;
          &lt;div className="modal-content"&gt;&#13;
            &lt;input type="text" ref={firstInputRef}/&gt;&#13;
            &lt;button onClick={closeModal}&gt;Close Modal&lt;/button&gt;&#13;
          &lt;/div&gt;&#13;
        &lt;/FocusTrap&gt;&#13;
      )}&#13;
    &lt;/&gt;&#13;
  )&#13;
&#13;
}&#13;
</pre>
<p>在这个例子中，当打开模态并设置焦点时，调用<code>onPostActivate</code>，它将焦点设置在模态中的第一个输入元素上，因此用户可以在模态打开后立即在输入字段中开始输入。</p>
<p>添加此功能会使用户体验更加流畅和自然，因为在打开模式后让用户在表单中输入信息是一个常见的用例:</p>
<figure class="wp-block-video"><video src="https://blog.logrocket.com/wp-content/uploads/2023/02/setting-focus-first-input-element-modal-1.mov" controls="controls"/></figure>
<p>让我们来看看其他一些选项:</p>
<ul>
<li><code>onActivate</code>:该选项允许您指定一个当焦点陷阱被激活时将被执行的回调函数。例如，您可能希望向模态元素添加一个类，以便在它处于活动状态时更改它的外观</li>
<li><code>onDeactivate</code>:该选项允许您指定一个当焦点陷阱失效时将被执行的回调函数。例如，您可能希望删除激活时添加的类</li>
<li><code>clickOutsideDeactivates</code>:该选项允许您指定当用户在陷阱外单击时，是否应禁用焦点陷阱。它是一个布尔值，默认情况下设置为<code>true</code>，这意味着当用户在它之外单击时，焦点陷阱将被禁用。</li>
</ul>
<p>现在，让我们将这些选项添加到我们的模式中:</p>
<pre class="language-javascript hljs">import { useRef } from "react"&#13;
import FocusTrap from "focus-trap-react"&#13;
&#13;
const Modal = () =&gt; {&#13;
  const modalRef = useRef(null)&#13;
&#13;
  const onActivate = () =&gt; {&#13;
    modalRef.current.classList.add("active")&#13;
  }&#13;
  const onDeactivate = () =&gt; {&#13;
    modalRef.current.classList.remove("active")&#13;
  }&#13;
  return (&#13;
    &lt;&gt;&#13;
      &lt;div&gt;&#13;
        &lt;button onClick={openModal} className="button"&gt;&#13;
          Open Modal&#13;
        &lt;/button&gt;&#13;
      &lt;/div&gt;&#13;
      {isOpen &amp;&amp; (&#13;
        &lt;FocusTrap&#13;
          focusTrapOptions={{&#13;
            onActivate,&#13;
            onDeactivate,&#13;
            clickOutsideDeactivates: true,&#13;
          }}&#13;
        &gt;&#13;
          &lt;div&#13;
            className="modal-content"&#13;
            ref={modalRef}&#13;
          &gt;&#13;
           {/* JSX elements */}       &#13;
          &lt;/div&gt;&#13;
        &lt;/FocusTrap&gt;&#13;
      )}&#13;
    &lt;/&gt;&#13;
  )&#13;
}&#13;
</pre>
<p>在这个例子中，我们使用<code>useRef</code>钩子来创建对模态元素的引用，然后将它作为ref传递给包装了模态内容的div元素。这样，我们可以通过使用<code>modalRef.current</code>来访问<code>onActivate</code>和<code>onDeactivate</code>回调中的元素。</p>
<p><code>onActivate</code>函数将类<code>"active"</code>添加到模态元素中，当模态元素打开时，它将背景颜色更改为<code>blue</code>。</p>
<p>当模态关闭时，<code>onDeactivate</code>函数从模态元素中移除<code>"active"</code>类。</p>
<p><code>clickOutsideDeactivates: true</code>选项告诉焦点陷阱在单击发生在模态之外时停用，因此当用户在模态之外单击时，模态将关闭:</p>
<figure class="wp-block-video"><video src="https://blog.logrocket.com/wp-content/uploads/2023/02/deactivating-focus-when-click-happens-outside-modal.mov" controls="controls"/></figure>
<p>你可以在<a href="https://github.com/focus-trap/focus-trap#createoptions">聚焦陷阱文档</a>中找到选项的完整列表。</p>
<h2 id="testing-modal">测试我们的模型</h2>
<p>在<code>App.js</code>中导入模态组件并渲染模态组件:</p>
<pre class="language-javascript hljs">import "./App.css"&#13;
import Modal from "./Modal"&#13;
&#13;
export default function App() {&#13;
  return (&#13;
    &lt;div className="App"&gt;&#13;
      &lt;Modal /&gt;&#13;
    &lt;/div&gt;&#13;
  )&#13;
}&#13;
</pre>
<p>然后，从终端运行您的应用程序:</p>
<pre class="language-bash hljs">npm start&#13;
# or&#13;
yarn start&#13;
</pre>
<p>这将启动一个开发服务器，您应该在<code><a href="http://localhost:3000/">http://localhost:3000</a></code>看到应用程序在浏览器中运行。</p>
<p>要测试模态:</p>
<ul>
<li>使用Tab键在模式中的可聚焦元素间导航</li>
<li>使用回车键激活按钮和链接</li>
<li>使用<code>Shift + Tab</code>键以相反的顺序浏览模态，并检查焦点是否反向移动通过模态的可聚焦元素</li>
</ul>
<p>此外，用像<a href="https://www.freedomscientific.com/products/software/jaws/"> JAWS </a>或<a href="https://www.nvaccess.org/download/"> NVDA </a>这样的屏幕阅读器来测试modal是很重要的，以确保它对不同能力的用户来说都像预期的那样工作。</p>
<h2 id="conclusion">结论</h2>
<p>focus-trap-react库是一个低级的库，它提供了在一个组件中捕获焦点的基本功能，但是它不提供内置的可访问性特性，比如添加ARIA属性。</p>
<p>您可以使用另一个库，如<a href="https://github.com/davidtheclark/react-aria-modal"> react-aria-modal </a>，它提供了完全可访问的模态对话框，遵循WAI-ARIA创作实践，您可以将它与focus-trap-react一起使用。</p>
<p>为了使一个模型具有可访问性，遵循<a href="https://www.w3.org/WAI/standards-guidelines/aria/"> WAI-ARIA </a>创作实践指南是很重要的。这包括为该模式提供一个清晰的描述性标签，确保该模式可以使用键盘关闭，并在该模式中捕获焦点，以便用户可以使用键盘浏览其内容。</p>
<p>总之，focus-trap-react库是一个简单有效的方法，可以让你的模态更容易访问。值得注意的是，在模态中捕获焦点只是使模态可访问的一个方面。您还应该确保模式标签正确，关闭按钮清晰可见且易于访问。此外，您应该考虑使用屏幕阅读器和其他辅助技术的用户的需求。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用LogRocket消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款React analytics解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket告诉您React应用程序中实际影响用户的最具影响力的bug和UX问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS异常、前端性能指标和用户交互。然后，LogRocket使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>How to style scroll snap points with CSS </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>如何用CSS设置滚动捕捉点的样式</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/style-scroll-snap-points-css/#0001-01-01">https://blog.logrocket.com/style-scroll-snap-points-css/#0001-01-01</a></blockquote><div><article class="article-post">
<p>滚动对齐是一种交互增强(如果实现正确的话)，现在是一种原生CSS特性，可以帮助用户对齐某些滚动点。这样做的好处是，它可以帮助用户捕捉到应该一起观看的各种内容元素，减少整体所需的滚动量，并防止过度滚动。</p>
<p>在本教程中，您将学习如何构建包含可捕捉内容的HTML容器。我们将使用CSS的<a href="https://blog.logrocket.com/how-to-use-css-scroll-snap/">滚动捕捉属性</a>,看看你附近的网络浏览器中的其他CSS滚动捕捉特性。目标是避免使用JavaScript来构建更高性能的解决方案，因为对于滚动捕捉来说，JavaScript不再是必需的。我们将只使用CSS。</p>
<p>此外，您可能已经正确地猜测到，对于滚动捕捉，有许多与<a href="https://blog.logrocket.com/category/ux-design/"> UX相关的</a>警告，我们将在后面讨论。</p>
<p>我们开始吧！</p>
<p><em>向前跳转:</em></p>

<h2 id="started-css-project">开始我们的CSS项目</h2>
<p>首先，这是我们要做的:</p>
<p class="codepen" data-height="399.53515625" data-default-tab="html,result" data-slug-hash="XWBpmKy" data-user="mrdanielschwarz">请看<a href="https://codepen.io"> CodePen </a>上丹尼尔·施瓦茨(<a href="https://codepen.io/mrdanielschwarz"> @mrdanielschwarz </a> ) <br/>的笔<a href="https://codepen.io/mrdanielschwarz/pen/XWBpmKy"> <br/> CSS滚动抓拍</a>。</p>
<p/>
<p>澄清一下，这是内容的五个抓拍点。</p>
<p>以下是完整的代码:</p>
<pre class="language-html hljs">&lt;!doctype html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;style&gt;
        * {
            margin: 0;
            line-height: 1.5;
            box-sizing: border-box;
            font-family: sans-serif;
        }

        main {
            height: 100vh;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
        }

        html,
        body {
            overflow: hidden;
        }

        section {
            height: 100vh;
            display: flex;
            background: #eee;
            scroll-snap-align: start;
            scroll-snap-stop: always;
        }

        section:nth-child(odd) {
            background: #ddd;
        }

        div {
            margin: auto;
            text-align: center;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;main&gt;
        &lt;section&gt;
            &lt;div&gt;
                &lt;h1&gt;Section 1&lt;/h1&gt;
                &lt;p&gt;Lorem ipsum howdy&lt;/p&gt;
            &lt;/div&gt;
        &lt;/section&gt;
        &lt;section id="section-2"&gt;
            &lt;div&gt;
                &lt;h2&gt;Section 2&lt;/h2&gt;
                &lt;p&gt;Lorem ipsum howdy&lt;/p&gt;
            &lt;/div&gt;
        &lt;/section&gt;
        &lt;section&gt;
            &lt;div&gt;
                &lt;h2&gt;Section 3&lt;/h2&gt;
                &lt;p&gt;Lorem ipsum howdy&lt;/p&gt;
            &lt;/div&gt;
        &lt;/section&gt;
        &lt;section&gt;
            &lt;div&gt;
                &lt;h2&gt;Section 4&lt;/h2&gt;
                &lt;p&gt;Lorem ipsum howdy&lt;/p&gt;
            &lt;/div&gt;
        &lt;/section&gt;
        &lt;section&gt;
            &lt;div&gt;
                &lt;h2&gt;Section 5&lt;/h2&gt;
                &lt;p&gt;Lorem ipsum howdy&lt;/p&gt;
            &lt;/div&gt;
        &lt;/section&gt;
    &lt;/main&gt;
&lt;/body&gt;

&lt;/html&gt;
</pre>
<p>请注意，子组合符(<code>&gt;</code>)用于说明HTML元素的层次结构——要知道这根本不是编写CSS选择器的最佳方式。</p>
<p>在我们开始之前，让我解释一下每个<a href="https://blog.logrocket.com/level-up-your-css-selector-skills/"> CSS选择器</a>的作用。</p>
<p>通用选择器<a href="https://blog.logrocket.com/what-should-modern-css-boilerplate-look-like/">重置一些东西</a>。例如，边距。它与CSS滚动捕捉没有任何关系，所以我们可以忽略这些规则:</p>
<pre class="language-css hljs">* { }
</pre>
<p>这是滚动捕捉容器，它和捕捉点本身一样重要(就CSS而言):</p>
<pre class="language-css hljs">main { }
</pre>
<p>这是五个捕捉点:</p>
<pre class="language-css hljs">main &gt; section { }
</pre>
<p>此规则确保每隔一个捕捉点部分有不同的颜色，这样我们就可以很容易地观察到每个捕捉点部分的开始和结束位置。它只存在于本教程中:</p>
<pre class="language-css hljs">main &gt; section:nth-child(odd) {
    background: #ddd;
}
</pre>
<p>此规则针对每个捕捉点部分的内容。具体来说，它确保内容在节内居中。这也只是为了本教程的目的:</p>
<pre class="language-css hljs">main &gt; section &gt; div {
    margin: auto;
    text-align: center;
}
</pre>
<p>好了，现在让我们深入CSS滚动捕捉细节。</p>

<p>首先，必须为滚动捕捉容器指定一个<code>height</code>(或者为水平容器指定一个<code>width</code>)。幸运的是，这不需要是固定的高度，所以如果您不知道容器有多长(它甚至可能是响应性的)，您可以使用视口单位来代替。我使用了<code>100vh</code>，它使容器和视口一样大(垂直流动)。</p>
<p>这确实是一个奇怪的要求，但仍然是一个要求:</p>
<pre class="language-css hljs">main {
    height: 100vh;
    max-height: 100vh; /* this will also work */
}
</pre>
<p>奇怪的是，容器也需要<code>overflow-y: scroll</code>:</p>
<pre class="language-css hljs">main {
    height: 100vh;
    overflow-y: scroll;
}
</pre>
<p>如果你有两个滚动条，那么你可能还需要加入以下内容:</p>
<pre class="language-css hljs">html, body {
    overflow: hidden;
}
</pre>
<p>最后，CSS属性<code>scroll-snap-type</code>通过指定滚动捕捉的行为来激活滚动捕捉。它由两部分组成，中间用空格隔开。</p>
<p>第一部分可以是<code>x</code>、<code>y</code>或<code>both</code>——指定我们希望滚动捕捉在哪个轴上起作用。在这个例子中，我们使用了<code>y</code>——例如，垂直滚动捕捉。</p>
<p>第二部分可以是<code>mandatory</code>或者<code>proximity</code>，它决定了用户释放滚动时会发生什么。使用<code>mandatory</code>，滚动将总是吸附到最近的吸附点。使用<code>proximity</code>，只有当滚动接近捕捉目标时，滚动才会被捕捉，否则不做任何事情。</p>
<p>如果你坚持让用户只捕捉特定的区域，请使用<code>mandatory</code>,如果你认为捕捉很好，请使用<code>proximity</code>。值得注意的是，这两个选项都对用户的体验产生了负面影响(至少在一开始是这样)，因为他们不太可能期望滚动会突然停止。</p>
<p>当用户进行大胆的轻弹滚动时，滚动捕捉效果最好，这将产生很好的效果，但只有当用户事先知道滚动会以这种方式运行时。出于这个原因，滚动捕捉最适合致力于让滚动捕捉成为一种熟悉的<a href="https://blog.logrocket.com/ux-design/better-form-design-ux-tips-tools-tutorial/"> UX模式</a>或者用户定期返回的网站。</p>
<p>简而言之，这是一个有用的效果，但是如果你只是用它来增加一个登陆页面的趣味，最好避免它。滚动捕捉应被视为UX模式:</p>
<pre class="language-css hljs">main {
    height: 100vh;
    overflow-y: scroll;
    scroll-snap-type: y mandatory;
}
</pre>
<p>值得注意的是，在整个网页只是一个巨大的滚动捕捉体验的场景中，我们可以使用根(<code>&lt;html&gt;</code>)作为我们的滚动捕捉容器。在这种情况下，我们不需要设置<code>height</code>或<code>overflow-y</code>，因为<code>&lt;html&gt;</code>已经有了它们。然而，这在<code>&lt;body&gt;</code>上不起作用，原因不明。</p>
<h2 id="declaring-snap-points">声明捕捉点</h2>
<p>在快照目标上声明<code>height: 100vh;</code>可以确保它们充分利用所有可用的垂直空间。例如，将每个快照目标视为一个假想产品的单一卖点，必须完整查看才能获得最大效果(如幻灯片)。</p>
<p>但是，拥有大型快照目标会带来两个潜在问题。首先，如前所述，如果用户不执行大胆的flicky滚动，他们就有不能捕捉到下一个捕捉目标的风险，在某些情况下，会退回到上一个目标(正如你所想象的，这将是相当令人沮丧的)。记住:如果你不重用这个模式，不利用用户对它的熟悉，滚动捕捉就不值得。</p>
<p>第二个问题是，如果对齐目标使用完整的视区，并且内容大于移动设备上的视区，滚动对齐将阻止内容被访问，因此在使用滚动对齐之前，请确保它补充了内容:</p>
<pre class="language-css hljs">main &gt; section {
    height: 100vh;
}
</pre>
<p><code>scroll-snap-align</code>接受各种关键字值(<code>start</code>、<code>end</code>、<code>center</code>)，这些关键字值决定了web浏览器应该吸附到吸附目标的哪一侧。例如，在水平对齐目标上声明<code>scroll-snap-align: start;</code>将确保web浏览器靠左对齐。对于垂直捕捉目标，顶部。</p>
<p><code>scroll-snap-align</code>似乎没有缺省值，因为不提供缺省值会导致滚动捕捉失败，所以尽管您无论如何都希望<code>start</code>是缺省值，但我们仍然必须声明它:</p>
<pre class="language-css hljs">main &gt; section {
    height: 100vh;
    scroll-snap-align: start;
}
</pre>
<p><code>scroll-snap-stop: always;</code>确保用户不会意外跳过快照目标。使用它没有正确或错误的时间，它只是归结为偏好，所以它可能值得你的用户进行A/B测试。请注意，它不适用于<code>scroll-snap-type: &lt;axis&gt; proximity</code>:</p>
<pre class="language-css hljs">main &gt; section {
    height: 100vh;
    scroll-snap-align: start;
    scroll-snap-stop: always;
}
</pre>
<h2 id="styling-current-snap-target">设置当前捕捉目标的样式</h2>
<p><a href="https://caniuse.com/?search=scroll-snap-type">网页浏览器对CSS滚动捕捉的支持</a>很高。也就是说，它仍在开发中，现在即将出现的是只使用CSS来设计快照目标和/或kickstart动画的能力。更确切地说，即将推出的<code>:snapped</code> <a href="https://blog.logrocket.com/css-pseudo-elements-guide/"> CSS伪选择器</a>。</p>
<p>一旦浏览器支持<code>:snapped</code>伪选择器(以及类似的选择器，<code>:snapped-x</code>和<code>:snapped-y</code>)，你就能像这样使用它们了:</p>
<pre class="language-css hljs">section:snapped {
    /* CSS declarations */
}
</pre>
<p>就是这么简约直白！自然，样式化对齐目标的能力对于非全屏的对齐目标更有用。看看下面来自<a href="https://web.dev/state-of-css-2022/#scroll-snap-features-are-too-limited"> Chrome DevRel团队</a>的演示，它模拟了<code>:snapped</code>可能如何在这些场景中工作:<a href="https://snap-gallery.netlify.app/horizontal/target/">水平</a>，<a href="https://snap-gallery.netlify.app/vertical/target/">垂直</a>，以及<a href="https://snap-gallery.netlify.app/2d/target/">双轴</a>。</p>
<h3 id="alternative-method-javascript">使用JavaScript的替代方法</h3>
<p>当我们等待web浏览器采用<code>:snapped</code>时，有一个替代的JavaScript解决方案，涉及<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">交叉点观察器API </a>，它本质上观察视口，等待某些元素进入其中(在这种情况下，元素是捕捉目标)。当一个snap目标出现时，我们可以添加一个添加样式的类。看看下面的例子。</p>
<p>在第一个例子中，<code>Observer</code>指向一个特定的捕捉点。它等待它进入视图，然后给它添加一个类——这非常适合于对特定的捕捉点做一些独特的事情，例如触发一个独特的<a href="https://blog.logrocket.com/creating-smoother-css-transitions-animate-css-grid/"> CSS过渡/动画</a>:</p>
<pre class="language-javascript hljs">let callback = (entries, observer) =&gt; {
    entries.forEach(entry =&gt; {
        if (!entry.isIntersecting) {
            /* remove class when snap target becomes invisible */
            entry.target.classList.remove("transition");
        } else {
            /* add class when snap target becomes visible */
            entry.target.classList.add("transition");
        }
    });
};

/* only 50% of the element needs to be visible */
let options = {
    threshold: 0.5
}

let observer = new IntersectionObserver(callback, options);

/* do this to #section-2 specifically */
let section2 = document.querySelector("#section-2")

observer.observe(section2);
</pre>
<p>在第二个示例中，<code>forEach</code>用于遍历所有快照目标，为每个快照目标添加一个单独的<code>Observer</code>,但有一个对所有快照目标具有相同效果:</p>
<pre class="language-javascript hljs">let callback = (entries, obs) =&gt; {
    entries.forEach(entry =&gt; {
        if (!entry.isIntersecting) {
            entry.target.classList.remove("styles");
        } else {
            entry.target.classList.add("styles");
        }
    });
};

let options = {
    threshold: 0.5
}

let observer = new IntersectionObserver(callback, options);

/* target all section elements */
document.querySelectorAll("section").forEach(section =&gt; observer.observe(section));
</pre>
<p>最终，<a href="https://blog.logrocket.com/lazy-loading-using-the-intersection-observer-api/">交叉点观察器API </a>完成了和<code>:snapped</code>最终要做的一样的事情，但是它需要JavaScript和更多的代码。它还会导致web性能的轻微下降。</p>
<p>然而，交叉点观察器API的好处是，我们可以用它来做比添加和删除CSS更多的事情(例如，我们可以用它来播放和重启视频)。此外，<code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#intersection_observer_options">threshold</a></code>选项决定了在调用<code>callback</code>之前，捕捉目标需要在视口中的位置，这为我们提供了对类何时被切换的更细粒度的控制。</p>
<p>同样值得关注的是<code>snapChanging()</code>和<code>snapChanged()</code>，这两个<a href="https://blog.logrocket.com/custom-events-in-javascript-a-complete-guide/"> JavaScript事件</a>最终应该会得到web浏览器的支持。虽然我看不出他们会带来什么交集观察者API没有的东西。</p>
<p>以下是它们的使用方法，以供参考:</p>
<pre class="language-javascript hljs">document.querySelector("#section-2").addEventListener("snapchanging", event =&gt; {
  /* do something */
});
document.querySelector("#section-2").addEventListener("snapchanged", event =&gt; {
  /* do something */
});
</pre>
<p>你怎么想呢?有用，还是没用？如果你有任何想法，请在下面的评论区留言。</p>
<h2>结束语</h2>
<p>如果使用得当，滚动捕捉会很有趣。尽管如此，并没有太多的场景可以增强UX。在适当的情况下，一旦用户熟悉了滚动捕捉在网站上作为UX模式的用法，他们会感觉非常直观。</p>
<p>希望你能更舒服地享受滚动捕捉，因为只使用CSS就能非常容易地实现。与此同时，重要的是要谨慎使用它，如果它看起来不仅仅是一种虚荣心。</p>
<p>我建议<a href="https://drafts.csswg.org/css-scroll-snap-2/">关注<code>:snapped</code> CSS伪选择器</a>，因为一旦网络浏览器支持它，它将减少所需的JavaScript数量。</p>
<p>一如既往地感谢您的阅读！</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的CPU？</h2><p>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
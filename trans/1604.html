<html>
<head>
<title>React app testing: Jest and React Testing Library - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React 应用测试:Jest 和 React 测试库</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/testing-react-apps-jest-react-testing-library/#0001-01-01">https://blog.logrocket.com/testing-react-apps-jest-react-testing-library/#0001-01-01</a></blockquote><div><article class="article-post">
<p><em> <strong>编者按:</strong>这篇文章更新于 2022 年 3 月 16 日，删除了任何过时的内容，并增加了关于<code>React Testing Library</code> vs. Jest </em>的信息</p>
<p>测试是软件工程中必不可少的实践，它有助于构建健壮和高质量的软件，增强团队对代码的信心，使应用程序更加灵活，在引入或修改功能时更容易出错。</p>
<p>高效的团队将测试作为他们日常工作中的核心实践，在自动化测试到位之前，任何特性都不会发布。一些开发人员甚至在编写特性之前编写测试，遵循一个称为测试驱动开发(TDD)的过程。</p>
<p>在本文中，我们将使用 Jest 和<code>React Testing Library</code>测试 React 应用程序，Jest 和<code>React Testing Library</code>是 JavaScript 测试框架和用于测试组件的 React 实用程序的流行组合。这也是在<a href="https://reactjs.org/docs/testing.html#tools" target="_blank" rel="noopener"> React 的文档</a>中给出的官方推荐。</p>
<p>我们将讨论以下主题:</p>

<h2 id="what-is-testing">什么是测试？</h2>
<p>测试是在代码产生的结果和我们期望的结果之间自动断言的过程。</p>
<p>当测试 React 应用程序时，我们的断言是由应用程序如何呈现和响应用户交互来定义的。</p>
<p>有许多不同类型的测试范例和哲学。本文将关注于创建单元和组件测试(或者集成测试)。</p>
<h2 id="introduction-to-jest-and-react-testing-library">Jest 和<code>React Testing Library</code>介绍</h2>
<h3 id="what-is-jest">什么是玩笑？</h3>
<p>Jest 是一个 JavaScript 测试框架,允许开发人员对 JavaScript 和 TypeScript 代码进行测试，并与 React 很好地集成。</p>
<p>这是一个考虑到简单性而设计的框架，提供了一个强大而优雅的 API 来构建隔离测试、快照比较、模拟、测试覆盖等等。</p>
<h3 id="what-is-react-testing-library"><code>React Testing Library</code></h3>
<p><code>React Testing Library</code>是一个专门为测试 React 组件而构建的 JavaScript 测试工具。它模拟独立组件上的用户交互，并断言它们的输出，以确保 UI 行为正确。</p>
<h2 id="react-testing-library-vs-jest"><code>React Testing Library</code>等。他来了</h2>
<p>不是笑话的替代品。每一个都执行一个明确的任务，你需要它们来测试你的组件。</p>
<p>Jest 是一个测试运行程序，它查找测试，运行测试，并确定测试是通过还是失败。此外，Jest 为测试套件、测试用例以及断言提供了功能。<br/> <code>React Testing Library</code>为测试 React 组件提供虚拟 DOM。</p>
<p>每当我们在没有 web 浏览器的情况下运行测试时，我们都必须有一个虚拟 DOM 来呈现应用程序，与元素进行交互，并观察虚拟 DOM 的行为是否像它应该的那样(比如在单击按钮时改变 div 的宽度)。</p>
<p><code>React Testing Library</code>不特定于任何测试框架；我们可以将它与任何其他测试库一起使用，尽管 Jest 是许多开发人员推荐和首选的。</p>
<p><code>create-react-app</code>默认使用 Jest 和<code>React Testing Library</code>。此外，<a href="https://blog.logrocket.com/everything-you-need-to-know-about-react-scripts/" target="_blank" rel="noopener"> <code>[react-scripts]</code>会自动设置我们的服务器来监视变化</a>，所以如果测试文件被修改，服务器会自动编译并运行测试，而不需要重启服务器。</p>
<p>为了了解这些库是如何协同工作的，让我们来看看<code>create-react-app</code>的自动生成的测试文件:</p>
<pre class="language-javascript hljs">import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () =&gt; {
  render(&lt;App /&gt;);
  const linkElement = screen.getByText(/learn react/i)
  expect(linkElement).toBeInTheDocument();
});
</pre>
<p>这里，测试用例由 Jest 提供。为了渲染和访问虚拟 DOM，我们从<code>React Testing Library</code>导入并使用了<code>render</code>和<code>screen</code>。</p>
<p>如果你从头开始设置 React 应用，那么你必须自己安装和设置 Jest 和<code>React Testing Library</code>。</p>
<h2 id="setting-up-your-react-testing-environment">设置您的测试环境</h2>
<p>让我们从安装所需的库和设置项目开始。启动和运行 React 应用程序最简单的方法是使用<code>create-react-app</code>。</p>
<p>我建议您按照教程中的步骤运行命令并自己编写代码。但是，如果您更喜欢遵循最终项目结果的代码，您可以从 GitHub 中克隆<a href="https://github.com/bajcmartinez/react-jest-tutorial" target="_blank" rel="noopener">教程项目。</a></p>
<p>首先，创建一个 React 应用程序:</p>
<pre class="language-bash hljs">npx create-react-app react-jest-tutorial
</pre>
<p>现在，安装<code>React Testing Library</code>:</p>
<pre class="language-bash hljs">npm install --save-dev @testing-library/react
</pre>
<p>最后，安装附加库:</p>
<pre class="language-bash hljs">npm install axios
</pre>
<h2 id="building-a-react-application-for-testing">构建用于测试的 React 应用程序</h2>
<p>接下来，让我们构建一个从 API 显示用户的最小应用程序。因为我们只关注前端，所以让我们使用<a href="https://jsonplaceholder.typicode.com/" target="_blank" rel="noopener"> JSONPlaceholder 用户 API </a>。这个应用程序专为构建测试而构建。</p>
<p>用以下内容替换<code>App.js</code>文件的内容:</p>
<pre class="language-javascript hljs">import { useEffect, useState } from 'react';
import axios from 'axios';
import { formatUserName } from './utils';
import './App.css';

function App() {
 const [users, setUsers] = useState([]);

 // Load the data from the server
 useEffect(() =&gt; {
   let mounted = true;

   const getUsers = async () =&gt; {
     const response = await axios.get('https://jsonplaceholder.typicode.com/users');
     if (mounted) {
       setUsers(response.data);
     }
</pre>
<p>接下来，在<code>src</code>文件夹中创建一个名为<code>utils.js</code>的文件，并编写以下函数:</p>
<pre class="language-javascript hljs">export function formatUserName(username) {
 return '@' + username;
}
</pre>
<p>现在，您可以使用以下命令运行应用程序:</p>
<pre class="language-bash hljs">npm start
</pre>
<p>之后，您应该会看到这个屏幕。</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/526e1ed7a497e5ebf4f69463db40aa91.png" alt="API Basic application listing the users from the API with their corresponding usernames." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/users-from-api.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/users-from-api.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/526e1ed7a497e5ebf4f69463db40aa91.png" alt="API Basic application listing the users from the API with their corresponding usernames." data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/users-from-api.png"/></noscript><figcaption class="wp-caption-text">API Basic application listing the users from the API with their corresponding usernames.</figcaption></figure>
<h2 id="building-a-unit-test">构建单元测试</h2>
<p>单元测试孤立地测试单个软件单元或组件。一个单元可以是一个函数、例程、方法、模块或对象，测试目标决定了该单元是否输出给定输入的预期结果。</p>
<p>一个测试模块由 Jest 提供的一系列描述测试结构的方法组成。我们可以如下使用类似<code>describe</code>或<code>test</code>的方法:</p>
<pre class="language-javascript hljs">describe('my function or component', () =&gt; {
 test('does the following', () =&gt; {
   // Magic happens here
 });
});
</pre>
<p><code>describe</code>块是测试套件，<code>test</code>块(或者简称为<code>test</code>)是测试用例。一个测试套件可以有多个测试用例，一个测试用例不一定要在一个测试套件中，尽管这样做是常见的做法。</p>
<p>在测试用例中，我们可以编写断言(例如，Jest 中的<code>expect</code>)来验证成功(绿色)或错误(红色)。每个测试用例可以有多个断言。</p>
<p>下面是一个成功的断言的小例子:</p>
<pre class="language-javascript hljs">describe('true is truthy and false is falsy', () =&gt; {
 test('true is truthy', () =&gt; {
   expect(true).toBe(true);
 });

 test('false is falsy', () =&gt; {
   expect(false).toBe(false);
 });
});
</pre>
<p>接下来，让我们针对来自<code>utils</code>模块的函数<code>formatUserName</code>编写第一个测试用例。<br/>为此，我们必须先创建一个新文件:<code>utils.test.js</code>。注意，所有的测试文件都使用模式<code>{file}.test.js</code>，其中<code>{file}</code>是要测试的模块文件的名称。</p>
<p>我们正在讨论的函数将一个字符串作为输入，并输出相同的字符串，在其开头添加一个<code>@</code>。我们的测试函数可以断言，给定一个字符串，例如，<code>"jc"</code>，函数将输出<code>"@jc"</code>。</p>
<p>以下是测试文件的代码:</p>
<pre class="language-javascript hljs">import { formatUserName } from "./utils";

describe('utils', () =&gt; {
 test('formatUserName adds @ at the beginning of the username', () =&gt; {
   expect(formatUserName('jc')).toBe('@jc');
 });
});
</pre>
<p>我们有效地描述了模块是什么，测试用例是什么，这样如果它们失败了，我们就能清楚地知道哪里出错了。<br/>现在我们的第一个测试已经准备好了，我们可以运行它，看看会有什么输出。<code>create-react-app</code>通过使用简单的 npm 命令，我们可以轻松运行所有测试:</p>
<pre class="language-bash hljs">npm run test
</pre>
<p>现在，让我们使用下面的代码集中运行一个测试:</p>
<pre class="language-bash hljs">npm run test -- -t 'utils'
</pre>
<p>我们这样做是因为我们有其他已经由<code>create-react-app</code>创建的测试，我们现在需要忽略它们。</p>
<p>如果一切顺利，您应该会看到类似如下的输出:</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/e2def9ca5f8ecc27da67d4943e7aebe9.png" alt="Successful output." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/successful-output.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/successful-output.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/e2def9ca5f8ecc27da67d4943e7aebe9.png" alt="Successful output." data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/successful-output.png"/></noscript><figcaption class="wp-caption-text">Successful output.</figcaption></figure>
<p>请注意，有一个测试被跳过了(我们希望这样)，有一个测试成功通过了。但是，如果出了问题会发生什么呢？让我们向<code>utils</code>测试套件添加一个新的测试来找出答案:</p>
<pre class="language-javascript hljs">test('formatUserName does not add @ when it is already provided', () =&gt; {
   expect(formatUserName('@jc')).toBe('@jc');
 });
</pre>
<p>现在情况不同了；如果用户名在字符串的开头已经包含了一个<code>@</code>符号，我们希望函数返回所提供的用户名，而不添加第二个符号。</p>
<p>让我们运行它:</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/f4bc031892c8a63455dcefa3be008bb8.png" alt="Failed test output." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/failed-test-output.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/failed-test-output.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/f4bc031892c8a63455dcefa3be008bb8.png" alt="Failed test output." data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/failed-test-output.png"/></noscript><figcaption class="wp-caption-text">Failed test output.</figcaption></figure>
<p>正如预测的那样，测试失败了，我们收到了关于哪个<code>expect</code>调用失败、期望值和实际结果的具体信息。因为我们发现了原始函数的一个问题，所以我们可以修复它:</p>
<pre class="language-javascript hljs">export function formatUserName(username) {
 return username.startsWith('@') ? username : '@' + username;
}
</pre>
<p>现在，让我们再次运行我们的测试:</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/cd25da18b6aa4c2f9aed769d31583d8a.png" alt="Successful test." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/successful-test.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/successful-test.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/cd25da18b6aa4c2f9aed769d31583d8a.png" alt="Successful test." data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/successful-test.png"/></noscript><figcaption class="wp-caption-text">Successful test.</figcaption></figure>
<p>到目前为止，我们已经取得了很大的进步。我们为我们的应用程序编写了两个测试用例，由于编写了这些测试用例，我们发现了一个 bug，并在发布之前修复了它。</p>
<h2 id="testing-components-with-jest">用 Jest 测试组件</h2>
<p>测试组件和测试功能没有太大的不同。想法和概念是相同的，但是区别在于我们如何编写断言。</p>
<p>我们将通过构建几个测试用例来测试我们的<code>App</code>组件，在每个测试用例中，我们将引入不同的东西来验证 React 组件。</p>
<p>我们的第一个测试将是基本的，它将只验证组件渲染。</p>
<p>跳转到文件<code>App.test.js</code>(由<code>create-react-app</code>自动生成)并用以下内容替换其内容:</p>
<pre class="language-javascript hljs">import { render } from '@testing-library/react';
import App from './App';

describe('App component', () =&gt; {
 test('it renders', () =&gt; {
   render(&lt;App /&gt;);
 });
})
</pre>
<p>与之前类似，我们有一个<code>describe</code>块和一个<code>test</code>块，但是这一次，我们使用<code>render</code>函数挂载来单独渲染一个组件。只有当编译错误或函数组件中的错误阻碍了它的呈现时，这个测试才会失败。</p>
<p>虽然有效，但它不是一个完整的测试，因为它不执行任何断言。为了解决这个问题，我们可以匹配组件中的内容，看看它们是否存在，例如:</p>
<pre class="language-javascript hljs">import { render, screen } from '@testing-library/react';
import App from './App';

describe('App component', () =&gt; {
 test('it renders', () =&gt; {
   render(&lt;App /&gt;);


   expect(screen.getByText('Users:')).toBeInTheDocument();
 });
})
</pre>
<p>我们的新测试更好；它验证组件可以呈现，但是它也搜索 DOM 中存在的带有文本<code>"Users:"</code>的元素，在我们的例子中就是这样，因此测试成功通过。</p>
<p><a href="https://testing-library.com/docs/queries/about/#screen" target="_blank" rel="noopener">对象<code>[screen]</code>在<code>React Testing Library</code> </a>中是必不可少的，因为它提供了助手方法来与组件及其元素进行交互。</p>
<h3 id="&quot;waiting-for-asynchronous-operations">等待异步操作</h3>
<p>接下来，我们希望验证在 API 完成后用户列表是否显示了条目。为此，我们可以编写如下测试用例:</p>
<pre class="language-javascript hljs">import { render, screen, waitFor } from '@testing-library/react';
import App from './App';

describe('App component', () =&gt; {
 test('it displays a list of users', async () =&gt; {
   render(&lt;App /&gt;);


   expect(screen.getByTestId('user-list')).toBeInTheDocument();
 });
});
</pre>
<p>但是，当我们运行测试时，它会失败并显示以下消息:</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/f92a273470ca1ccbbb0c3463e7d988b3.png" alt="Failed test in Jest." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/failed-test-in-jest.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/failed-test-in-jest.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/f92a273470ca1ccbbb0c3463e7d988b3.png" alt="Failed test in Jest." data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/failed-test-in-jest.png"/></noscript><figcaption class="wp-caption-text">Failed test in Jest.</figcaption></figure>
<p>失败的原因很简单:当我们评估屏幕时，异步操作(<code>fetch</code>)仍然处于挂起状态，所以显示的是<code>"Loading users…"</code>消息，而不是用户列表。<br/>解决办法是等待:</p>
<pre class="language-javascript hljs">import { render, screen, waitFor } from '@testing-library/react';
import App from './App';

describe('App component', () =&gt; {
 test('it displays a list of users', async () =&gt; {
   render(&lt;App /&gt;);


   const userList = await waitFor(() =&gt; screen.getByTestId('user-list'));
   expect(userList).toBeInTheDocument();
 });
});
</pre>
<p>现在，测试成功通过。</p>
<h2 id="mocking-with-react-and-jest">用反应和玩笑嘲弄</h2>
<p>我们的下一步是验证组件将如何对从 API 收集的数据做出反应。但是，如果我们不确定 API 的响应是什么，我们如何测试数据呢？这个问题的解决方法是嘲讽。</p>
<p>模仿的目的是将测试的代码与外部依赖(如 API 调用)隔离开来。这是通过用模拟依赖关系的受控对象替换依赖关系来实现的。</p>
<p>嘲讽是一个三步走的过程。首先，我们必须导入依赖项:</p>
<pre class="language-javascript hljs">import axios from 'axios';
</pre>
<p>然后，嘲笑依赖性:</p>
<pre class="language-javascript hljs">jest.mock('axios');
</pre>
<p>最后，伪造函数输出:</p>
<pre class="language-javascript hljs">axios.get.mockResolvedValue({ data: fakeUsers });
</pre>
<p>让我们看看他们现在的表现:</p>
<pre class="language-javascript hljs">import axios from 'axios';
import { render, screen, waitFor } from '@testing-library/react';
import App from './App';

jest.mock('axios');

const fakeUsers = [{
  "id": 1,
  "name": "Test User 1",
  "username": "testuser1",
 }, {
  "id": 2,
  "name": "Test User 2",
  "username": "testuser2",
 }];

describe('App component', () =&gt; {

 test('it displays a row for each user', async () =&gt; {
   axios.get.mockResolvedValue({ data: fakeUsers });
   render(&lt;App /&gt;);


   const userList = await waitFor(() =&gt; screen.findAllByTestId('user-item'));
   expect(userList).toHaveLength(2);
 });
});
</pre>
<p>最后一点注意:因为我们模仿了<code>axios</code>，每个使用该库的测试用例将返回<code>undefined</code>，除非一个模仿的值通过。因此，概括一下我们的完整组件测试，我们有以下内容:</p>
<pre class="language-javascript hljs">import axios from 'axios';
import { render, screen, waitFor } from '@testing-library/react';
import App from './App';

jest.mock('axios');

const fakeUsers = [{
  "id": 1,
  "name": "Test User 1",
  "username": "testuser1",
 }, {
  "id": 2,
  "name": "Test User 2",
  "username": "testuser2",
 }];

describe('App component', () =&gt; {
 test('it renders', async () =&gt; {
   axios.get.mockResolvedValue({ data: fakeUsers });
   render(&lt;App /&gt;);


   expect(screen.getByText('Users:')).toBeInTheDocument();
 });

 test('it displays a list of users', async () =&gt; {
   axios.get.mockResolvedValue({ data: fakeUsers });


   render(&lt;App /&gt;);


   const userList = await waitFor(() =&gt; screen.getByTestId('user-list'));
   expect(userList).toBeInTheDocument();
 });

 test('it displays a row for each user', async () =&gt; {
   axios.get.mockResolvedValue({ data: fakeUsers });
   render(&lt;App /&gt;);


   const userList = await waitFor(() =&gt; screen.findAllByTestId('user-item'));
   expect(userList).toHaveLength(2);
 });
});
</pre>
<p>让我们运行所有测试，看看结果:</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/54a45622f88a13d927c6565f85d0a31f.png" alt="Successful test results." data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/03/successful-test-results.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/successful-test-results.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/54a45622f88a13d927c6565f85d0a31f.png" alt="Successful test results." data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/03/successful-test-results.png"/></noscript><figcaption class="wp-caption-text">Successful test results.</figcaption></figure>
<h2 id="snapshot-testing">快照测试</h2>
<p>当您想要确保您的 UI 不会意外更改时，快照测试非常有用。</p>
<p>一个典型的快照测试用例呈现一个 UI 组件，获取一个快照，然后将其与一个存储的参考快照文件进行比较。如果两个快照匹配，测试将通过。如果两个快照不匹配，这可能是由于意外的更改，或者是由于引用快照需要更新到 UI 组件的新版本。</p>
<p>要编写快照测试，需要使用<a href="https://www.npmjs.com/package/react-test-renderer" target="_blank" rel="noopener"> react-test-renderer </a>库，因为它是一个能够将 react 组件呈现为纯 JavaScript 对象的库。您可以使用以下命令安装该库:</p>
<pre class="language-bash hljs">npm i <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1d6f787c7e693069786e69306f787379786f786f5d2c2a332d332c">[email protected]</a>
</pre>
<p>现在，让我们编辑<code>App.js</code>文件来包含一个快照测试。</p>
<pre class="language-javascript hljs">import renderer from "react-test-renderer";

// ...

test("it renders a correct snapshot", async () =&gt; {
  axios.get.mockResolvedValue({ data: fakeUsers });
  const tree = renderer.create(&lt;App /&gt;).toJSON();
  expect(tree).toMatchSnapshot();
});

// ...
</pre>
<p>现在，如果我们运行测试，我们应该看到更新的通过测试的结果，并注明:“它呈现了一个正确的快照”。</p>
<p><img data-attachment-id="125530" data-permalink="https://blog.logrocket.com/testing-react-apps-jest-react-testing-library/attachment/snapshot-test-passed/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed.png" data-orig-size="720,133" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Snapshot test passed" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed-300x55.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed.png" decoding="async" class="aligncenter wp-image-125530 size-full jetpack-lazy-image" src="../Images/1cb8a00b80a47226396c404f2a6fdbc5.png" alt="Snapshot Test Passed" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed-300x55.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="125530" data-permalink="https://blog.logrocket.com/testing-react-apps-jest-react-testing-library/attachment/snapshot-test-passed/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed.png" data-orig-size="720,133" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Snapshot test passed" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed-300x55.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed.png" decoding="async" loading="lazy" class="aligncenter wp-image-125530 size-full" src="../Images/1cb8a00b80a47226396c404f2a6fdbc5.png" alt="Snapshot Test Passed" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed-300x55.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-passed.png"/></noscript>
<p>第一次运行这个测试时，Jest 会在<code>__snapshots__</code>文件夹中创建一个快照文件。以下是该文件的外观:</p>
<pre class="language-javascript hljs">// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`App component it renders correctly 1`] = `
&lt;div
  className="App"
&gt;
  &lt;div&gt;
    Users:
  &lt;/div&gt;
  &lt;div&gt;
    Loading users...
  &lt;/div&gt;
&lt;/div&gt;
`;
</pre>
<p>现在，如果我们继续通过更改一个简单的文本值来修改 App 组件，我们可以预期<code>it renders a correct snapshot</code>测试会失败，因为组件的输出已经更改。</p>
<p><img data-attachment-id="125532" data-permalink="https://blog.logrocket.com/testing-react-apps-jest-react-testing-library/attachment/snapshot-test-failed/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed.png" data-orig-size="720,272" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sanpshot test failed" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed-300x113.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed.png" decoding="async" class="aligncenter wp-image-125532 size-full jetpack-lazy-image" src="../Images/0c8d9f19d204a112fd6fb0d2b578e61d.png" alt="Snapshot Test Failed" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed-300x113.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="125532" data-permalink="https://blog.logrocket.com/testing-react-apps-jest-react-testing-library/attachment/snapshot-test-failed/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed.png" data-orig-size="720,272" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Sanpshot test failed" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed-300x113.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed.png" decoding="async" loading="lazy" class="aligncenter wp-image-125532 size-full" src="../Images/0c8d9f19d204a112fd6fb0d2b578e61d.png" alt="Snapshot Test Failed" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed-300x113.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-failed.png"/></noscript>
<p>我们需要通过这个测试，并通知 Jest 对测试组件的有意更改。当 Jest 处于观察模式时，我们可以很容易地做到这一点，首先在命令行中按下<strong> w </strong>来显示更多内容，然后按下<strong> u </strong>来更新快照。</p>
<p><img data-attachment-id="125534" data-permalink="https://blog.logrocket.com/testing-react-apps-jest-react-testing-library/attachment/snapshot-test-watch-usage/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage.png" data-orig-size="720,194" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Snapshot test watch usage" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage-300x81.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage.png" decoding="async" class="aligncenter wp-image-125534 size-full jetpack-lazy-image" src="../Images/f3ab7116b0a02865c3a0e5c5076f2ddb.png" alt="Snapshot Test Watch Usage" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage-300x81.png 300w" data-lazy-sizes="(max-width: 720px) 100vw, 720px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="125534" data-permalink="https://blog.logrocket.com/testing-react-apps-jest-react-testing-library/attachment/snapshot-test-watch-usage/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage.png" data-orig-size="720,194" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Snapshot test watch usage" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage-300x81.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage.png" decoding="async" loading="lazy" class="aligncenter wp-image-125534 size-full" src="../Images/f3ab7116b0a02865c3a0e5c5076f2ddb.png" alt="Snapshot Test Watch Usage" srcset="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage.png 720w, https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage-300x81.png 300w" sizes="(max-width: 720px) 100vw, 720px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/snapshot-test-watch-usage.png"/></noscript>
<h2 id="which-testing-library-is-best-for-react">哪个测试库最适合 React？</h2>
<p>当谈到测试库或框架时，有各种选项和组合可以考虑。下面来看看一些最流行的测试框架及其优缺点。</p>
<h3 id="jest">玩笑</h3>
<p>React 社区推荐 Jest 作为 React 测试框架的选择。Jest 是许多知名公司使用的<a href="https://jestjs.io/docs/tutorial-react" target="_blank" rel="noopener">，比如脸书、优步和 Airbnb。Jest 也恰好是许多现成 JavaScript 框架的默认设置，包括<code>create-react-app</code>。</a></p>
<p>下面是使用 Jest 测试 React 应用程序的一些好处:</p>
<ul>
<li>易于设置和配置，性能也很好</li>
<li>借助 Jest 快照捕获特性，轻松跟踪大型测试用例</li>
<li>可以进行并行化和异步方法测试</li>
<li>提供模拟 API 函数和第三方库的能力</li>
</ul>
<h3 id="enzyme">酶</h3>
<p>Enzyme 允许您操纵、遍历和在某种程度上模拟给定输出的运行时。它帮助您渲染组件、查找元素以及与元素进行交互。</p>
<p>这个库是专门为 React 设计的，它提供了两种测试方法:<a href="https://enzymejs.github.io/enzyme/docs/api/shallow.html" target="_blank" rel="noopener">浅层渲染</a>，这有助于将组件作为一个没有子组件的单元进行测试，以及挂载测试。如果您的组件具有非常高的嵌套子组件和孙组件粒度，这将意味着每个子组件都需要有自己的特定测试来覆盖所有逻辑。</p>
<p>酵素通常与 Jest 连用。</p>
<p>以下是使用 Enzyme 测试 React 应用程序的一些好处:</p>
<ul>
<li>支持浅层渲染</li>
<li>支持 DOM 渲染的特性</li>
<li>支持在浅层渲染中使用反应钩子</li>
<li>可以根据测试输出模拟运行时</li>
</ul>
<h3 id="react-testing-library"><code>React Testing Library</code></h3>
<p>是一个轻量级的库，提供了一整套测试 React DOM 的工具。当与 Jest 测试库一起使用时，<code>React Testing Library</code>允许开发者轻松地测试组件来模拟用户的行为。<code>React Testing Library</code>自带内置的 React DOM 测试工具，可以模拟 React 应用程序上的实际用户操作。但是，它不支持浅层呈现和访问组件的状态。</p>
<p><code>React Testing Library</code>提供以下优势:</p>
<ul>
<li>支持用户行为测试</li>
<li>自带内置的 DOM 测试工具</li>
<li>更容易模拟用户工作流和操作</li>
<li>兼容 Angular 和 Vue 等其他 UI 框架</li>
</ul>
<h3 id="jasmine">茉莉</h3>
<p><a href="https://github.com/jasmine/jasmine" target="_blank" rel="noopener"> Jasmine </a>是一个简单的针对浏览器和 Node.js 的 JavaScript 测试框架，Jasmine 遵循行为驱动的开发模式，所以一般在使用前配置到位。</p>
<p>为了在测试 React 应用中使用 Jasmine，开发者可以添加其他第三方框架，比如 Enzyme。</p>
<p>茉莉的一些好处包括:</p>
<ul>
<li>不需要 DOM 来测试</li>
<li>可用于前端和后端测试</li>
<li>可用于异步功能测试</li>
<li>具有自定义的等式检查器断言</li>
<li>带有内置的匹配器断言</li>
</ul>
<p>尽管有很多好处，Jasmine 并不是 React 应用程序的完美测试框架。它不支持快照测试，并且需要第三方库进行并行化和本地 DOM 操作。</p>
<h3 id="mocha">摩卡</h3>
<p><a href="https://blog.logrocket.com/a-quick-and-complete-guide-to-mocha-testing-d0e0ea09f09d/" target="_blank" rel="noopener"> Mocha 是一个运行在 Node.js 上的 JavaScript 框架</a>，用于测试 React 应用。它拥有浏览器支持、异步测试和断言库的使用。</p>
<p>Mocha 非常灵活，但是总是需要导入其他库才能编写测试。与 Jest 类似，Mocha 可以与其他库结合，如 Enzyme，用于断言、嘲讽等。</p>
<p>以下是使用 Mocha 测试 React 应用程序的一些最佳好处:</p>
<ul>
<li>具有简单的异步测试功能</li>
<li>当测试文件中需要时，支持生成器轻松测试套件</li>
<li>为各种断言和模拟库提供高度可扩展的支持</li>
</ul>
<h2 id="conclusion">结论</h2>
<p>测试您的 React 应用程序是开发高质量应用程序的关键，感谢 React、Jest 和<code>React Testing Library</code>，测试我们的组件和应用程序比以往任何时候都更容易。<br/>所有应用和测试的代码都可以在<a href="https://github.com/yomete/react-jest-tutorial" target="_blank" rel="noopener"> GitHub </a>获得。感谢阅读！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Build a Tic-Tac-Toe game with React Hooks - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用 React Hooks 构建井字游戏</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-tic-tac-toe-game-react-hooks/#0001-01-01">https://blog.logrocket.com/build-tic-tac-toe-game-react-hooks/#0001-01-01</a></blockquote><div><article class="article-post">
<p>井字游戏是世界上最古老、最受欢迎的棋类游戏之一。我们可以用木板、鹅卵石、棍子等和朋友玩井字游戏。但是我们也可以在网络浏览器上和我们的朋友玩游戏。在本教程中，我们将使用 React Hooks 从头开始构建一个井字游戏，学习如何编写计算机程序来与我们对战。</p>
<p>你可以在 GitHub 库看到<a href="https://github.com/nextjs-prj/tictactoe"> <code>TicTacToe</code>游戏的完整代码。我们开始吧！</a></p>
<h3>目录</h3>

<h2 id="the-logic-tic-tac-toe">井字游戏的逻辑</h2>
<p>井字游戏是在 3×3 的格子上玩的。先出手的玩家是<code>X</code>。第二个出场的选手是<code>O</code>。第一个在行、列或对角线上占据三个空间的玩家获胜。没有规则规定谁先开始，然而，决定谁先开始的一个流行惯例是掷骰子或掷硬币。</p>
<p>井字游戏很容易导致平局，在这种情况下，玩家必须重新开始游戏。在接下来的章节中，我们将学习如何在浏览器中实现井字游戏逻辑。</p>
<h2 id="installation">装置</h2>
<p>我们需要在机器上安装最新版本的 Node.js、Yarn 或 npm。请记住，npm 是与 Node.js 捆绑在一起的，但是如果您使用的是 Yarn，您可以通过运行以下命令来安装最新版本:</p>
<pre>npm i -g yarn
</pre>
<p>我们可以从<a href="https://nodejs.org/download">https://nodejs.org/download</a>下载最新版本的 Next.js。</p>
<h2 id="scaffold-project">资助这个项目</h2>
<p>我们将使用 Yarn 来搭建我们的 Next.js 项目。从计算机上的任何文件夹运行以下命令:</p>
<pre>yarn create next-app tictactoe
cd tictactoe
</pre>
<p>在<code>pages</code>文件夹中，我们将创建一个名为<code>components</code>的文件夹，它将存放我们的游戏。我们将在这个文件夹中创建一个<code>TicTacToe</code>组件，如下所示:</p>
<pre>mkdir components

mkdir components/TicTacToe

touch components/TicTacToe/index.js components/TicTacToe/TicTacToe.module.css
</pre>
<p><code>components/TicTacToe/index.js</code>包含游戏及其逻辑，而<code>components/TicTacToe/TicTacToe.module.css:</code>包含游戏造型。</p>
<h2 id="build-tic-tac-toe-game">构建井字游戏</h2>
<p>进入<code>styles/Home.module.css</code>文件并粘贴以下代码:</p>
<pre>.container {
  padding: 0 2rem;
}

.main {
  min-height: 100vh;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
</pre>
<p>接下来，我们将进入<code>pages/index.js</code>并粘贴以下代码:</p>
<pre>import Head from "next/head";
import styles from "../styles/Home.module.css";
import TicTacToe from "../components/TicTacToe";

export default function Home() {
  return (
    &lt;div className={styles.container}&gt;
      &lt;Head&gt;
        &lt;title&gt;Tic Tac Toe game&lt;/title&gt;
        &lt;meta name="description" content="Generated by create next app" /&gt;
        &lt;link rel="icon" href="/favicon.ico" /&gt;
        &lt;style&gt;
          @import url('https://fonts.googleapis.com/css2?family=Indie+Flower');
        &lt;/style&gt;
      &lt;/Head&gt;

      &lt;main className={styles.main}&gt;
        &lt;TicTacToe /&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>组件将加载到我们项目的每条路线上。注意，我们导入了我们的<code>TicTacToe</code>组件和样式表<code>Home.module.css</code>。</p>
<p>在<code>Home</code>组件内部，我们设置了一个<code>Head</code>。在这个<code>Head</code>里面，我们有<code>title</code>和<code>meta</code>标签。我们还有一个<code>style</code>标签来加载字体。我们加载<code>Indie Flower</code>字体来显示棋盘上的<code>X</code>和<code>O</code>。最后，在<code>main</code>标签中，我们呈现了<code>TicTacToe</code>组件。</p>
<h2 id="the-tictactoe-component"><code>TicTacToe</code>组件</h2>
<p>让我们转到<code>TicTacToe</code>组件。我们的棋盘将是一个 3×3 单元的正方形，玩家将在单元内竞争。为了定义我们的纸板，我们将使用一个多维数组:</p>
<pre>[
  ["", "", ""],
  ["", "", ""],
  ["", "", ""],
];
</pre>
<p>第一个维度是行，第二个维度是列。从<code>0</code>到<code>2</code>对行和列进行编号。第一排是<code>0</code>，第二排是<code>1</code>，第三排是<code>2</code>。第一列是<code>0</code>，第二列是<code>1</code>，第三列是<code>2</code>。</p>
<p>第一行是顶行，第二行是中间行，第三行是底行。第一列是左列，第二列是中间列，第三列是右列。</p>
<p>我们将从这个数组中在 DOM 上绘制棋盘。第一个单元格位于第一行第一列，第二个单元格位于第一行第二列，第三个单元格位于第一行第三列。它遵循这种模式，直到最后一个单元格。</p>
<p>首先，我们从<code>TicTacToe.module.css</code>文件导入 React 库和样式:</p>
<pre>// TickTacToe/index.js
import styles from "./TicTacToe.module.css";
import { useEffect, useState } from "react";
</pre>
<p>接下来，我们将创建一个对象来保存游戏中每个玩家的名字和符号。在本教程中，我们将对抗计算机:</p>
<pre>// TickTacToe/index.js
// previous code here

const players = {
  CPU: {
    SYM: "O",
    NAME: "CPU",
  },
  HUMAN: {
    SYM: "X",
    NAME: "You",
  },
};
</pre>
<p>对象保存玩家的名字和符号。<code>CPU</code>是电脑的名字，<code>O</code>是电脑的符号。<code>You</code>是人类的名字，<code>X</code>是人类的象征。</p>
<p>接下来，我们将创建一个函数<code>sleep</code>，我们将使用它来模拟计算机思维:</p>
<pre>// TickTacToe/index.js
// previous code here

function sleep(milliseconds) {
  const date = Date.now();
  let currentDate = null;
  do {
    currentDate = Date.now();
  } while (currentDate - date &lt; milliseconds);
}
</pre>
<p>上面的代码将在释放 CPU 之前等待指定的毫秒数。<br/>现在，我们创建<code>TicTacToe</code>组件:</p>
<pre>// TickTacToe/TicTacToe.js
//  previous code here

export default function TicTacToe() {}
</pre>
<p>为了抓住板子，我们创建了一个<code>useState</code>钩子。我们将创建额外的钩子来抓住转牌圈和赢家:</p>
<pre>// TickTacToe/TicTacToe.js
// previous code here
export default function TicTacToe() {
  const [board, setBoard] = useState([
    ["", "", ""],
    ["", "", ""],
    ["", "", ""],
  ]);
  const [isCPUNext, setIsCPUNext] = useState(false);
  const [winner, setWinner] = useState(null);
}
</pre>
<ul>
<li><code>board</code>状态:保存棋盘的多维数组</li>
<li><code>setBoard</code>功能:设置板子</li>
<li><code>isCPUNext</code>状态:持有玩家的回合</li>
<li><code>setIsCPUNext</code>功能:设置转弯</li>
<li><code>winner</code>状态:持有游戏的获胜者</li>
<li><code>setWinner</code>功能:设置获胜者</li>
</ul>
<p>接下来，我们将用户界面渲染如下:</p>
<pre>// TickTacToe/TicTacToe.js
// previous code here
export default function TicTacToe() {
  // code here

  return (
    &lt;div className={styles.container}&gt;
      &lt;div className={styles.col}&gt;
        &lt;span onClick={() =&gt; playFn(0, 0)} className={styles.cell}&gt;
          {board\[0\][0]}
        &lt;/span&gt;
        &lt;span onClick={() =&gt; playFn(0, 1)} className={styles.cell}&gt;
          {board\[0\][1]}
        &lt;/span&gt;
        &lt;span onClick={() =&gt; playFn(0, 2)} className={styles.cell}&gt;
          {board\[0\][2]}
        &lt;/span&gt;
      &lt;/div&gt;
      &lt;div className={styles.col}&gt;
        &lt;span onClick={() =&gt; playFn(1, 0)} className={styles.cell}&gt;
          {board\[1\][0]}
        &lt;/span&gt;
        &lt;span onClick={() =&gt; playFn(1, 1)} className={styles.cell}&gt;
          {board\[1\][1]}
        &lt;/span&gt;
        &lt;span onClick={() =&gt; playFn(1, 2)} className={styles.cell}&gt;
          {board\[1\][2]}
        &lt;/span&gt;
      &lt;/div&gt;
      &lt;div className={styles.col}&gt;
        &lt;span onClick={() =&gt; playFn(2, 0)} className={styles.cell}&gt;
          {board\[2\][0]}
        &lt;/span&gt;
        &lt;span onClick={() =&gt; playFn(2, 1)} className={styles.cell}&gt;
          {board\[2\][1]}
        &lt;/span&gt;
        &lt;span onClick={() =&gt; playFn(2, 2)} className={styles.cell}&gt;
          {board\[2\][2]}
        &lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>在上面的代码中，我们有一个包含每个<code>cell</code>和<code>cols</code>的<code>container</code>。每个<code>col</code>都是棋盘的一排。每个<code>cell</code>都是棋盘上的一个单元格。当点击<code>cell</code>时，会调用<code>playFn</code>功能。</p>
<p>看到在第一个<code>cell</code>中，我们显示了值，从而得到了<code>board</code>数组中的第一个数组和数组中的第一个元素。同样，我们对第二个<code>cell</code>也做了同样的事情，最终对其余的细胞也做了同样的事情。</p>
<p>我们还使用<code>board</code>中数组的适当索引和同一个数组中的索引调用了<code>playFn</code>函数，使我们能够捕获我们将在其中放置符号的<code>board</code>。</p>
<p>然而，我们遗漏了一些东西。例如，我们需要指示轮到谁了，显示游戏的获胜者，并添加一个按钮，以便在游戏结束时重新开始:</p>
<pre>// TickTacToe/TicTacToe.js
// previous code here
export default function TicTacToe() {
  // code here
  return;
  &lt;div&gt;
    &lt;div&gt;{!winner &amp;&amp; displayTurn()}&lt;/div&gt;
    {/** previous JSX code here **/}
    {winner &amp;&amp; &lt;h2&gt;{displayWinner()}&lt;/h2&gt;}
    {winner &amp;&amp; (
      &lt;button className={styles.video_game_button} onClick={playAgainFn}&gt;
        Play Again
      &lt;/button&gt;
    )}
  &lt;/div&gt;;
}
</pre>
<p>我们将创建函数<code>playFn</code>。当用户点击它时，它会玩游戏:</p>
<pre>function playFn(arrayIndex, index) {
  if (isCPUNext) return;
  if (winner) return;
  board\[arrayIndex\][index] = players?.HUMAN?.SYM;
  setBoard((board) =&gt; [...board]);
  checkWinner();
  setIsCPUNext(true);
}
</pre>
<p><code>playFn</code>函数将检查游戏是否结束。如果是，它将显示获胜者。如果不是，它将检查玩家是否是下一个。如果是，它会将玩家的符号设置到<code>board</code>数组中该数组的特定索引，并调用<code>setBoard</code>函数来设置棋盘状态。然后，它会调用<code>checkWinner</code>函数来检查游戏是否结束。最后，它将设置<code>isCPUNext</code>为真。</p>
<p>接下来，我们将设置一个<code>useEffect</code>钩子:</p>
<pre>useEffect(() =&gt; {
  if (winner) return;
  if (isCPUNext) {
    cPUPlay();
  }
}, [isCPUNext]);
</pre>
<p>这个<code>useEffect</code>钩子在组件安装后运行，检查游戏是否结束。如果是，它将返回。如果不是，它将检查 CPU 是否是下一个。如果是，它会调用<code>cPUPlay</code>函数来玩游戏。</p>
<p>接下来，我们将创建<code>cPUPlay</code>函数:</p>
<pre>function cPUPlay() {
  if (winner) return;
  sleep(1000);

  const cPUMove = getCPUTurn();

  board\[cPUMove.arrayIndex\][cPUMove.index] = players?.CPU?.SYM;

  setBoard((board) =&gt; [...board]);
  checkWinner();
  setIsCPUNext(false);
}
</pre>
<p><code>cPUPlay</code>函数检查游戏是否结束。如果是，它将返回。如果不是，它会调用 sleep 10 秒，然后调用<code>getCPUTurn</code>函数来获取 CPU 的 move。它会将 CPU 的符号设置为<code>board</code>数组中该数组的特定索引，并调用<code>setBoard</code>函数来设置板卡状态。然后，它会调用<code>checkWinner</code>函数来检查游戏是否结束。最后，它会将<code>isCPUNext</code>设置为假。</p>
<p>接下来，我们将创建<code>getCPUTurn</code>函数，它将返回 CPU 的移动:</p>
<pre>function getCPUTurn() {
  const emptyIndexes = [];
  board.forEach((row, arrayIndex) =&gt; {
    row.forEach((cell, index) =&gt; {
      if (cell === "") {
        emptyIndexes.push({ arrayIndex, index });
      }
    });
  });
  const randomIndex = Math.floor(Math.random() * emptyIndexes.length);
  return emptyIndexes[randomIndex];
}
</pre>
<p>该函数将遍历<code>board</code>数组并找到所有的空单元格，然后，它将随机选择一个空单元格。</p>
<p>接下来，我们将创建<code>checkWinner</code>函数，它将检查游戏是否结束。如果是，它将返回。如果不是，它会检查是播放器还是 CPU 赢了。如果玩家赢了，它会将<code>winner</code>状态设置为<code>HUMAN</code>。如果 CPU 赢了，它将把<code>winner</code>状态设置为<code>CPU</code>。如果是平局，它会将<code>winner</code>状态设置为<code>draw</code>。如果不是平局，它将返回:</p>
<pre>function checkWinner() {
  // check same row
  for (let index = 0; index &lt; board.length; index++) {
    const row = board[index];
    if (row.every((cell) =&gt; cell === players?.CPU?.SYM)) {
      setWinner(players?.CPU?.NAME);
      return;
    } else if (row.every((cell) =&gt; cell === players?.HUMAN?.SYM)) {
      setWinner(players?.HUMAN?.NAME);
      return;
    }
  }

  // check same column
  for (let i = 0; i &lt; 3; i++) {
    const column = board.map((row) =&gt; row[i]);
    if (column.every((cell) =&gt; cell === players?.CPU?.SYM)) {
      setWinner(players?.CPU?.NAME);
      return;
    } else if (column.every((cell) =&gt; cell === players?.HUMAN?.SYM)) {
      setWinner(players?.HUMAN?.NAME);
      return;
    }
  }

  // check same diagonal
  const diagonal1 = \[board[0\][0], board\[1\][1], board\[2\][2]];
  const diagonal2 = \[board[0\][2], board\[1\][1], board\[2\][0]];
  if (diagonal1.every((cell) =&gt; cell === players?.CPU?.SYM)) {
    setWinner(players?.CPU?.NAME);
    return;
  } else if (diagonal1.every((cell) =&gt; cell === players?.HUMAN?.SYM)) {
    setWinner(players?.HUMAN?.NAME);
    return;
  } else if (diagonal2.every((cell) =&gt; cell === players?.CPU?.SYM)) {
    setWinner(players?.CPU?.NAME);
    return;
  } else if (diagonal2.every((cell) =&gt; cell === players?.HUMAN?.SYM)) {
    setWinner(players?.HUMAN?.NAME);
    return;
  } else if (board.flat().every((cell) =&gt; cell !== "")) {
    setWinner("draw");
    return;
  } else {
    setWinner(null);
    return;
  }
}
</pre>
<p>代码非常简单。它遍历<code>board</code>数组，检查相同的行、列或对角线是否有相同的符号。如果是，它会将<code>winner</code>状态设置为玩家的名字。如果所有的棋盘上都没有找到匹配的符号，那么这个游戏就是平局。然后它会将<code>winner</code>状态设置为<code>draw</code>。</p>
<p>让我们创建<code>displayWinner</code>函数:</p>
<pre>function displayWinner() {
  if (winner === "draw") {
    return "It's a draw!";
  } else if (winner) {
    return `${winner} won!`;
  }
}
</pre>
<p>如果<code>winner</code>状态为<code>draw</code>，则返回<code>It's a draw!</code>。如果<code>winner</code>状态不是<code>draw</code>，则返回<code>${winner} won!</code>。现在，我们将创建<code>displayTurn</code>函数:</p>
<pre>function displayTurn() {
  if (isCPUNext) {
    return "CPU's turn";
  } else {
    return "Your turn";
  }
}
</pre>
<p><code>displayTurn</code>函数将检查 CPU 是否是下一个。如果是，则返回<code>CPU's turn</code>。如果不是，它将返回<code>Your turn</code>。</p>
<p>我们将创建<code>playAgainFn</code>函数:</p>
<pre>function playAgainFn() {
  setBoard([
    ["", "", ""],
    ["", "", ""],
    ["", "", ""],
  ]);
  setWinner(null);
  setIsCPUNext(false);
}
</pre>
<p>该功能会将<code>board</code>状态设置为初始板卡状态，并将<code>winner</code>状态设置为<code>null</code>。然后，它会将<code>isCPUNext</code>状态设置为<code>false</code>。</p>
<h2 id="styling-app">设计应用程序</h2>
<p>打开<code>TicTacToe.module.css</code>文件，添加以下样式:</p>
<pre>.container {
  display: flex;
  flex-direction: column;
  background-image: url(https://i.imgur.com/OVBsgc1.jpg);
  border: 2px solid black;
  font-family: "Indie Flower", cursive;
}

.col {
  display: flex;
}

.cell {
  width: 89px;
  height: 89px;
  border: 1px solid lightgray;
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: xxx-large;
  text-transform: capitalize;
  cursor: pointer;
  color: white;
  font-weight: 900;
}

.video_game_button {
  text-shadow: 1px 1px pink, -1px -1px maroon;

  line-height: 1.5em;
  text-align: center;
  display: inline-block;
  width: 4.5em;
  height: 4.5em;
  border-radius: 50%;
  background-color: red;
  box-shadow: 0 0.2em maroon;
  color: red;
  margin: 5px;
  background-color: red;
  background-image: linear-gradient(left top, pink 3%, red 22%, maroon 99%);
  cursor: pointer;
  padding-left: 5px;
}

.video_game_button:active {
  box-shadow: none;
  position: relative;
  top: 0.2em;
}
</pre>
<h2 id="play-the-game">按章办事</h2>
<p><img data-attachment-id="97962" data-permalink="https://blog.logrocket.com/build-tic-tac-toe-game-react-hooks/tic-tac-toe-react-hooks/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/tic-tac-toe-react-hooks.gif" data-orig-size="730,380" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tic-tac-toe-react-hooks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/tic-tac-toe-react-hooks-300x156.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/tic-tac-toe-react-hooks.gif" decoding="async" class="aligncenter wp-image-97962 size-full jetpack-lazy-image" src="../Images/e829680aa16ad896db76f2ebbc28c7dc.png" alt="Tic Tac Toe React Hooks" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/03/tic-tac-toe-react-hooks.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/tic-tac-toe-react-hooks.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="97962" data-permalink="https://blog.logrocket.com/build-tic-tac-toe-game-react-hooks/tic-tac-toe-react-hooks/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/03/tic-tac-toe-react-hooks.gif" data-orig-size="730,380" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tic-tac-toe-react-hooks" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/03/tic-tac-toe-react-hooks-300x156.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/03/tic-tac-toe-react-hooks.gif" decoding="async" loading="lazy" class="aligncenter wp-image-97962 size-full" src="../Images/e829680aa16ad896db76f2ebbc28c7dc.png" alt="Tic Tac Toe React Hooks" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/03/tic-tac-toe-react-hooks.gif"/></noscript>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们解释了井字游戏的玩法。然后，我们搭建了一个 Next.js 项目，继续展示我们如何在电脑上编码和玩井字游戏。</p>
<p>我们的电脑游戏有最少或神秘的逻辑。如果能增加逻辑的趣味性，让计算机能像人一样思考和游戏，那就太好了。我们还可以通过添加一些有趣的功能，如聊天、排行榜和游戏历史，使游戏更有趣。</p>
<p>我等不及要看你想出什么了！编码快乐！</p>
<p> </p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
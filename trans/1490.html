<html>
<head>
<title>5 top React Hooks libraries compared - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>5 大 React 钩子库比较</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/5-top-react-hooks-libraries-compared/#0001-01-01">https://blog.logrocket.com/5-top-react-hooks-libraries-compared/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React 的 Hooks API 现在是创建组件的实际方法。它与类组件 API 共存，让我们可以用 JavaScript 类创建组件。</p>
<p>除了 React 库附带的标准挂钩，开发人员还可以创建自己的挂钩。不出所料，许多定制钩子库已经出现，使得创建 React 应用程序更加容易。</p>
<p>在本文中，我们将看看五个有用的 React Hooks 库，并比较它们的效用</p>

<p>React 钩子库为我们提供了类似 React 类组件的生命周期方法的钩子。</p>
<p>例如，它提供了像<code>useDidMount</code>和<code>useDidUpdate</code>这样的挂钩，前者在组件安装时运行，后者在组件更新时运行。它也有管理状态的钩子，像<code>useCounter</code>，它添加了一个有自己功能的数字状态来管理它。</p>
<p>要安装这个包，我们可以运行:</p>
<pre>npm i react-hooks-lib --save</pre>
<p>然后我们可以从模块中导入一些钩子来使用它们。我们可以通过编写以下代码来使用<code>useDidMount</code>钩子:</p>
<pre>import React from "react";
import { useDidMount } from "react-hooks-lib";

export default function App() {
  useDidMount(() =&gt; {
    console.log("did mount");
  });

  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;Hello world&lt;/h1&gt;
    &lt;/div&gt;
  );
}</pre>
<p>同样，我们可以通过编写以下代码来使用<code>useCounter</code>钩子:</p>
<pre>import React from "react";
import { useCounter } from "react-hooks-lib";

export default function App() {
  const { count, inc, dec, reset } = useCounter(0);
  return (
    &lt;div&gt;
      {count}
      &lt;button onClick={() =&gt; inc(1)}&gt;increment&lt;/button&gt;
      &lt;button onClick={() =&gt; dec(1)}&gt;decrement&lt;/button&gt;
      &lt;button onClick={reset}&gt;reset&lt;/button&gt;
    &lt;/div&gt;
  );
}</pre>
<p>它用<code>count</code>状态和<code>inc</code>、<code>dec</code>和<code>reset</code>方法返回一个对象。让我们来分解一下这些方法的作用:</p>
<ul>
<li><code>inc</code>将<code>count</code>增加一个给定的数字</li>
<li>将<code>count</code>减少给定的数量</li>
<li><code>reset</code>将<code>count</code>重置为初始值</li>
</ul>
<p>React Hooks Lib 还附带了<code>useField</code>钩子，使得获取和设置输入值更加容易。我们可以通过书写来使用它:</p>
<pre>import React from "react";
import { useField } from "react-hooks-lib";

export default function App() {
  const { value, bind } = useField("text");

  return (
    &lt;div&gt;
      &lt;input type="text" {...bind} /&gt;
      &lt;p&gt;{value}&lt;/p&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们只是将整个<code>bind</code>对象传入输入，我们可以用它从输入中获取数据，并将其设置为<code>value</code>的值。<code>bind</code>也有<code>value</code>属性来设置输入值。</p>
<p>它也适用于选择元素:</p>
<pre>import React from "react";
import { useField } from "react-hooks-lib";

export default function App() {
  const { value, bind } = useField("text");

  return (
    &lt;div&gt;
      &lt;select {...bind}&gt;
        &lt;option value="apple"&gt;apple&lt;/option&gt;
        &lt;option value="orange"&gt;orange&lt;/option&gt;
      &lt;/select&gt;
      &lt;p&gt;{value}&lt;/p&gt;
    &lt;/div&gt;
  );
}</pre>
<p>React Hooks Lib 附带了许多其他提供类似功能的钩子。总的来说，它为我们提供了定制的钩子，可以做一些方便的事情。然而，我们应该注意，并不是所有提供的钩子都有文档记录。</p>

<p>react-hanger 是一个库，它为我们提供了 react 钩子，让我们可以更容易地管理各种状态。它带有以下挂钩:</p>
<ul>
<li><code>useInput</code>–获取并设置输入控制值</li>
<li><code>useBoolean</code>–获取和设置布尔状态</li>
<li><code>useNumber</code>–获取和设置状态数</li>
<li><code>useArray</code>–获取和设置数组状态</li>
<li><code>useOnMount</code>–安装组件时运行代码</li>
<li><code>useOnUnmount</code>–卸载组件时运行代码</li>
<li><code>useStateful</code>–获取并设置组件状态</li>
</ul>
<p>我们可以如下使用<code>useInput</code>来简化输入值的处理:</p>
<pre>import React from "react";
import { useInput } from "react-hanger";

export default function App() {
  const input = useInput("");

  return (
    &lt;div&gt;
      &lt;input type="text" value={input.value} onChange={input.onChange} /&gt;
      &lt;p&gt;{input.value}&lt;/p&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们可以使用<code>useNumber</code>来获取和设置一个数字状态:</p>
<pre>import React from "react";
import { useNumber } from "react-hanger";

export default function App() {
  const counter = useNumber(3, { lowerLimit: 0, upperLimit: 5 });

  return (
    &lt;div&gt;
      &lt;p&gt; {counter.value} &lt;/p&gt;
      &lt;button onClick={() =&gt; counter.increase()}&gt; increase &lt;/button&gt;
      &lt;button onClick={() =&gt; counter.decrease()}&gt; decrease &lt;/button&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们可以用第一个参数设置<code>counter.value</code>的初始值，用第二个参数设置<code>counter.value</code>状态的下限和上限。<code>useArray</code>和<code>useBoolean</code>挂钩的工作方式类似。</p>
<p>要设置任何一种状态，我们可以使用<code>useStateful</code>钩子:</p>
<pre>import React from "react";
import { useStateful } from "react-hanger";

export default function App() {
  const username = useStateful("tom");

  return (
    &lt;div&gt;
      &lt;p&gt; {username.value} &lt;/p&gt;
      &lt;button onClick={() =&gt; username.setValue("tom")}&gt; tom &lt;/button&gt;
      &lt;button onClick={() =&gt; username.setValue("jerry")}&gt; jerry &lt;/button&gt;
    &lt;/div&gt;
  );
}</pre>
<p>它比 React 的<code>useState</code>钩子更好，因为我们可以从<code>value</code>属性中获取状态的值，并且我们可以用返回对象的<code>setValue</code>方法来设置该值。与 React 内置的<code>useState</code>钩子不同，获取 state 和 setter 函数不需要析构。</p>

<p>像无数其他库一样，React hookedUp 让我们可以管理组件状态。但是我们也可以用它来管理 HTML 元素的焦点和悬停。</p>
<p>它附带了一些钩子，这些钩子复制了类组件生命周期钩子的功能，还附带了一些有用的定时器和网络钩子，这些钩子是我们到目前为止讨论过的其他库中没有提供的。</p>
<p>让我们来看看<code>useHover</code>钩子，它会检测我们是否将鼠标悬停在输入上:</p>
<pre>import React from "react";
import { useHover } from "react-hookedup";

export default function App() {
  const { hovered, bind } = useHover();

  return (
    &lt;div&gt;
      &lt;p&gt;{hovered ? "hovered" : "not hovered"}&lt;/p&gt;
      &lt;input {...bind} /&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们只是将整个<code>bind</code>对象展开作为<code>input</code>的道具。<code>useFocus</code>钩也可以以类似的方式使用。</p>
<p>如果我们在类组件中错过了好的 ol' <code>componentDidMount</code>方法，我们可以使用<code>useOnMount</code>钩子在函数组件中提供等效的功能:</p>
<pre>import React from "react";
import { useOnMount } from "react-hookedup";

export default function App() {
  useOnMount(() =&gt; console.log("mounted"));
  return &lt;div&gt; hello world &lt;/div&gt;;
}</pre>
<p>如果我们想在代码中调用<code>setInterval</code>，我们可以使用<code>useInterval</code>钩子。例如，我们可以写:</p>
<pre>import React, { useState } from "react";
import { useInterval } from "react-hookedup";

export default function App() {
  const [time, setTime] = useState(new Date().toString());

  useInterval(() =&gt; setTime(new Date().toString()), 1000);

  return &lt;p&gt;{time}&lt;/p&gt;;
}</pre>
<p>我们只是传入回调函数作为第一个参数运行，传入间隔作为第二个参数，就像<code>setInterval</code>函数一样。</p>
<p>它还附带了一个<code>useTimeout</code>钩子，用于在给定的延迟后运行回调:</p>
<pre>import React from "react";
import { useTimeout } from "react-hookedup";

export default function App() {
  useTimeout(() =&gt; alert("hello world"), 1500);

  return &lt;h1&gt;hello world&lt;/h1&gt;;
}</pre>
<p>React hookedUp 的另一个有用的钩子是<code>useOnlineStatus</code>，它允许我们查看我们的应用程序的在线状态。例如，我们可以写:</p>
<pre>import React from "react";
import { useOnlineStatus } from "react-hookedup";

export default function App() {
  const { online } = useOnlineStatus();

  return &lt;h1&gt;{online ? "online" : "offline"}&lt;/h1&gt;;
}</pre>
<p>它返回<code>online</code>属性，当设备在线时是<code>true</code>。</p>
<p>就像我们之前提到的，React hookedUp 还附带了一套状态管理挂钩，这是我们之前看到的库附带的。这些功能与它们在其他库中的工作方式相似。</p>

<p>react-use 钩子库提供了比目前列出的其他库更大的钩子集合，包括利用浏览器可以访问的各种硬件的钩子。它还带有钩子来观察屏幕大小、运动、滚动、动画，以及动态调整 CSS 等等。</p>
<p>例如，我们可以使用<code>useMouse</code>钩子来观察用户鼠标的位置:</p>
<pre>import React from "react";
import { useMouse } from "react-use";

export default function App() {
  const ref = React.useRef(null);
  const { docX, docY, posX, posY, elX, elY, elW, elH } = useMouse(ref);

  return (
    &lt;div ref={ref}&gt;
      &lt;div&gt;
        Mouse position in document - ({docX}, {docY})
      &lt;/div&gt;
      &lt;div&gt;
        Mouse position in element - ({elX}, {elY})
      &lt;/div&gt;
      &lt;div&gt;
        Element position- ({posX} , {posY})
      &lt;/div&gt;
      &lt;div&gt;
        Element dimensions - {elW}x{elH}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们可以使用<code>docX</code>和<code>docY</code>来获取鼠标在文档中的 x 和 y 坐标。同样，我们可以使用<code>elX</code>和<code>elY</code>属性来获取鼠标在被监控元素中的 x 和 y 坐标。我们将 ref 分配给我们想要观察的元素。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>类似地，我们可以使用<code>useScroll</code>钩子来跟踪元素的滚动位置:</p>
<pre>import React from "react";
import { useScroll } from "react-use";

export default function App() {
  const scrollRef = React.useRef(null);
  const { x, y } = useScroll(scrollRef);

  return (
    &lt;div ref={scrollRef} style={{ height: 300, overflowY: "scroll" }}&gt;
      &lt;div style={{ position: "fixed" }}&gt;
        &lt;div&gt;x: {x}&lt;/div&gt;
        &lt;div&gt;y: {y}&lt;/div&gt;
      &lt;/div&gt;
      {Array(100)
        .fill()
        .map((_, i) =&gt; (
          &lt;p key={i}&gt;{i}&lt;/p&gt;
        ))}
    &lt;/div&gt;
  );
}</pre>
<p>我们为想要查看其滚动位置的元素分配一个 ref，并将<code>height</code>和<code>overflowY</code>设置为<code>scroll</code>，这样我们就可以滚动内容。我们用返回的<code>x</code>和<code>y</code>属性获得滚动位置。</p>
<p>我们也可以使用钩子来提供动画。例如，我们可以使用<code>useSpring</code>钩子来动画显示数字:</p>
<pre>import React, { useState } from "react";
import useSpring from "react-use/lib/useSpring";

export default function App() {
  const [target, setTarget] = useState(50);
  const value = useSpring(target);

  return (
    &lt;div&gt;
      {value}
      &lt;br /&gt;
      &lt;button onClick={() =&gt; setTarget(0)}&gt;Set 0&lt;/button&gt;
      &lt;button onClick={() =&gt; setTarget(200)}&gt;Set 100&lt;/button&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们将动画的数字传递到<code>useSpring</code>钩子中。然后数字会一直显示，直到到达<code>target</code>。注意<code>rebound</code>是这个钩子工作所必需的。</p>
<p>这个库也有钩子让我们提交各种副作用，比如将数据复制到剪贴板和操作本地存储。要添加复制到剪贴板特性，我们可以使用<code>useCopyToClipboard</code>钩子:</p>
<pre>import React, { useState } from "react";
import useCopyToClipboard from "react-use/lib/useCopyToClipboard";

export default function App() {
  const [text, setText] = useState("");
  const [state, copyToClipboard] = useCopyToClipboard();

  return (
    &lt;div&gt;
      &lt;input value={text} onChange={(e) =&gt; setText(e.target.value)} /&gt;
      &lt;button type="button" onClick={() =&gt; copyToClipboard(text)}&gt;
        copy text
      &lt;/button&gt;
      {state.error ? (
        &lt;p&gt;error: {state.error.message}&lt;/p&gt;
      ) : (
        state.value &amp;&amp; &lt;p&gt;Copied {state.value}&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
}</pre>
<p>我们只需在组件中调用<code>useCopyToClipboard</code>来获得<code>copyToClipboard</code>函数，然后我们可以调用它来复制任何作为参数传入剪贴板的内容。</p>
<p>同样，我们可以通过<code>useLocalStorage</code>钩子轻松地使用本地存储:</p>
<pre>import React from "react";
import useLocalStorage from "react-use/lib/useLocalStorage";

export default function App() {
  const [value, setValue, remove] = useLocalStorage("key", "foo");

  return (
    &lt;div&gt;
      &lt;div&gt;Value: {value}&lt;/div&gt;
      &lt;button onClick={() =&gt; setValue("bar")}&gt;bar&lt;/button&gt;
      &lt;button onClick={() =&gt; setValue("baz")}&gt;baz&lt;/button&gt;
      &lt;button onClick={() =&gt; remove()}&gt;Remove&lt;/button&gt;
    &lt;/div&gt;
  );
}</pre>
<p><code>value</code>具有带有给定键的本地存储条目的值，<code>setValue</code>让我们传入要设置的值，<code>remove</code>从本地存储中移除条目。</p>
<p>除了前面提到的 react-use 特有的钩子之外，这个库还附带了许多钩子，用于设置状态、使用浏览器 API、运行异步代码等等。react-use 是迄今为止我们看到的最全面的钩子库。</p>

<p>React Recipes 是另一个钩子库，带有许多自定义钩子。它提供了许多与 react-use 相同的钩子，比如使用浏览器 API、管理状态、运行异步代码等的钩子。</p>
<p>例如，我们可以使用<code>useSpeechSynthesis</code>钩子让浏览器说话:</p>
<pre>import React, { useState } from "react";
import { useSpeechSynthesis } from "react-recipes";

export default function App() {
  const [value, setValue] = useState("");
  const [ended, setEnded] = useState(false);
  const onBoundary = (event) =&gt; {
    console.log(`${event.name}: ${event.elapsedTime} milliseconds.`);
  };
  const onEnd = () =&gt; setEnded(true);
  const onError = (event) =&gt; {
    console.warn(event);
  };

  const {
    cancel,
    speak,
    speaking,
    supported,
    voices,
    pause,
    resume
  } = useSpeechSynthesis({
    onEnd,
    onBoundary,
    onError
  });

  if (!supported) {
    return "Speech is not supported.";
  }

  return (
    &lt;div&gt;
      &lt;input value={value} onChange={(event) =&gt; setValue(event.target.value)} /&gt;
      &lt;button
        type="button"
        onClick={() =&gt; speak({ text: value, voice: voices[1] })}
      &gt;
        Speak
      &lt;/button&gt;
      &lt;button type="button" onClick={cancel}&gt;
        Cancel
      &lt;/button&gt;
      &lt;button type="button" onClick={pause}&gt;
        Pause
      &lt;/button&gt;
      &lt;button type="button" onClick={resume}&gt;
        Resume
      &lt;/button&gt;
      &lt;p&gt;{speaking &amp;&amp; "Voice is speaking"}&lt;/p&gt;
      &lt;p&gt;{ended &amp;&amp; "Voice has ended"}&lt;/p&gt;
      &lt;div&gt;
        &lt;h2&gt;Voices:&lt;/h2&gt;
        &lt;div&gt;
          {voices.map((voice) =&gt; (
            &lt;p key={voice.name}&gt;{voice.name}&lt;/p&gt;
          ))}
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</pre>
<p>我们称之为<code>useSpeechSynthesis</code>钩子，它返回一个具有各种属性的对象:</p>
<ul>
<li><code>cancel</code>取消语音合成</li>
<li><code>speak</code>让浏览器开始说话</li>
<li><code>speaking</code>是一个布尔值，它告诉我们语音合成是否正在进行</li>
<li><code>supported</code>是一个布尔值，它告诉我们当前的浏览器是否支持语音合成</li>
<li>有可供选择的声音列表</li>
<li>让我们暂停说话</li>
<li>让我们继续说话</li>
</ul>
<p>它附带了许多钩子，这里列出了这些钩子，它们为我们提供了许多 React 本身所没有的功能。它是一个真正有良好文档记录和全面的库，这一点也没有什么价值。</p>
<h2>判决结果？</h2>
<p>到目前为止，我们今天讨论的最全面、最有用的 React 钩子库是 react-use 和 React Recipes。它们为我们提供了许多针对各种用例的钩子，这样我们就不必自己从头开始编写了。</p>
<p>React Hooks Lib、react-hanger 和 React hookedUp 为状态管理提供了一些基本的钩子，可以在一定程度上帮助我们简化状态管理。如果这就是我们要从钩子库中寻找的，那么 React Hooks Lib、react-hanger 和 React hookedUp 是有用的。它们都很容易使用，所有的(除了 React Hooks Lib)都有清晰的文档。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
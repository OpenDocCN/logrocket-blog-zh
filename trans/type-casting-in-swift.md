# Swift - LogRocket 博客中的类型转换

> 原文：<https://blog.logrocket.com/type-casting-in-swift/>

由苹果公司于 2014 年创建的 [Swift](https://www.apple.com/swift/) 是一种流行的开源语言，用于构建 iOS 应用程序，已经获得了强大的开发者社区和丰富的第三方内容。

像几乎所有其他编程语言一样，Swift 有自己的规则和语法。在本指南中，我们将了解 Swift 中的类型转换，这是现代面向对象编程语言中的一个流行概念。

## Swift 中有哪些类型？

本质上，类型是一个类的基本等价物，用于表示存储在变量中的数据种类。由于每个类都与其他类不同，所以数据类型也不同，这使得开发人员可以根据他们持有的数据类型来区分变量。对数据类型进行分类可以防止类型不匹配，这是编译时常见的错误。

类型与编译器无关。如果存储在变量中的数据适用于流程中稍后执行的操作，流程将相应地运行。

但是，如果类型不匹配导致流程中断，您将会看到一个编译错误。即使类型不匹配没有显式中断流程，它也可能在编译过程中被忽略，从而在运行程序时导致意外的结果。

Swift 是一种强类型编程语言。Swift 中的每个变量都有一个关联的类型，一旦某个类型被分配给一个变量，它就不能存储任何其他类型的数据。

弱类型语言在这方面没有那么严格。例如，在 PHP 和 C 之类的语言中，您可以在一定程度上改变数据类型，以便在代码中获得更大的灵活性。

## 什么是类型转换？

使用类型的约束迫使语言失去了很大一部分灵活性。类型转换提供了一种恢复灵活性的方法。

不是所有的类变量都保存像整数和字符串这样的原始数据。大多数现代应用程序的逻辑依赖于自定义对象，这些对象通过类来实现。从现在开始，我们将按类型引用原始数据类型和类。

类型转换是大多数面向对象语言中使用的一种编程范式，它允许开发人员将一种类型的对象视为另一种类型的对象。虽然类型转换一开始可能没有多大意义，但它有助于简化现代应用程序中的许多例程。

类型转换不会改变相关的对象。相反，它改变了用于描述对象的类型。例如，您显然不能将保存字符串的对象的类型从`string`更改为`integer`，因为在现实生活中，将一个句子视为一个数字是没有意义的。

要进行类型转换，相关对象的原始类型和新类型必须是彼此的子类或超类。假设一个叫做`Vehicle`的类有两个子类，`Car`和`Truck`。你可以将一个类型为`Car`的对象投射到`Vehicle`，反之亦然，或者将`Truck`投射到`Vehicle`，反之亦然。

现在，假设有另一个名为`Ship`的类，它与`Truck`、`Car`或`Vehicle`没有关系。您将无法将其对象转换为上面给出的任何类型。

## 向上抛

向上转换用于通过使用类本身的变量来概括一个类的一系列子类。让我们考虑使用`Car`、`Truck`和`Vehicle`的例子。

我们之前提到过`Car`或`Truck`可以被类型转换为`Vehicle`。子类的对象被类型转换成其超类的对象。把它想象成在阶级阶层中的上升。

向上转换允许您在类型为`Vehicle` : `Car`，`Truck`等的引用中存储任何类型的`Vehicle`。我们已经知道这些是同一个阶层的后代，`Vehicle`，他们必然有一些相似之处。将他们的对象升级到`Vehicle`类使用了这种一般化，让我们使用循环和其他常规范例来运行操作。

这是一个向上转换的例子:

```
let truck:Truck = Vehicle(wheels:8)
```

在上面的代码块中，您声明了一个名为`truck`的引用，它的类型是`Truck`。接下来，用一个有八个轮子的`Vehicle`实例初始化它。您可以看到引用变量的类型注释和分配给它的对象完全不同。

如前所述，我们可以执行这个操作，因为`Truck`和`Vehicle`属于同一个类层次结构。这就好比说卡车是一种交通工具，在逻辑上是正确的。

在上面的例子中，向上转换是隐式的。但是，您可以通过运行以下代码使其可见:

```
let truck:Truck = Vehicle(wheels:8) as Truck
```

稍后，我们将更详细地讨论隐式向上转换。

* * *

### 更多来自 LogRocket 的精彩文章:

* * *

## 向下铸造

向下造型与向上造型相反，它指的是将父类类型的对象造型为其子类的对象。向下转换用于重新转换子类的对象，这些对象之前被向上转换以进行泛化。

假设你拥有两辆汽车和三辆卡车。如果将它们存储在一个共享数组中，类型推断会将数组的类型决定为`Vehicle`，这是两种类型的公共父类型。

如果您试图从数组中获取一个项目，您将获得一个类型为`Vehicle`的对象。要把它改回原来的类型，你需要把它转换成一个`Truck`或`Vehicle`。

重要的是要明白，列表中的车辆并不都是汽车，这在某些情况下可能会导致向下转换失败。为了解决这个问题，我们将使用两种类型的向下转换操作符，我们将在后面介绍。

## 卧式铸造

请注意，`Car`和`Truck`共享一个公共超类，但是，您不能将类型为`Car`的对象强制转换为`Truck`，反之亦然。它们既不是子类，也不是超类。因此，水平转换被禁用，如果你试图将一个`Car`转换成一个`Truck`，你会得到一个错误。

## Swift 中的类型转换运算符

要执行上述操作，您将使用以下操作符:

### `as`

`as`操作符用于向上投射对象。然而，在大多数情况下，向上转换是隐式完成的，所以您不会频繁使用`as`。

重申一下，这里有一个将`Chair`向上转换为`Furniture`的例子:

```
let furniture:Furniture = Chair(legs: 4) as Furniture
```

### `as?`

`as?`运算符用于可选的向下转换，是 Swift 中可用的两个向下转换运算符之一。当您不确定一个对象是否可以成功向下转换时，使用`as?`。

如果您试图从不同的类层次结构中向下转换一个对象，您的程序在遇到错误时会返回一个`nil`值。为了验证向下转换是否成功，可以对`nil`进行简单的检查。

您可以在我们的`Vehicle`示例中使用`as?`操作符:

```
let truckObject = vehiclesArray[0] as? Truck
```

您正在指示控件从数组中访问第一个对象，将其向下转换为一个`Truck`，并将结果存储在`truckObject`变量中。

如果向下转换成功，您将在`truckObject`中找到一个`Truck`实例。如果失败，`truckObject`将指向`nil`。然后，您可以通过运行以下命令来检查`nil`:

```
if truckObject != nil {
print("The reference points to some value!")
} else {
print("The reference points to nil, and so the downcast was unsuccessful")
}
```

### `as!`

`as!`操作符用于强制向下转换，仅当类型转换操作可行时才返回一个对象。如果您尝试从不同的类层次结构向下转换对象，您的程序将遇到致命错误。

下面是如何在我们的`Vehicle`示例中使用`as!`操作符:

```
let carObject = vehiclesArray[1] as! Car
```

上面的代码行指示控件从数组中访问第二个对象，将其向下转换为一个`Truck`，并将结果存储在`truckObject`变量中。如果向下转换失败，程序就会崩溃。

记住这几点，只有当您确定您向下转换的对象属于类层次结构时，您才应该使用`as!`操作符，并且操作将成功完成。

如果类型不匹配，您还可以在代码流需要中断的情况下使用`as!`操作符，这表明在中间计算中可能会出现意外的结果。

### `is`

`is`操作符用于检查实例的类型。使用`is`操作符进行类型检查的结果是类型`Bool`，这表明该类型是否匹配，如下面的代码块所示:

```
let car: Car = Car(wheels: 4)

if car is Car {
print("It is a Car.")
} else if car is Truck {
print("It is a Truck.")
}
```

输出是:

```
It is a Car.
```

您还可以使用`is`操作符来检查任何隐式向上转换。让我们考虑一个例子:

```
let car: Car = Vehicle(wheels: 4)

print(car is Car)
print(car is Truck)
print(car is Vehicle)
```

上面代码的输出是:

```
true
false
true
```

输出表明 car 引用是类型`Car`和隐式向上转换类型`Vehicle`。因为水平铸造是不可能的，`Car`永远不可能是`Truck`类型。

## 你自己试试

在本文中，您了解了 Swift 中的类型和类型转换，并介绍了用于类型转换对象的各种操作符。

类型转换是一个使面向对象编程非常强大和灵活的概念。有了通过向上造型和向下造型在类层次结构中上下移动的能力，您可以根据需要使用泛化。

记住所有信息的关键是坚持练习。我希望你喜欢这篇文章。编码快乐！

## 使用 [LogRocket](https://lp.logrocket.com/blg/signup) 消除传统错误报告的干扰

[![LogRocket Dashboard Free Trial Banner](img/d6f5a5dd739296c1dd7aab3d5e77eeb9.png)](https://lp.logrocket.com/blg/signup)

[LogRocket](https://lp.logrocket.com/blg/signup) 是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。

然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。

LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。

关注重要的 bug—[今天就试试 LogRocket】。](https://lp.logrocket.com/blg/signup-issue-free)
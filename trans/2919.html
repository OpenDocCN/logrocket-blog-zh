<html>
<head>
<title>BEM vs. SMACSS: Comparing CSS methodologies - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>BEM vs. SMACSS:比较 CSS 方法论</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/bem-vs-smacss-comparing-css-methodologies/#0001-01-01">https://blog.logrocket.com/bem-vs-smacss-comparing-css-methodologies/#0001-01-01</a></blockquote><div><article class="article-post">
 <p>让我们面对现实吧，如果你没有一个好的方法或架构可以遵循，CSS 可能是一个真正的痛苦。到处编写大量不同的选择器并不是理想的策略；它产生了许多与特殊性相关的问题，并可能使我们的代码库混乱不堪，调试困难。</p>
<p>遵循 CSS 方法可以保证参与开发过程的每个人都说同一种语言。这在有几个人的大型项目中尤其重要，这使得软件更容易扩展，新的团队成员也更容易快速了解代码库。</p>
<p>在本文中，我们将比较两种广泛使用的 CSS 方法:块、元素、修饰符(BEM)和 CSS 的可伸缩和模块化架构(SMACSS)。我们将看看它们的相似之处，以及它们最终是如何相互比较的。</p>

<h2 id="what-is-bem">BEM 是什么？</h2>
<p>BEM 是一个简单的命名约定，它使您的前端代码更容易阅读、理解、使用和扩展。它是健壮和明确的。</p>
<p>我们都知道当一个 HTML 文档没有良好的结构时，它会变得多么混乱。再加上一个糟糕的 CSS 类命名约定，你就有了一个难以理解、错误百出、甚至难以扩展的代码库。</p>
<p>遵循 BEM 命名约定不仅可以简化 CSS 文件的结构，还可以简化 HTML 文档的结构。我们可以用独立的代码块和 CSS 选择器以组件驱动的方式思考，使我们的代码可重用和模块化。</p>
<p>要使用 BEM，我们只需要遵循它的命名约定！</p>
<ul>
<li>B 代表 block。块是独立的实体。卡组件就是一个例子</li>
<li>E 代表元素。一个元素是一个块的一部分，在语义上和它联系在一起，它本身没有任何意义</li>
<li>M 代表修饰词。它只是一个标志，允许您修改元素或块的外观或行为</li>
</ul>
<p>让我们在下面的例子中看看所有这些是如何组合在一起的:</p>
<pre class="language-xml hljs">&lt;div class="card card-current"&gt;
  &lt;div class="card__img"&gt;
    &lt;img src="#" alt="#" /&gt;
  &lt;/div&gt;
  &lt;div class="card__desc"&gt;
    &lt;h3&gt;Card Title&lt;/h3&gt;
    &lt;p&gt;Some descriptiton for our card element.&lt;/p&gt;
  &lt;/div&gt;
  &lt;div class="card__buttons"&gt;
    &lt;button class="card__button card__button-danger"&gt;Delete&lt;/button&gt;
    &lt;button class="card__button card__button-success"&gt;Confirm&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>在 BEM 方法中，块只有一个类名。你可以在上面的例子中看到这一点。作为块一部分的元素以块名为前缀，后跟双下划线和元素名。你可以在上面的例子中看到<code>.card__img</code>、<code>.card__desc</code>、<code>.card__buttons</code>和<code>.card__button</code>的例子。</p>
<p>最后，修饰符以它们所修改的块名或元素为前缀，比如我们例子中的<code>.card-current</code>、<code>.card__button-success</code>和<code>.card__button-danger</code>。</p>
<h2 id="what-is-smacss-how-does-it-work">什么是 SMACSS，它是如何工作的？</h2>
<p>SMACSS 是一系列对 CSS 规则集进行分类的规则，目的是使 CSS 代码库更加有组织、干净、可伸缩和模块化。遵循 SMACSS 方法，我们可以将 CSS 规则集分为五类:</p>
<ol>
<li>基础</li>
<li>布局</li>
<li>组件</li>
<li>状态</li>
<li>主题</li>
</ol>
<h3 id="base">基础</h3>
<p>所有为 HTML 元素提供默认样式的 CSS 规则集都被称为基本规则。我们不使用类或 ID 选择器，而是使用元素、属性、伪类、子或兄弟选择器来定义这些规则集。有时我们称这些样式规则为重置，因为它们重置了 HTML 元素的默认样式。</p>
<h3 id="layout">布局</h3>
<p>在重用的基础上，布局风格可以分为主要风格和次要风格。主要组件是那些建立页面结构的组件，比如页眉、页脚、侧栏、正文等等。页面布局由几个主要组件组成，称为布局规则。另一方面，模块是位于主要组件中的次要组件。</p>
<h3 id="module">组件</h3>
<p>模块是相互分离且不同的 UI 组件。它们通常出现在布局组件中，但有时也会出现在其他模块组件中。它们不受其他用户界面模块或布局的影响。例如手风琴、模态对话框或旋转木马。</p>
<h3 id="state">状态</h3>
<p>CSS 规则集用于为组件的各种状态指定样式。这实际上覆盖了 UI 模块的默认样式。例如，消息 toast 组件可能处于成功或不成功状态，我们可以用红色或绿色来描述。状态类似于边界元法中的修饰语。</p>
<h3 id="theme">主题</h3>
<p>主题 CSS 规则集的目的是创建特定于主题的样式。特定于主题的属性主要覆盖默认的颜色和图片。</p>
<h2 id="bem-vs-smacss-comparing-developer-experience">BEM 与 SMACSS:比较开发人员的体验</h2>
<h3 id="clean-code">干净的代码</h3>
<p>BEM 遵循一个命名约定，告诉开发人员如何给元素起类名。这为构建我们的 HTML 文档和样式表提供了一种很好的方式。尽管类名会变得很长，但它们仍然清晰易读。</p>
<p>SMACSS 也使我们的代码库变得干净。它的分类规则让我们知道应该在哪里以清晰简洁的方式声明样式规则，它的命名约定让我们的 HTML 文档干净易读，因为类名很少。</p>
<p>当涉及到确保我们的代码库是干净的、可读的和易于导航时，这两种方法都是很棒的。</p>
<h3 id="file-structure">文件结构</h3>
<p>我们如何在项目文件夹中构建文件是一件非常重要的事情。让我们比较一下这两种方法，这样我们就可以看到它们是如何组织文件的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>BEM 方法有三种组织项目文件夹的方法:</p>

<p>你可以在这里找到这三种方法是如何工作的。遵循 BEM 技术，您必须为项目中的每个块创建新文件，随着项目的增长和其他块的添加，您的项目目录可能会变得混乱，使开发更加困难。</p>
<p>你的项目有多大并不重要；如果您遵循 smcss 方法，您将拥有与我们在上面的 smcss 概述部分看到的相同的文件夹结构。它使用 SMACSS 分类规则，并定义我们如何构建我们的项目文件夹。</p>
<p>在这种方法中，随着项目的增长，您的模块文件通常是最大的。这可能会使搜索模块变得很麻烦，但我发现，如果你在 Mac 上，一个简单的<code>Ctrl+F</code> <strong>、</strong>或<code>Command+F</code>可以帮助你轻松快速地搜索模块。</p>
<p>在这一点上，我不会说两者之间有明显的赢家。对我来说，我更喜欢搜索单个文件，而不是整个目录。</p>
<h3 id="development-time">程序调试时间</h3>
<p>除非你使用的是像 Sass 或更低版本的 CSS 预处理器，否则当你使用 BEM 方法时，开发会有点慢。按照命名约定来声明类名可能会花费一些时间。我的意思是:</p>
<pre class="language-xml hljs">&lt;div class="card card-current"&gt;
  &lt;div class="card__img"&gt;&lt;/div&gt;
  &lt;div class="card__desc"&gt;&lt;/div&gt;
  &lt;div class="card__buttons"&gt;
    &lt;button class="card__button card__button-danger"&gt;Delete&lt;/button&gt;
    &lt;button class="card__button card__button-success"&gt;Confirm&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>注意类名有多长？如果我们使用常规的 CSS 来定位这些元素，可能会有点麻烦和耗时。我的意思是:</p>
<pre class="language-css hljs">.card{...}
.card-current{...}
.card__img{...}
.card__desc{...}
.card__button{...}
.card__button-danger{...}
</pre>
<p>如果我们使用 CSS 预处理器(在本例中是 Sass)就可以解决这个问题，所以我们上面的代码看起来像这样:</p>
<pre class="language-css hljs">.card{
  &amp;__img{...}
  &amp;__desc{...}
  &amp;__buttons{...}
}
</pre>
<p>我们仍然需要在 HTML 元素上写类名，所以对于每个块，都要在它的元素和修饰符前面加上很多块名。</p>
<p>SMACSS 的核心是分类。它并没有真正给你一个严格的命名约定来遵循，它只是告诉你在哪里放置相似的样式规则，并给开发者命名元素的灵活性。它建议您根据它们的分类给选择器加前缀，例如，布局样式规则可以写成<code>.l-example</code>。</p>
<p>然而，SMACSS 并不建议您遵循相同的模块命名规则，因为模块会随着项目呈指数增长。它建议您在模块内的相关元素前加上它们的基本名称。例如，<code>.base</code>是模块，<code>.base-element</code>是模块中的元素。</p>
<p>在我看来，SMACSS 的开发时间比 BEM 快得多，因为你不必编写这么长的类选择器。</p>
<h3 id="scalability-support">可扩展性和支持</h3>
<p>很难说这两种方法中哪一种提供了更好的可伸缩性和支持；BEM 似乎提供了更多的支持，而 SMACSS 似乎是一个更具可伸缩性的替代方案。尽管如此，我们还是试着在这里做一个比较。</p>
<p>许多人声称，由于使用 BEM 方法时类名会变得非常长，我们的 HTML 页面会变得非常混乱，新团队成员很难在代码库中导航。但我不同意。在我看来，更容易快速理解 BEM 是怎么回事，因为为每个块都创建了新文件。</p>
<p>此外，BEM 允许您构建代码，以便您可以创建可重用的组件，并且您可以使用修饰符更改组件的外观和行为，以适应它们所处的上下文。随着项目开始增长，为每个块或组件创建一个新文件可能有点太多，而且对可伸缩性没有帮助。</p>
<p>对于加入大型团队的新项目的人来说，SMACSS 提供的支持很少，可能会让你难以理解正在发生的事情。然而，就可伸缩性而言，一旦您能够理解 SMACSS 是如何工作的，您就会开始看到它的样式规则分类是如何帮助您扩展项目的。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们研究了两种广泛使用的 CSS 方法:BEM 和 SMACSS。无论您选择在项目中使用哪一个，您都将受益于更结构化的 CSS 和 UI 的优势。在我看来，两者都不突出；真的是看个人喜好了。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的 CPU？</h2><p>随着 web 前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端 CPU 使用情况、内存使用情况等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
 </article>

</div>    
</body>
</html>
<html>
<head>
<title>Designing a URL-based query syntax for GraphQL - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>为 GraphQL - LogRocket 博客设计基于 URL 的查询语法</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/#0001-01-01">https://blog.logrocket.com/designing-url-based-query-syntax-graphql/#0001-01-01</a></blockquote><div><article class="article-post">
<p>目前，如果我们想在 GraphQL 中使用 HTTP 缓存，我们必须使用支持持久化查询的 GraphQL 服务器。这是因为持久化查询已经在服务器中存储了 GraphQL 查询；因此，我们不需要在请求中提供这些信息。</p>
<p>为了让 GraphQL 服务器也通过单个端点支持 HTTP 缓存，GraphQL 查询必须作为 URL 参数提供。HTTP 上的<a href="https://github.com/graphql/graphql-over-http">GraphQL</a>规范有望实现这一目标，为所有 graph QL 客户端、服务器和库之间的交互提供一种标准化的语言。</p>
<p>不过，我怀疑所有通过 URL 参数传递 GraphQL 查询的尝试都不太理想。这是因为 URL 参数必须以单行值的形式提供，所以查询要么需要编码，要么需要重新格式化，这使得它很难理解(对于我们人类，而不是机器)。</p>
<p>例如，当用空格替换所有换行符以使其适合单行时，GraphQL 查询看起来是这样的:</p>
<pre>{ posts(limit:5) { id title @titleCase excerpt @default(value:"No title", condition:IS_EMPTY) author { name } tags { id name } comments(limit:3, order:"date|DESC") { id date(format:"d/m/Y") author { name } content } } }
</pre>
<p>你能理解它吗？我也没有。</p>
<p>这就是 GraphiQL 客户端将简单查询<code>{ posts { id title } }</code>编码为 URL 参数的方式:</p>
<pre>%7B%0A%20%20posts%20%7B%0A%20%20%20%20id%0A%20%20%20%20title%0A%20%20%7D%0A%7D
</pre>
<p>再说一次，我们不知道这里发生了什么。</p>
<p>这两个例子都表明了这个问题:单行 GraphQL 查询从技术角度来看可以工作，将信息传输到服务器，但是人们不容易读取和编写这些查询。</p>
<p>能够使用单行查询有很多好处。例如，我们可以直接在浏览器的地址栏中编写查询，而不需要一些 GraphQL 客户端。</p>
<p>这并不是说我不喜欢 GraphQL 客户端——事实上，我喜欢 graph QL。但是我不喜欢依赖他们的想法。</p>
<p>换句话说，我们可以受益于一种查询语法，它允许人们:</p>
<ul>
<li>直接在一行中编写查询</li>
<li>一目了然地理解单行查询</li>
</ul>
<p>这是一个艰巨的挑战。但这并不是不可克服的。</p>
<p>在本文中，我将介绍一种替代语法，它支持我们人类“在一行中轻松地读写”。</p>
<p>我并不是真的建议在 GraphQL 中引入这种语法——我知道这永远不会发生。但是这种语法的设计过程仍然可以作为我们在设计 GraphQL over HTTP 规范时必须注意的例子。</p>
<h2>为什么 GraphQL 语法在一行中如此难以理解？</h2>
<p>让我们首先探索 GraphQL 语法的问题，然后将其推广到其他语法。</p>
<h3>识别问题</h3>
<p>在我看来，困难在于 GraphQL 查询中的字段是嵌套的，其中嵌套可以在整个查询中前进和后退。正是这种来来去去的行为使得用单行书写时很难理解。</p>
<p>如果查询中的嵌套只是向前推进，那么理解它并不困难。以这个查询为例:</p>
<pre>{
  posts {
    id
    title
    excerpt
    comments {
      id
      date
      content
      author {
        id
        name
        url
        posts {
          id
          title
        }
      }
    }
  }
}
</pre>
<p>在这里，嵌套只能向前进行:</p>
<figure id="attachment_54195" aria-describedby="caption-attachment-54195" class="wp-caption aligncenter"><img data-attachment-id="54195" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/graphql-nesting/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting.png" data-orig-size="360,547" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graphql nesting" data-image-description="" data-image-caption="&lt;p&gt;GraphQL query, advancing only.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting-197x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting.png" decoding="async" class="size-full wp-image-54195 jetpack-lazy-image" src="../Images/f0924c8a48927c154a764a93b1d91892.png" alt="Nesting Code Is Moving Forward " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting.png 360w, https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting-197x300.png 197w" data-lazy-sizes="(max-width: 360px) 100vw, 360px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="54195" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/graphql-nesting/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting.png" data-orig-size="360,547" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graphql nesting" data-image-description="" data-image-caption="&lt;p&gt;GraphQL query, advancing only.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting-197x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting.png" decoding="async" loading="lazy" class="size-full wp-image-54195" src="../Images/f0924c8a48927c154a764a93b1d91892.png" alt="Nesting Code Is Moving Forward " srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting.png 360w, https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting-197x300.png 197w" sizes="(max-width: 360px) 100vw, 360px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/graphql-nesting.png"/></noscript><figcaption id="caption-attachment-54195" class="wp-caption-text">GraphQL query, advancing only.</figcaption></figure>
<p>当查看总是向前的查询并从左向右扫描时，我们仍然可以理解每个字段属于哪个实体:</p>
<pre>{ posts { id title excerpt comments { id date content author { id name url posts { id title } } } } }
</pre>
<p>现在，考虑同一个 GraphQL 查询，但是重新排列了字段，使得叶子出现在连接之后:</p>
<pre>{
  posts {
    id
    comments {
      id
      date
      author {
        posts {
          id
          title
        }
        id
        name
        url
      }
      content
    }
    title
    excerpt
  }
}
</pre>
<p>在这种情况下，我们可以说，场前进，也后退:</p>
<figure id="attachment_54198" aria-describedby="caption-attachment-54198" class="wp-caption aligncenter"><img data-attachment-id="54198" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/nesting-code-advancing-retreating/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating.png" data-orig-size="360,547" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Nesting code advancing retreating" data-image-description="" data-image-caption="&lt;p&gt;GraphQL query, advancing and retreating.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating-197x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating.png" decoding="async" class="size-full wp-image-54198 jetpack-lazy-image" src="../Images/3af66334b1d01c1862cdfb07c29e87b7.png" alt="GraphQL Code Starts Moving Forward Then It Begins Moving Backwards" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating.png 360w, https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating-197x300.png 197w" data-lazy-sizes="(max-width: 360px) 100vw, 360px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="54198" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/nesting-code-advancing-retreating/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating.png" data-orig-size="360,547" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Nesting code advancing retreating" data-image-description="" data-image-caption="&lt;p&gt;GraphQL query, advancing and retreating.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating-197x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating.png" decoding="async" loading="lazy" class="size-full wp-image-54198" src="../Images/3af66334b1d01c1862cdfb07c29e87b7.png" alt="GraphQL Code Starts Moving Forward Then It Begins Moving Backwards" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating.png 360w, https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating-197x300.png 197w" sizes="(max-width: 360px) 100vw, 360px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/nesting-code-advancing-retreating.png"/></noscript><figcaption id="caption-attachment-54198" class="wp-caption-text">GraphQL query, advancing and retreating.</figcaption></figure>
<p>该查询可以写成一行，如下所示:</p>
<pre>{ posts { id comments { id date author { posts { id title } id name url } content } title excerpt } }
</pre>
<p>现在，理解查询不再那么容易了。在后退一级后(即，紧接在一个连接之后)，我们可能不记得哪个实体在它之前，所以我们不会掌握字段属于哪里:</p>
<figure id="attachment_54200" aria-describedby="caption-attachment-54200" class="wp-caption aligncenter"><img data-attachment-id="54200" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/code-written-single-line/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line.png" data-orig-size="640,111" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Code written single line" data-image-description="" data-image-caption="&lt;p&gt;To what entity do these fields belong to?&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line.png" decoding="async" class="size-full wp-image-54200 jetpack-lazy-image" src="../Images/b798312c79179bea4e31faa49c8d5e36.png" alt="GraphQL Code Written In A Single Line" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line.png 640w, https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line-300x52.png 300w" data-lazy-sizes="(max-width: 640px) 100vw, 640px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="54200" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/code-written-single-line/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line.png" data-orig-size="640,111" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Code written single line" data-image-description="" data-image-caption="&lt;p&gt;To what entity do these fields belong to?&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line-300x52.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line.png" decoding="async" loading="lazy" class="size-full wp-image-54200" src="../Images/b798312c79179bea4e31faa49c8d5e36.png" alt="GraphQL Code Written In A Single Line" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line.png 640w, https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line-300x52.png 300w" sizes="(max-width: 640px) 100vw, 640px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/code-written-single-line.png"/></noscript><figcaption id="caption-attachment-54200" class="wp-caption-text">To what entity do these fields belong to?</figcaption></figure>
<p>(我猜这与人类大脑的短期记忆有限有关，一次只能保存不超过几个项目。)</p>
<p>而当前进和后退有很多层次时，那么完全掌握就变得相当不可能了。这个疑问是可以理解的:</p>
<pre>{
  posts {
    id
    comments {
      id
      date
      children {
        id
        author {
          name
          url
        }
        content
      }
      author {
        posts {
          id
          title
          tags {
            name
          }
        }
        id
        name
        friends {
          id
          name
        }
        url
      }
      content
    }
    title
    excerpt
  }
  author {
    name
  }
}
</pre>
<p>但是我们无法理解它的单行等价物:</p>
<pre>{ posts { id comments { id date children { id author { name url } content } author { posts { id title tags { name } } id name friends { id name } url } content } title excerpt } author { name } }
</pre>
<p>总之，由于它的嵌套行为，GraphQL 查询不能简单地用一行代码来表示，以至于我们人类不能理解它。</p>
<h3>概括问题</h3>
<p>该问题并不是 GraphQL 特有的。事实上，对于一种语法——任何语法——元素进退都会发生这种情况。</p>
<p>以 JSON 为例:</p>
<pre>{
  "name": "leoloso/PoP",
  "description": "PoP monorepo",
  "repositories": [
    {
      "type": "package",
      "package": {
        "name": "leoloso-pop-api-wp/newsletter-subscriptions-rest-endpoints",
        "version": "master",
        "type": "wordpress-plugin",
        "source": {
          "url": "https://gist.github.com/leoloso/6588f6c1bdcce82fc317052616d3dfb4",
          "type": "git",
          "reference": "master"
        }
      }
    },
    {
      "type": "package",
      "package": {
        "name": "leoloso-pop-api-wp/disable-user-edit-profile",
        "version": "0.1.1",
        "type": "wordpress-plugin",
        "source": {
          "url": "https://gist.github.com/leoloso/4e367eb8d8014a7aa7580567608bd5b4",
          "type": "git",
          "reference": "master"
        }
      }
    },
    {
      "type": "vcs",
      "url": "https://github.com/leoloso/wp-muplugin-loader.git"
    }
  ],
  "minimum-stability": "dev",
  "prefer-stable": true,
  "require": {
    "php": "~8.0",
    "getpop/api-rest": "dev-master",
    "getpop/engine-wp-bootloader": "dev-master"
  },
  "extra": {
    "branch-alias": {
      "dev-master": "1.0-dev"
    },
    "installer-types": [
      "graphiql-client",
      "graphql-voyager"
    ],
    "installer-paths": {
      "wordpress/wp-content/mu-plugins/{$name}/": [
        "type:wordpress-muplugin"
      ],
      "wordpress/wp-content/plugins/{$name}/": [
        "type:wordpress-plugin",
        "getpop/engine-wp-bootloader"
      ]
    }
  },
  "config": {
    "sort-packages": true
  }
}
</pre>
<p>把它转换成一句话，真的很难理解:</p>
<pre>{ "name": "leoloso/PoP", "description": "PoP monorepo", "repositories": [ { "type": "package", "package": { "name": "leoloso-pop-api-wp/newsletter-subscriptions-rest-endpoints", "version": "master", "type": "wordpress-plugin", "source": { "url": "https://gist.github.com/leoloso/6588f6c1bdcce82fc317052616d3dfb4", "type": "git", "reference": "master" } } }, { "type": "package", "package": { "name": "leoloso-pop-api-wp/disable-user-edit-profile", "version": "0.1.1", "type": "wordpress-plugin", "source": { "url": "https://gist.github.com/leoloso/4e367eb8d8014a7aa7580567608bd5b4", "type": "git", "reference": "master" } } }, { "type": "vcs", "url": "https://github.com/leoloso/wp-muplugin-loader.git" } ], "minimum-stability": "dev", "prefer-stable": true, "require": { "php": "~8.0", "getpop/api-rest": "dev-master", "getpop/engine-wp-bootloader": "dev-master" }, "extra": { "branch-alias": { "dev-master": "1.0-dev" }, "installer-types": [ "graphiql-client", "graphql-voyager" ], "installer-paths": { "wordpress/wp-content/mu-plugins/{$name}/": [ "type:wordpress-muplugin" ], "wordpress/wp-content/plugins/{$name}/": [ "type:wordpress-plugin", "getpop/engine-wp-bootloader" ] } }, "config": { "sort-packages": true } } 
</pre>
<p>更重要的是，当语法使用空格来嵌套其元素时，甚至不可能将它写在一行中。</p>
<p>例如，YAML 就是这种情况:</p>
<pre>services:
  _defaults:
    public: true
    autowire: true
    autoconfigure: true

  PoP\API\PersistedQueries\PersistedQueryManagerInterface:
    class: \PoP\API\PersistedQueries\PersistedQueryManager

  # Override the service
  PoP\ComponentModel\Schema\FieldQueryInterpreterInterface:
    class: \PoP\API\Schema\FieldQueryInterpreter

  PoP\API\Hooks\:
    resource: '../src/Hooks/*' 
</pre>
<h2>设计不同的查询语法</h2>
<p>我将描述 GraphQL 语法的替代设计:GraphQL by PoP(我编写的 PHP 中的 GraphQL 服务器)使用的<a href="https://graphql-by-pop.com/docs/extended/pql.html"> PQL 语法</a>，接受通过<code>GET</code>传递的基于 URL 的查询。</p>
<p>由于 GraphQL 语法的问题是由退回嵌套字段引起的，所以解决方案似乎很明显:查询流必须总是向前的。</p>
<p>PQL 是如何做到这一点的？为了演示，让我们来探索 PQL 语法。</p>
<h3>字段语法</h3>
<p>在 GraphQL 中，一个字段是这样写的:</p>
<pre>{
  alias:fieldName(fieldArgs)@fieldDirective(directiveArgs)
}
</pre>
<p>在 PQL，一个字段是这样写的:</p>
<pre>fieldName(fieldArgs)[@alias]&lt;fieldDirective(directiveArgs)&gt;
</pre>
<p>两者非常相似，但也有一些不同之处:</p>
<ol>
<li>别名不是放在字段之前，而是放在字段之后</li>
<li>别名不是用<code>:</code>来标识的，而是用<code>@</code>来标识的(可选地，用<code>[...]</code>来表示“书签”，稍后解释)</li>
<li>该指令不是用<code>@</code>标识，而是用<code>&lt;...&gt;</code>包围</li>
</ol>
<p>这些差异与查询所需的总是向前的流直接相关。</p>
<p>在我自己的经验中，当直接在浏览器的地址栏中编写查询时，我总是在编写完字段名之后才想到需要别名，而不是在此之前。因此，使用 GraphQL 中的顺序，我必须返回到那个位置(按左箭头键)，添加别名，然后返回到最终位置(按右箭头键)。</p>
<p>那是相当麻烦的。将别名放在字段名之后更有意义，这是一种自然的流程。</p>
<p>当在字段名后定义别名时，使用<code>:</code>不再有意义。GraphQL 使用这个符号让 JSON 响应考虑查询的形状。一旦字段和别名之间的顺序颠倒，使用<code>@</code>似乎是一个自然的选择。</p>
<p>这反过来意味着我们不能再使用<code>@</code>来识别指令。相反，我选择了一个环绕语法<code>&lt;...&gt;</code>(例如<code>&lt;directiveName&gt;</code>)，这样指令也可以嵌套(例如<code>&lt;directive1&lt;directive2&gt;&gt;</code>)，使得 GraphQL by PoP 能够支持<a href="https://graphql-by-pop.com/docs/extended/pql-language-features.html#composable-directives">可组合指令</a>特性。</p>
<h3>菲尔茨</h3>
<p>在 GraphQL 中，我们可以通过在字段之间添加空格或换行符来添加两个或更多字段:</p>
<pre>{
  foo
  bar
}
</pre>
<p>在 PQL，我们使用字符<code>|</code>来分隔字段:</p>
<pre>foo|bar
</pre>
<p>我们已经可以看到查询是如何组成一行的:</p>
<ul>
<li>没有<code>{}</code>字符</li>
<li>没有空格或换行符</li>
</ul>
<p>我们还可以理解，查询可以直接在浏览器中编写，通过 URL param <code>query</code>传递。</p>
<p>例如，执行查询<code>id|__typename</code>的 URL 是:<a href="https://nextapi.getpop.org/api/graphql/?query=id%7C__typename"> ${endpoint}？query=id|__typename </a></p>
<p>使用 DevTools，我们可以看到 GraphQL 单端点是如何支持 HTTP 缓存的:</p>
<figure id="attachment_54203" aria-describedby="caption-attachment-54203" class="wp-caption aligncenter"><img data-attachment-id="54203" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/devtool-http-graphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql.png" data-orig-size="730,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Devtool http graphql" data-image-description="" data-image-caption="&lt;p&gt;HTTP caching for the GraphQL single endpoint.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql-300x231.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql.png" decoding="async" class="size-full wp-image-54203 jetpack-lazy-image" src="../Images/6b9fb9cc316f0492388553d2f3aee22f.png" alt="DevTool Website Inspecting HTTP Caching For GraphQL" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql-300x231.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="54203" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/devtool-http-graphql/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql.png" data-orig-size="730,562" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Devtool http graphql" data-image-description="" data-image-caption="&lt;p&gt;HTTP caching for the GraphQL single endpoint.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql-300x231.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql.png" decoding="async" loading="lazy" class="size-full wp-image-54203" src="../Images/6b9fb9cc316f0492388553d2f3aee22f.png" alt="DevTool Website Inspecting HTTP Caching For GraphQL" srcset="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql-300x231.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/devtool-http-graphql.png"/></noscript><figcaption id="caption-attachment-54203" class="wp-caption-text">HTTP caching for the GraphQL single endpoint.</figcaption></figure>
<p>对于下面演示的所有查询，将有一个链接<em>在浏览器</em>中执行查询。点击它们可以看到 PQL 是如何在实际生产现场工作的。</p>
<h3>使查询具有视觉吸引力</h3>
<p>与 GraphQL 类似，换行符(以及空格)不增加语义。因此，我们可以方便地添加换行符来帮助可视化查询:</p>
<pre>foo|
bar
</pre>
<p>当使用 Firefox 时，这个查询可以被复制(从文本编辑器、网页等)。)并粘贴到浏览器的地址栏中，所有换行符将被自动删除，从而创建等效的单行查询。</p>
<p><img data-attachment-id="54897" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/pql-copy-paste/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-copy-paste.gif" data-orig-size="730,469" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Copy/pasting the query into Firefox" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-copy-paste-300x193.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-copy-paste.gif" decoding="async" class="aligncenter size-full wp-image-54897 jetpack-lazy-image" src="../Images/636a712002e9b38c0e21e9f45a367b20.png" alt="Copy/pasting the Single-line Query Into Firefox" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-copy-paste.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-copy-paste.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="54897" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/pql-copy-paste/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-copy-paste.gif" data-orig-size="730,469" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Copy/pasting the query into Firefox" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-copy-paste-300x193.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-copy-paste.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-54897" src="../Images/636a712002e9b38c0e21e9f45a367b20.png" alt="Copy/pasting the Single-line Query Into Firefox" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-copy-paste.gif"/></noscript>
<h3>连接</h3>
<p>GraphQL 使用字符<code>{}</code>来定义连接数据:</p>
<pre>{
  posts {
    author {
      id
    }
  }
}
</pre>
<p>在 PQL，质疑只有前进，没有后退。所以对于<code>{</code>有一个等价的，也就是<code>.</code>，但是对于<code>}</code>没有等价的，因为它不需要。</p>
<pre>posts.
  author.
    id
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.author.id"> <em>在</em> </a>浏览器中执行查询。</p>
<p>我们可以组合<code>|</code>和<code>.</code>来为任何实体获取多个字段。考虑这个 GraphQL 查询:</p>
<pre>{
  posts {
    id
    title
    author {
      id
      name
      url
    }
  }
}
</pre>
<p>它在 PQL 的对等词是:</p>
<pre>posts.
  id|
  title|
  author.
    id|
    name|
    url
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.id%7Ctitle%7Cauthor.id%7Cname%7Curl"> <em>在</em> </a>浏览器中执行查询。</p>
<p>在这一点上，我们可以面对挑战:PQL 如何只接受前进领域？</p>
<h3>仅前进流的语法</h3>
<p>上面看到的查询总是在前进。现在让我们来处理同样需要退回的查询，比如这个 GraphQL 查询:</p>
<pre>{
  posts {
    id
    author {
      id
      name
      url
    }
    comments {
      id
      content
    }
  }
}
</pre>
<p>PQL 使用字符<code>,</code>来连接元素。它类似于连接字段的<code>|</code>,但是有一个基本的区别:<code>,</code>右边的字段从根开始再次遍历图。</p>
<p>然后，上面的查询在 PQL 有这样的等价物:</p>
<pre>posts.
  id|
  author.
    id|
    name|
    url,
posts.
  comments.
    id|
    content
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.id%7Cauthor.id%7Cname%7Curl,posts.comments.id%7Ccontent"> <em>在</em> </a>浏览器中执行查询。</p>
<p>注意，为了在视觉上吸引人，<code>name|</code>和<code>url</code>的左边有相同的填充，因为<code>|</code>保持它们相同的路径<code>posts.author.</code>。但是在<code>,</code>之后没有左填充，因为查询是从根开始的。</p>
<p>我们可能会认为这个查询也确实后退了:</p>
<figure id="attachment_54208" aria-describedby="caption-attachment-54208" class="wp-caption aligncenter"><img data-attachment-id="54208" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/pql-query-advance-retreat/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-query-advance-retreat.png" data-orig-size="300,281" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Pql query advance retreat" data-image-description="" data-image-caption="&lt;p&gt;Advancing and retreating query in PQL.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-query-advance-retreat.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-query-advance-retreat.png" decoding="async" class="size-full wp-image-54208 jetpack-lazy-image" src="../Images/747bc87bb8f04c631079d4bdd84721ed.png" alt="Code In PQL Is Moving Forward Then Backwards Then Forward" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-query-advance-retreat.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-query-advance-retreat.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="54208" data-permalink="https://blog.logrocket.com/designing-url-based-query-syntax-graphql/pql-query-advance-retreat/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-query-advance-retreat.png" data-orig-size="300,281" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Pql query advance retreat" data-image-description="" data-image-caption="&lt;p&gt;Advancing and retreating query in PQL.&lt;/p&gt;&#10;" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-query-advance-retreat.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-query-advance-retreat.png" decoding="async" loading="lazy" class="size-full wp-image-54208" src="../Images/747bc87bb8f04c631079d4bdd84721ed.png" alt="Code In PQL Is Moving Forward Then Backwards Then Forward" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/06/pql-query-advance-retreat.png"/></noscript><figcaption id="caption-attachment-54208" class="wp-caption-text">Advancing and retreating query in PQL.</figcaption></figure>
<p>然而，这与其说是撤退，不如说是“重置”。在 GraphQL 中，我们可以返回到查询中的前一个位置——即图中的父节点——与我们遍历的级别一样多。然而在 PQL，我们不能:我们总是一路回溯到图的根。</p>
<p>再次从根开始，我们必须再次指定节点的完整路径，以继续添加字段。这使得查询更加冗长。例如，上面查询中的<code>posts</code>路径在 GraphQL 中出现了一次，但在 PQL 中出现了两次。</p>
<p>这种冗余迫使我们人类在为图中的每一层读写查询时重新创建路径。这样做可以让我们理解用单行表达的查询:</p>
<pre>posts.id|author.id|name|url,posts.comments.id|content
</pre>
<p>因为我们在头脑中重新创建了路径，所以我们不会遭受短期内存问题，这种问题会导致我们在查看 GraphQL 查询时迷失方向。</p>
<h3>移除冗长的书签</h3>
<p>不得不重新创建到节点的整个路径可能会变得很麻烦。</p>
<p>考虑这个 GraphQL 查询:</p>
<pre>{
  users {
    posts {
      author {
        id
        name
      }
      comments {
        id
        content
      }
    }
  }
}
</pre>
<p>和 PQL 的同类组织:</p>
<pre>users.
  posts.
    author.
      id|
      name,
users.
  posts.
    comments.
      id|
      content
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=users.posts.author.id%7Cname,users.posts.comments.id%7Ccontent"> <em>在</em> </a>浏览器中执行查询。</p>
<p>为了检索<code>comments</code>字段，我们再次需要添加<code>users.posts.</code>。图表越往下，复制的路径就越长。</p>
<p>为了解决这个问题，PQL 引入了一个新概念:“书签”，它提供了一个已经遍历过的路径的快捷方式，这样我们就可以方便地从那个点继续加载数据。</p>
<p>我们定义了一个书签，当遍历某个路径时，用<code>[...]</code>将它的名字括起来，然后当引用它的书签时，这个路径被自动检索，再次用<code>[...]</code>将它的名字括起来，从查询的根开始。</p>
<p>在上面的查询中，我们可以将<code>users.posts</code>标记为<code>[userposts]</code>:</p>
<pre>users.
  posts[userposts].
    author.
      id|
      name,
[userposts].
  comments.
    id|
    content
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=users.posts%5Buserposts%5D.author.id%7Cname,%5Buserposts%5D.comments.id%7Ccontent"> <em>在</em> </a>浏览器中执行查询。</p>
<p>为了更容易可视化，我们还可以在应用的书签的左侧添加等效的填充，匹配其路径的相同填充(以便<code>comments</code>出现在<code>posts</code>下面):</p>
<pre>users.
  posts[userposts].
    author.
      id|
      name,
  [userposts].
    comments.
      id|
      content
</pre>
<p>有了书签，我们仍然可以理解用单行表达的查询:</p>
<pre>users.posts[userposts].author.id|name,[userposts].comments.id|content
</pre>
<p>如果我们需要定义书签和别名，我们可以在<code>[...]</code>中嵌入<code>@</code>符号:</p>
<pre>users.
  posts[@userposts].
    author.
      id|
      name,
  [userposts].
    comments.id|
    content
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=users.posts%5B@userposts%5D.author.id%7Cname,%5Buserposts%5D.comments.id%7Ccontent"> <em>在</em> </a>浏览器中执行查询。</p>
<h3>简化字段参数</h3>
<p>在 GraphQL 中，字段参数中的<code>String</code>值必须用引号<code>"..."</code>括起来:</p>
<pre>{
  posts {
    id
    title
    date(format: "d/m/Y")
  }
}
</pre>
<p>事实证明，在浏览器中编写查询时必须键入这些引号非常烦人；我经常会忘记它们，然后不得不用箭头键左右导航来添加它们。</p>
<p>因此，在 PQL，字符串引号可以省略:</p>
<pre>posts.
  id|
  title|
  date(format:d/m/Y)
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.id%7Ctitle%7Cdate(format:d/m/Y)"> <em>在</em> </a>浏览器中执行查询。</p>
<p>当查询会被中断时，字符串引号是必需的:</p>
<pre>posts.
  id|
  title|
  date(format:"d M, Y")
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.id%7Ctitle%7Cdate(format:%22d%20M,%20Y%22)"> <em>在</em> </a>浏览器中执行查询。</p>
<p>此外，字段参数有时可能是隐式的；例如，当字段只有一个字段参数时。在这种情况下，PQL 允许省略它:</p>
<pre>posts.
  id|
  title|
  date(d/m/Y)
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.id%7Ctitle%7Cdate(d/m/Y)"> <em>在</em> </a>浏览器中执行查询。</p>
<h3>变量</h3>
<p>在 GraphQL 中，<a href="https://graphql.org/learn/queries/#variables">变量在请求</a>的主体中被定义为编码的 JSON:</p>
<pre>{
  "query":"query ($format: String) {
    posts {
      id
      title
      date(format: $format)
    }
  }",
  "variables":"{
    \"format\":\"d/m/Y\"
  }"
}
</pre>
<p>相反，PQL 使用 HTTP 标准输入，通过<code>$_GET</code>或<code>$_POST</code>传递变量:</p>
<pre>?query=
  posts.
    id|
    title|
    date($format)
&amp;format=d/m/Y
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.id%7Ctitle%7Cdate(%24format)&amp;format=d/m/Y"> <em>在</em> </a>浏览器中执行查询。</p>
<p>我们也可以在输入<code>variables</code>下传递变量:</p>
<pre>?query=
  posts.
    id|
    title|
    date($format)
&amp;variables[format]=d/m/Y
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.id%7Ctitle%7Cdate(%24format)&amp;variables%5Bformat%5D=d/m/Y"> <em>在</em> </a>浏览器中执行查询。</p>
<h3>碎片</h3>
<p>GraphQL 使用片段来重用查询部分:</p>
<pre>{
  users {
    ...userData
    posts {
      comments {
        author {
          ...userData
        }
      }
    }
  }
}

fragment userData on User {
  id
  name
  url
}
</pre>
<p>在 PQL，片段遵循与定义变量相同的方法:作为<code>$_GET</code>或<code>$_POST</code>的输入。它们被引用为<code>--</code>:</p>
<pre>?query=
  users.
    --userData|
    posts.
      comments.
        author.
          --userData
&amp;userData=
  id|
  name|
  url
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=users.--userData%7Cposts.comments.author.--userData&amp;userData=id%7Cname%7Curl"> <em>在</em> </a>浏览器中执行查询。</p>
<p>该片段也可以在输入<code>fragments</code>下定义:</p>
<pre>?query=
  users.
    --userData|
    posts.
      comments.
        author.
          --userData
&amp;fragments[userData]=
  id|
  name|
  url
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=users.--userData%7Cposts.comments.author.--userData&amp;fragments%5BuserData%5D=id%7Cname%7Curl"> <em>在</em> </a>浏览器中执行查询。</p>
<h2>在 GraphQL 和 PQL 语法之间转换查询</h2>
<p>PQL 是 GraphQL 查询语法的超集。因此，使用标准 GraphQL 语法编写的任何查询也可以用 PQL 语言编写。</p>
<p>相反，并不是用 PQL 编写的每个查询都可以用 GraphQL 语法编写，因为 PQL 支持 GraphQL 不支持的特性，如<a href="https://graphql-by-pop.com/docs/extended/pql-language-features.html#composable-fields">可组合字段</a>和<a href="https://graphql-by-pop.com/docs/extended/pql-language-features.html#composable-directives">可组合指令</a>。</p>
<p>PQL 包含了大部分相同的元素:</p>
<ul>
<li>字段和字段参数</li>
<li>指令和指令参数</li>
<li>别名</li>
<li>碎片</li>
<li>变量</li>
</ul>
<p>它不支持的元素有:</p>
<ul>
<li>操作</li>
<li>操作名称、变量定义和默认变量</li>
<li><code>on</code>元素，指示一个片段必须应用在什么类型/接口上</li>
</ul>
<p>尽管这些元素不受支持，但它们的底层功能通过不同的方法得到支持。</p>
<p>因为不再需要它，所以该操作被遗漏了:我们现在可以选择使用<code>GET</code>(对于查询)或<code>POST</code>(对于突变)来请求查询。</p>
<p>只有当文档包含许多操作时，GraphQL 中才需要操作名，我们需要指定执行哪个操作，或者可能一起执行几个操作，通过<code>@export</code>将它们联系起来。</p>
<p>在前一个例子中，PQL 不需要它——我们只传递必须执行的查询，而不是所有的查询。</p>
<p>在后一种情况下，多个操作可以在一个请求中一起执行，同时保证它们的执行顺序，<a href="https://github.com/leoloso/PoP/blob/master/layers/Engine/packages/field-query/README.md#appending-fields-with-strict-execution-order">通过用<code>;</code> </a>连接它们，如下所示:</p>
<pre>posts.
  author.
    id|
    name|
    url;

posts.
  comments.
    id|
    content
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.author.id%7Cname%7Curl;posts.comments.id%7Ccontent"> <em>在</em> </a>浏览器中执行查询。</p>
<p>在 GraphQL 中，变量定义用于定义变量的类型，使 graph QL 这样的客户端能够在类型不同时显示错误。这是一个不错的选择，但是对于执行查询本身来说并不是真正需要的。</p>
<p>默认变量值可以像任何变量一样定义:通过 URL 参数。</p>
<p>不需要<code>on</code>元素，因为我们可以使用指令<code>@include</code>，传递一个可组合字段<code>isType</code>作为参数，找出对象的类型，并基于这个值，应用或不应用想要的片段。</p>
<p>例如，以这个 GraphQL 查询为例:</p>
<pre>{
  customPosts {
    __typename
    ... on Post {
      title
    }
  }
}
</pre>
<p>这相当于 PQL:</p>
<pre>customPosts.
  __typename|
  title&lt;include(if:isType(Post))&gt;
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=customPosts.__typename%7Ctitle%3Cinclude(if:isType(Post))%3E"> <em>在</em> </a>浏览器中执行查询。</p>
<h2>转换自检查询</h2>
<p>让我们将 GraphQL(和其他客户机)用来获取模式元数据的自省查询从 graph QL 语法转换为 PQL 语法。</p>
<p>自检查询是<a href="https://gist.github.com/leoloso/4adf5c565789d43e2879bb3787af9329">这个</a>:</p>
<pre>query IntrospectionQuery {
  __schema {
    queryType {
      name
    }
    mutationType {
      name
    }
    subscriptionType {
      name
    }
    types {
      ...FullType
    }
    directives {
      name
      description
      locations
      args {
        ...InputValue
      }
    }
  }
}

fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args {
      ...InputValue
    }
    type {
      ...TypeRef
    }
    isDeprecated
    deprecationReason
  }
  inputFields {
    ...InputValue
  }
  interfaces {
    ...TypeRef
  }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes {
    ...TypeRef
  }
}

fragment InputValue on __InputValue {
  name
  description
  type {
    ...TypeRef
  }
  defaultValue
}

fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
              }
            }
          }
        }
      }
    }
  }
}
</pre>
<p>它的等价 PQL 查询是这样的:</p>
<pre>?query=
    __schema[schema].
        queryType.
            name,
    [schema].
        mutationType.
            name,
    [schema].
        subscriptionType.
            name,
    [schema].
        types.
            --FullType,
    [schema].
        directives.
            name|
            description|
            locations|
            args.
                --InputValue
&amp;fragments[FullType]=
    kind|
    name|
    description|
    fields(includeDeprecated: true)[@fields].
        name|
        description|
        args.
            --InputValue,
    [fields].
        type.
            --TypeRef,
    [fields].
        isDeprecated|
        deprecationReason,
    [fields].
        inputFields.
            --InputValue,
    [fields].
        interfaces.
            --TypeRef,
    [fields].
        enumValues(includeDeprecated: true)@enumValues.
            name|
            description|
            isDeprecated|
            deprecationReason,
    [fields].
        possibleTypes.
            --TypeRef
&amp;fragments[InputValue]=
    name|
    description|
    defaultValue|
    type.
        --TypeRef
&amp;fragments[TypeRef]=
    kind|
    name|
    ofType.
        kind|
        name|
        ofType.
            kind|
            name|
            ofType.
                kind|
                name|
                ofType.
                    kind|
                    name|
                    ofType.
                        kind|
                        name|
                        ofType.
                            kind|
                            name|
                            ofType.
                                kind|
                                name
</pre>
<p><em> <a href="https://nextapi.getpop.org/api/graphql/?query=__schema%5Bschema%5D.queryType.name,%5Bschema%5D.mutationType.name,%5Bschema%5D.subscriptionType.name,%5Bschema%5D.types%5B@schemaTypes%5D.--FullType,--FullType_fields1,--FullType_fields2,--FullType_schemaTypes1,--FullType_schemaTypes2,--FullType_schemaTypes3,--FullType_schemaTypes4,%5Bschema%5D.directives.name%7Cdescription%7Clocations%7Cargs.--InputValue&amp;fragments%5BFullType%5D=kind%7Cname%7Cdescription%7Cfields(includeDeprecated:%20true)%5B@fields%5D.name%7Cdescription%7Cargs.--InputValue&amp;fragments%5BFullType_fields1%5D=%5Bfields%5D.type.--TypeRef&amp;fragments%5BFullType_fields2%5D=%5Bfields%5D.isDeprecated%7CdeprecationReason&amp;fragments%5BFullType_schemaTypes1%5D=%5BschemaTypes%5D.inputFields.--InputValue&amp;fragments%5BFullType_schemaTypes2%5D=%5BschemaTypes%5D.interfaces.--TypeRef&amp;fragments%5BFullType_schemaTypes3%5D=%5BschemaTypes%5D.enumValues(includeDeprecated:%20true)@enumValues.name%7Cdescription%7CisDeprecated%7CdeprecationReason&amp;fragments%5BFullType_schemaTypes4%5D=%5BschemaTypes%5D.possibleTypes.--TypeRef&amp;fragments%5BInputValue%5D=name%7Cdescription%7CdefaultValue%7Ctype.--TypeRef&amp;fragments%5BTypeRef%5D=kind%7Cname%7CofType.kind%7Cname%7CofType.kind%7Cname%7CofType.kind%7Cname%7CofType.kind%7Cname%7CofType.kind%7Cname%7CofType.kind%7Cname%7CofType.kind%7Cname">在浏览器中执行查询</a>。(注意，这个链接中的查询与上面的略有不同，因为我仍然需要<a href="https://github.com/leoloso/PoP/issues/655">在片段</a>中添加对<code>,</code>标记的支持。)</em></p>
<p>这是用一行代码编写的查询:</p>
<pre>?query=__schema[schema].queryType.name,[schema].mutationType.name,[schema].subscriptionType.name,[schema].types.--FullType,[schema].directives.name|description|locations|args.--InputValue&amp;fragments[FullType]=kind|name|description|fields(includeDeprecated: true)[@fields].name|description|args.--InputValue,[fields].type.--TypeRef,[fields].isDeprecated|deprecationReason,[fields].inputFields.--InputValue,[fields].interfaces.--TypeRef,[fields].enumValues(includeDeprecated: true)@enumValues.name|description|isDeprecated|deprecationReason,[fields].possibleTypes.--TypeRef&amp;fragments[InputValue]=name|description|defaultValue|type.--TypeRef&amp;fragments[TypeRef]=kind|name|ofType.kind|name|ofType.kind|name|ofType.kind|name|ofType.kind|name|ofType.kind|name|ofType.kind|name|ofType.kind|name
</pre>
<h2>更多的例子</h2>
<p>该查询有一个包含嵌套路径、变量、指令和其他片段的片段:</p>
<pre>?query=
  posts(limit:$limit, order:$order).
    --postData|
    author.
      posts(limit:$limit).
        --postData
&amp;postData=
  id|
  title|
  --nestedPostData|
  date(format:$format)
&amp;nestedPostData=
  comments&lt;include(if:$include)&gt;.
    id|
    content
&amp;format=d/m/Y
&amp;include=true
&amp;limit=3
&amp;order=title
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts(limit:%24limit).--postData%7Cauthor.posts(limit:%24limit).--postData&amp;postData=id%7Ctitle%7C--nestedPostData%7Cdate(format:%24format)&amp;nestedPostData=comments%3Cinclude(if:%24include)%3E.id%7Ccontent&amp;format=d/m/Y&amp;include=true&amp;limit=3"> <em>在</em> </a>浏览器中执行查询。</p>
<p>该查询将一个指令应用于一个片段，该指令随后应用于该片段中的所有字段:</p>
<pre>?query=
  posts.
    id|
    --props&lt;include(if:hasComments())&gt;
&amp;fragments[props]=
  title|
  date
</pre>
<p><a href="https://nextapi.getpop.org/api/graphql/?query=posts.id%7C--props%3Cinclude(if:hasComments())%3E&amp;fragments%5Bprops%5D=title%7Cdate"> <em>在</em> </a>浏览器中执行查询。</p>
<p>最后，在这篇博文的<a href="https://leoloso.com/posts/graphql-query-in-a-single-line/">中，有许多单行查询的例子，它们直接作为 URL 参数嵌入，并包含来自 PQL 语法的附加属性(本文中没有描述)。</a></p>
<h2>结论</h2>
<p>为了支持 HTTP 缓存，我们目前必须使用支持持久查询的 GraphQL 服务器。</p>
<p>但是 GraphQL 单端点呢？它也能支持 HTTP 缓存吗？如果是这样的话，是否可以让人们编写查询，而不是依赖于客户端或库？</p>
<p>对这些问题的回答是:是的，可以做到。然而，由于其嵌套行为，GraphQL 语法目前处于阻碍地位。</p>
<p>在本文中，我演示了一种替代语法，称为 PQL，它使 GraphQL 服务器能够通过 URL 参数接受查询，同时使人们能够在一行中读写查询，甚至直接在浏览器的地址栏中。</p><div class="code-block code-block-24">
<div class="blog-plug inline-plug graphql-plug"><h2>监控生产中失败和缓慢的 GraphQL 请求</h2><p>虽然 GraphQL 有一些调试请求和响应的特性，但确保 GraphQL 可靠地为您的生产应用程序提供资源是一件比较困难的事情。如果您对确保对后端或第三方服务的网络请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-lazy-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/><noscript><img data-lazy-fallback="1" src="../Images/432a3823c85b3fb72a206e6236a29f48.png" data-original-src="https://files.readme.io/69aa835-Image_2019-11-09_at_1.28.05_PM.png"/></noscript><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><a href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录下你网站上发生的每一件事。您可以汇总并报告有问题的 GraphQL 请求，以快速了解根本原因，而不是猜测问题发生的原因。此外，您可以跟踪 Apollo 客户机状态并检查 GraphQL 查询的键值对。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/graphql-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>.</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
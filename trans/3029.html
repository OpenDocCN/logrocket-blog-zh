<html>
<head>
<title>Understanding React Native env variables - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>了解 React 本机环境变量</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/understanding-react-native-env-variables/#0001-01-01">https://blog.logrocket.com/understanding-react-native-env-variables/#0001-01-01</a></blockquote><div><article class="article-post">
<p>变量是编程语言的基本组成部分之一。在 JavaScript 中，变量存储整数、字符串等数据类型的值。变量的值或数据类型可以在以后更改。</p>
<p>在本文中，我们将了解环境变量，为什么它们有用，以及如何在 React Native 中使用它们。我们将涵盖:</p>

<h2 id="what-env-variable">什么是环境变量？</h2>
<p>变量可以在 React Native 中扮演不同的角色。例如，您可以<a href="https://blog.logrocket.com/using-css-variables-react-native/" target="“_blank”" rel="noreferrer noopener">在 React Native </a>中使用 CSS 变量来存储和实现自定义样式。</p>
<p>环境变量——或者众所周知的 env 变量——是一个其值在程序外部设置的变量。它是一个在构建时嵌入的变量，用于存储 API 端点、目录路径等信息。</p>
<p>如果您想减少代码中的重复或者更好地管理变量，使用 env 变量有助于减少代码。你所要做的就是在你的根文件夹中编写或者定义你的变量。然后，您可以在调用该变量之前将其导入组件中。</p>
<p>虽然 env 变量在 React Native 中非常有用，但不建议使用它们来存储敏感信息，如 API 密钥、身份验证密钥或密码。由于各种原因，它们并不安全。</p>
<p>例如，env 变量不加密它们的值。它们也被嵌入到应用程序的内部版本中，这意味着任何人都可以通过检查应用程序的文件来查看它们。</p>
<h3 id="different-env-files">不同的环境文件</h3>
<p>您可以决定使用不同的 env 文件作为您的 env 变量。这些不同的文件包括:</p>
<ul>
<li><code>.env</code> —用于存储开发、生产和测试变量的默认文件</li>
<li><code>.env.local</code> —覆盖除测试文件之外的所有环境文件(包括默认的<code>.env</code>文件)</li>
<li><code>.env.development</code> —特定于开发环境</li>
<li><code>.env.development.local</code> —覆盖<code>.env.development</code>环境文件</li>
<li><code>.env.production</code> —特定于生产环境</li>
<li><code>.env.production.local</code> —覆盖<code>.env.production</code>环境文件</li>
<li><code>.env.test</code> —特定于测试环境</li>
<li><code>.env.test.local</code> —覆盖<code>.env.test</code>环境文件</li>
</ul>
<p>总之，<code>.env.development</code>、<code>.env.production</code>和<code>.env.test</code>文件是特定于环境的文件。同时，<code>.env.development.local</code>、<code>.env.production.local</code>、<code>.env.test.local</code>文件是各自文件的本地覆盖。</p>
<p>如果没有明确指定环境设置，则使用默认的<code>.env</code>文件。</p>
<h3 id="priorities-env-files">环境文件的优先级</h3>
<p>在显式设置您的 env 文件之前，您应该了解机器处理不同 env 文件的重要性顺序。</p>
<p>让我们回顾一下当您运行<code>npm start</code>、<code>npm run build</code>或<code>npm test</code>时，这些文件是如何优先排序的。下面列表中的文件从左边的高优先级到右边的低优先级排列:</p>
<ul>
<li><code>npm start</code>:<code>.env.development.local</code>&gt;<code>.env.development</code>&gt;<code>.env.local</code>&gt;<code>.env</code></li>
<li><code>npm run build</code>:<code>.env.production.local</code>&gt;<code>.env.production</code>&gt;<code>.env.local</code>&gt;<code>.env</code></li>
<li><code>npm test</code> : <code>.env.test.local</code> &gt; <code>.env.test</code> &gt; <code>.env</code></li>
</ul>
<p>注意，测试环境中没有<code>.env.local</code>文件，因为测试环境不支持这种类型的文件。</p>
<h2 id="what-process-env">什么是<code>process.env</code>？</h2>
<p><code>process.env</code>是节点应用程序在运行时注入的全局变量。此变量显示了初始化期间应用程序环境的完整状态。</p>
<p>换句话说，<code>process.env</code>在运行时显示您的应用程序的环境，并允许您利用该环境。</p>
<p>属性返回一个包含用户环境的对象。这个环境包括用户的路径、术语、编辑器等等。</p>
<p>为了更好地理解，在您的应用程序中使用<code>process.env</code>上的<code>console.log()</code>,并检查您的控制台以查看它记录了什么。您应该会看到如下所示的内容:</p>
<p><img data-attachment-id="143948" data-permalink="https://blog.logrocket.com/understanding-react-native-env-variables/attachment/img1-logged-result-process-env/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env.png" data-orig-size="365,206" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Logged-result-process-env" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env.png" decoding="async" src="../Images/231ee6e0e736b86f5c6b17a446b3397a.png" alt="Dark Blue Background Displaying Result Of Process Env File Being Logged To Console With Full State Of Application's Environment Shown In List Format" class="aligncenter size-full wp-image-143948 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env.png 365w, https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env-300x169.png 300w" data-lazy-sizes="(max-width: 365px) 100vw, 365px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143948" data-permalink="https://blog.logrocket.com/understanding-react-native-env-variables/attachment/img1-logged-result-process-env/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env.png" data-orig-size="365,206" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Logged-result-process-env" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env-300x169.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env.png" decoding="async" loading="lazy" src="../Images/231ee6e0e736b86f5c6b17a446b3397a.png" alt="Dark Blue Background Displaying Result Of Process Env File Being Logged To Console With Full State Of Application's Environment Shown In List Format" class="aligncenter size-full wp-image-143948" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env.png 365w, https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env-300x169.png 300w" sizes="(max-width: 365px) 100vw, 365px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/img1-Logged-result-process-env.png"/></noscript>
<p>然而，在 React Native 中，<code>process.env</code>的一个<code>console.log</code>将只记录<code>"NODE_ENV"</code>并显示你的应用程序的环境，就像这样:</p>
<p><img data-attachment-id="143951" data-permalink="https://blog.logrocket.com/understanding-react-native-env-variables/attachment/img2-logged-result-process-env-react-native-development/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development.png" data-orig-size="730,53" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Logged-result-process-env-React-Native-development" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development-300x22.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development.png" decoding="async" src="../Images/563f2e15b91e000b64345df21da28de0.png" alt="Dark Maroon Background With Node Env And Development Environment Shown Logged To Console For Process Env" class="aligncenter size-full wp-image-143951 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development-300x22.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143951" data-permalink="https://blog.logrocket.com/understanding-react-native-env-variables/attachment/img2-logged-result-process-env-react-native-development/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development.png" data-orig-size="730,53" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Logged-result-process-env-React-Native-development" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development-300x22.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development.png" decoding="async" loading="lazy" src="../Images/563f2e15b91e000b64345df21da28de0.png" alt="Dark Maroon Background With Node Env And Development Environment Shown Logged To Console For Process Env" class="aligncenter size-full wp-image-143951" srcset="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development-300x22.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/06/img2-Logged-result-process-env-React-Native-development.png"/></noscript>
<p>这是因为 React 本机应用程序运行在设备或模拟器环境上，而不是 Node.js 进程上。</p>
<h2 id="how-create-custom-env-variable-react-native">如何在 React Native 中创建自定义 env 变量</h2>
<p>让我们看一个在 React Native 中创建 env 变量的例子。</p>
<p>您的第一步是转到您的根文件夹并创建一个<code>.env</code>文件。在该文件中，编写不带任何括号的 API 端点，如下所示:</p>
<pre class="language-javascript hljs">BASE_URL=https://api-dev.application.com
</pre>
<p>然后，在组件内部调用 env 变量，如下例所示:</p>
<pre class="language-javascript hljs">import React, { useState, useEffect } from "react";
import { View, Text } from "react-native";

const App = () =&gt; {
  const postUrl = process.env.BASE_URL
  return (
    &lt;View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center"
      }}
    &gt;
      &lt;Text&gt;ENV URL: {postUrl} &lt;/Text&gt; // https://api-dev.endpoint.com
    &lt;/View&gt;
  );
};
export default App;
</pre>
<p>注意在上面的例子中我们是如何在<code>process.env.</code>中定义 env 变量的。这一步允许我们使用<code>process.env.</code>来访问 env 变量。</p>
<p>值得注意的是，React Native 中的所有自定义 env 变量都必须以<code>REACT_APP_</code>开头。任何不带<code>REACT_APP_</code>前缀的变量都将被忽略，我们将无法在我们的应用程序中访问它们。</p>
<h2 id="what-node-env">什么是<code>NODE_ENV</code>？</h2>
<p><code>NODE_ENV</code>是一个内置的 env 变量，用于声明一个特定的环境是开发、测试还是生产环境。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>要使用<code>NODE_ENV</code>来检查您当前工作的环境，您可以在您的<code>App.js</code>文件中执行以下操作:</p>
<pre class="language-javascript hljs">const environment = process.env.NODE_ENV
console.log(environment)
</pre>
<p>如果你在一个开发环境中工作(即当你运行<code>npm start</code>)，那么<code>console.log(environment)</code>将记录<code>development</code>。</p>
<p>如果你在一个测试环境中工作(即当你运行<code>npm test</code>)，那么<code>console.log(environment)</code>将记录<code>test</code>。</p>
<p>如果你在一个生产环境中工作(也就是说，当你运行<code>npm build</code>来推进生产)，那么<code>console.log(environment)</code>将记录<code>production</code>。</p>
<p>不能手动覆盖，这有助于防止开发人员意外地将缓慢的开发版本部署到生产环境中。</p>
<h2 id="using-env-variables-switch-api-endpoints-different-environments">使用 env 变量在不同环境中的 API 端点之间切换</h2>
<p>您可以使用 env 变量根据环境有条件地呈现信息。例如，我们可以使用<code>NODE_ENV</code>在开发、测试和生产中的 API 端点之间切换。</p>
<p>您可能想知道为什么 API 端点和其他信息的基于环境的呈现是必要的。一个重要的原因是，我们可以在生产中进行更改或热修复，或者在开发中添加新功能，而不会破坏生产版本。</p>
<p>假设我们已经有了一个应用程序的实际版本，但是我们想要添加一个新特性或者做一些其他的改变。我们不希望在生产环境中进行这种更改，因为我们可能会破坏应用程序。</p>
<p>相反，我们将不得不切换到开发环境，进行必要的更改，并进行测试。我们还可以切换到试运行环境，以确保在投入生产之前一切正常，没有任何问题。</p>
<p>我们将构建一个非常简单的 React 本地应用程序来帮助演示如何使用 env 变量在不同环境中的 API 端点之间进行切换。按照本文的其余部分，<a href="https://blog.logrocket.com/complete-guide-react-native-web/" target="“_blank”" rel="noreferrer noopener">您应该知道如何使用 React Native </a>。</p>
<h3>安装和配置<code>dotenv</code>包</h3>
<p>有<a href="https://blog.logrocket.com/react-native-component-libraries/" target="“_blank”" rel="noreferrer noopener">许多 React 原生组件库</a>和包帮助提供平稳的开发体验。一些包可以帮助我们轻松地访问 React Native 中的 env 变量，包括<code>dotenv</code>、<code>react-native-config</code>等等。</p>
<p>出于本文的目的，我们将使用<code>dotenv</code>包。<code>dotenv</code>包允许您将 env 变量注入 React 本地环境。</p>
<p>要用 NPM 安装<code>dotenv</code>，运行下面的命令:</p>
<pre class="language-bash hljs">$ npm install react-native-dotenv
</pre>
<p>要用 yarn 安装<code>dotenv</code>,运行以下命令:</p>
<pre class="language-bash hljs">$ yarn add react-native-dotenv
</pre>
<p>安装软件包后，启动您的应用程序。然后，让我们配置插件。</p>
<p>要配置已安装的软件包，请转到位于根文件夹中的<code>.babelrc</code>文件——或者创建一个<code>.babelrc</code>文件，如果它不存在的话——并添加以下内容:</p>
<pre class="language-javascript hljs">{
  plugins: [
    [
      "module:react-native-dotenv",
      {
        envName: "APP_ENV",
        moduleName: "@env",
        path: ".env"
      }
    ]
  ]
};
</pre>
<p>这里，我们配置了我们的<code>dotenv</code>包。我们还为<code>.env</code>文件分配了一个路径，我们的 env 变量将存储在这里。最后，我们分配了一个名为<code>@env</code>的模块，从中我们可以导入我们的 env 变量。</p>
<h3>在我们的<code>.env</code>文件中定义我们的自定义 env 变量</h3>
<p>接下来，让我们在根文件夹中创建我们的<code>.env</code>文件。<code>.env</code>文件是一个文本文件，我们将使用它来定义变量，如下所示。</p>
<pre class="language-javascript hljs">REACT_APP_DEV_MODE=https://api-dev.application.com
REACT_APP_PROD_MODE=https://api-prod.application.com
REACT_APP_STAGE_MODE=https://api-stage.application.com
REACT_APP_TEST_MODE=https://api-test.application.com
</pre>
<p>正如您在上面看到的，我们使用<code>REACT_APP_</code>前缀定义了自定义的 env 变量。</p>
<p>这种命名约定有利于一致性。但是，如果您正在使用 React，那么<code>REACT_APP_</code>前缀也是一个要求；除了<code>NODE_ENV</code>之外的任何变量都将被忽略，除非它使用这个前缀。</p>
<h3>从我们的<code>@env</code>模块导入和调用变量</h3>
<p>接下来，让我们转到我们的<code>App.js</code>文件，从<code>@env</code>模块导入变量，这是我们之前在<code>babel.config.js</code>文件中配置的。</p>
<pre class="language-javascript hljs">import React from "react";
import { REACT_APP_DEV_MODE, REACT_APP_PROD_MODE } from "@env"
</pre>
<p>导入变量后，我们可以调用它们，并用它们获取 API 端点。</p>
<pre class="language-javascript hljs">import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { REACT_APP_DEV_MODE } from '@env';

const App = () =&gt; {
    return (
        &lt;View style={styles.screen}&gt;
            &lt;Text&gt;Url: {REACT_APP_DEV_MODE}&lt;/Text&gt; // https://api-dev.application.com
        &lt;/View&gt;
    );
};

const styles = StyleSheet.create({
    screen: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center'
    }
});
export default App;
</pre>
<p>我们已经看到了如何配置我们的<code>dotenv</code>包，创建我们的 env 变量，以及从我们的<code>@env</code>模块调用 env 变量。最后，让我们利用这些知识在不同环境中的 API 端点之间进行切换。</p>
<h3>检查环境并动态调用 env 变量</h3>
<p>前面，我们了解到我们可以使用<code>NODE_ENV</code>来检查我们处于哪个 React 本地环境中。然后，我们可以基于该环境有条件地在 API 端点之间切换。</p>
<p>以下代码显示了如何实现这一点:</p>
<pre class="language-javascript hljs">// using the @env package
import { REACT_APP_DEV_MODE, REACT_APP_PROD_MODE } from '@env';

const url =
        process.env.NODE_ENV === 'development'
            ? REACT_APP_DEV_MODE
            : REACT_APP_PROD_MODE;
</pre>
<p>在上面的代码中，我们首先动态检查了 process.env 环境，以查看我们正在哪个环境中工作。然后，使用条件，我们将 URL 分配给相应环境的正确变量。</p>
<h2 id="hiding-api-key">隐藏您的 API 密钥</h2>
<p>之前，我们简单地提到过你不应该在你的<code>.env</code>文件中存储你的秘密，比如 API 密匙，因为任何人都可以通过检查你的应用程序文件来访问它。</p>
<p>既然已经确定了，您可能想知道如何在推送之前隐藏您的 env 文件，例如，使用 Git 的版本控制系统。在<code>gitignore</code>文件的帮助下，这是可能的。</p>
<p><code>gitignore</code>文件允许我们在 React 应用程序中添加我们希望 Git 在将代码推送到 Github 或 Gitlab 等远程 repo 时忽略的文件。这些文件中的一些可能包括<code>node_modules</code>文件——它很大——和我们存储私钥的<code>.env</code>文件。</p>
<p>要隐藏 env 文件，请转到根文件夹中的<code>gitignore</code>文件。React Native 在创建应用程序时会创建这个文件。您应该会看到一堆被您的应用程序忽略的文件。只需将<code>.env</code>文件添加到列表中:</p>
<pre class="language-javascript hljs">/* .env */

.env
</pre>
<p>添加完<code>.env</code>文件后，创建一个新的<code>.env.local</code>文件并添加以下代码:</p>
<pre class="language-javascript hljs">/* .env.local */
    
REACT_APP_DEV_MODE=YOUR_DEV_KEY
REACT_APP_PROD_MODE=YOUR_PROD_KEY
</pre>
<p>现在，当我们推送到远程存储库时，我们将只能看到<code>.env.local</code>文件，而不能看到我们的主<code>.env</code>文件。因为它也是一个环境文件，所以变量将在构建时被注入，并且可以以同样的方式被访问。</p>
<h2 id="expanding-existing-env-variables">扩展应用程序中已经存在的 env 变量</h2>
<p>最后，我们将探索如何扩展我们的应用程序中已经存在的 env 变量。这里扩展 env 变量意味着使用存储在我们的<code>.env</code>文件中已经存在的变量。</p>
<p>让我们看看下面的代码:</p>
<pre class="language-javascript hljs">const firstName = "Chimezie"
const lastName = "Innocent"
const fullName = lastName + " " + firstName // Innocent Chimezie
</pre>
<p>通过连接两个字符串变量，我们可以定义一个新的变量，就像我们在上面看到的一样。我们可以在我们的<code>.env</code>文件中获得类似的结果，如下所示:</p>
<pre class="language-javascript hljs">/* .env */
    
FIRST_NAME=Innocent
LAST_NAME=Chimezie
NAME=$npm_package_name //awesomeproject
FULL_NAME=$FIRST_NAME // Innocent
    
// OR
    
FULL_NAME=${FIRST_NAME} // Innocent
</pre>
<p>不过这个功能只有<code>react-scripts</code> v1.1.0 或更高版本才有。</p>
<h2>结论</h2>
<p>在本文中，我们看到了在 React Native 中使用 env 变量的重要性。我们还学习了如何创建定制的 env 变量，并使用它们在不同环境中的 API 端点之间动态切换。最后，我们探索了如何隐藏我们的私有 API 键，甚至扩展我们现有的 env 变量。</p>
<p>我希望这篇文章能帮助您更好地理解 React 本机 env 变量。感谢您的阅读！</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现 React 原生应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 React 原生监控解决方案，可帮助您即时重现问题、确定 bug 的优先级并了解 React 原生应用的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 React 原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Interacting with databases in Rust using Diesel vs. SQLx - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Diesel与SQLx在Rust中与数据库交互</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/interacting-databases-rust-diesel-vs-sqlx/#0001-01-01">https://blog.logrocket.com/interacting-databases-rust-diesel-vs-sqlx/#0001-01-01</a></blockquote><div><article class="article-post">
<p>在本教程中，我们将探索在Rust中与关系数据库交互时使用的两个库:Diesel和SQLx。</p>
<p>本文将使用一个简单的课堂数据库和学生来演示每种方法。我们将使用Diesel ORM和SQLx执行CRUD操作。</p>
<p>我们将涵盖的内容:</p>

<p>要跟随本教程，您将需要Rust 的<a href="https://blog.logrocket.com/full-stack-rust-a-complete-tutorial-with-examples/" target="_blank" rel="noreferrer noopener">工作知识，以及访问和使用Rust、</a><a href="https://blog.logrocket.com/demystifying-cargo-in-rust/" target="_blank" rel="noreferrer noopener"> Rust的构建系统和软件包管理器货物</a>以及一个MySQL服务器实例的能力。</p>
<h2 id="what-diesel">柴油是什么？</h2>
<p>Diesel是一个ORM，支持PostgreSQL，MySQL，SQLite。ORM代表对象关系映射。ORMs帮助面向对象的程序员抽象关系数据库的细节。</p>
<p>ORM附带了查询构建器，所以您不必担心编写原始的SQL查询。使用ORM，您可以与关系数据库通信，就像它们是面向对象的一样。</p>
<p>对于经验不足的开发人员来说，使用ORM可能更好，因为ORM可以处理优化的SQL查询。ORM也让你不容易受到SQL注入攻击。</p>
<h2 id="what-sqlx">什么是SQLx？</h2>
<p>与Diesel不同，SQLx不是ORM。<a href="https://crates.io/crates/sqlx" target="_blank" rel="noreferrer noopener"> SQLx是一个异步Rust SQL库</a>,具有编译时SQL查询检查功能。它是数据库和运行时不可知的。</p>
<p>SQLx支持连接池、跨平台开发、嵌套池、异步通知、传输层安全性和其他令人兴奋的特性。使用SQLx时，您必须自己设计SQL查询和迁移。</p>
<p>已经触及了表面，让我们探索如何用Diesel和SQLx与关系数据库交互。</p>
<h2 id="getting-started-diesel-orm">Diesel ORM入门</h2>
<p>以下步骤演示了如何为使用Diesel ORM的货物设置Rust项目。</p>
<h3 id="initializing-new-project-diesel-orm">用Diesel ORM初始化一个新项目</h3>
<p>第一步是通过运行以下命令来初始化项目:</p>
<pre class="language-bash hljs">cargo new -- lib classroom_diesel
cd classroom_diesel
</pre>
<p>在上面的代码中，我们设置了项目并将其命名为<code>classroom_diesel</code>。新项目目录应该如下所示:</p>
<pre class="language-rust hljs">./
│
├── src/
│   └── lib.rs
│
├── .gitignore
└── Cargo.toml
</pre>
<p>我们还需要用项目中需要的依赖项更新<code>Cargo.toml</code>文件，如下所示:</p>
<pre class="language-toml hljs">[dependencies]
diesel = { version = "1.4.4", features = ["mysql"] }
dotenv = "0.15.0"
</pre>
<p><code>dotenv</code>依赖关系帮助我们管理项目中的环境变量。</p>
<h3 id="installing-diesel-cli">安装Diesel CLI</h3>
<p><a href="https://crates.io/crates/diesel_cli" target="_blank" rel="noreferrer noopener"> Diesel使用单独的CLI工具</a>。它是一个独立的二进制文件；我们不需要将它作为依赖项添加到<code>cargo.toml</code>文件中。只需用下面的命令安装它:</p>
<pre class="language-bash hljs">cargo install diesel_cli
</pre>
<h3 id="setting-up-diesel-environment">设置我们的柴油环境</h3>
<p>我们需要在我们的环境中设置一个<code>DATABASE_URL</code>变量。这就是Diesel知道连接到哪个MySQL数据库的方法:</p>
<pre class="language-bash hljs">echo DATABASE_URL=mysql://&lt;username&gt;:&lt;password&gt;@localhost/&lt;database&gt;  &gt; .env
</pre>
<p>编辑连接字符串以匹配您的本地数据库凭据。</p>
<p>您的项目目录现在将如下所示:</p>
<pre class="language-rust hljs">./
│
├── src/
│   └── lib.rs
│
├── .env
├── .gitignore
└── Cargo.toml
</pre>
<p>现在运行以下命令:</p>
<pre class="language-bash hljs">diesel setup
</pre>
<p>这个命令将帮助我们设置数据库，并创建一个空的迁移目录来管理数据库模式。</p>
<h3 id="setting-up-diesel-migrations">设置柴油迁移</h3>
<p>迁移有助于ORM跟踪数据库操作，比如添加一个字段或删除一个表。您可以将它们视为数据库的版本控制系统。</p>
<p>首先，让我们使用Diesel CLI为教室应用程序创建一些迁移。理想情况下，我们应该有一个包含课堂学生数据的表。我们需要创建空的迁移文件，然后用SQL填充它们以创建一个表。</p>
<pre class="language-bash hljs">diesel migration generate create_students
</pre>
<p>您的文件树将如下所示:</p>
<pre class="language-rust hljs">./
│
├── migrations/
│   │
│   ├── 2022-07-04-062521_create_students/
│   │   ├── down.sql
│   │   └── up.sql
│   │
│   └── .gitkeep
│
├── src/
│   └── lib.rs
│
├── .env
├── .gitignore
├── Cargo.toml
└── diesel.toml
</pre>
<p><code>up.sql</code>文件用于创建迁移，而<code>down.sql</code>文件用于撤销迁移。</p>
<p>使用用于迁移的SQL更新<code>up.sql</code>文件:</p>
<pre class="language-sql hljs">sql
CREATE TABLE students (
  id INTEGER AUTO_INCREMENT PRIMARY KEY,
  firstname VARCHAR(255) NOT NULL,
  lastname TEXT NOT NULL,
  age INTEGER NOT NULL
);
</pre>
<p>用可以反向迁移的SQL修改<code>down.sql</code>文件:</p>
<pre class="language-sql hljs">sql
DROP TABLE students;
</pre>
<p>在创建了<code>up</code>和<code>down</code>迁移之后，我们需要在数据库上执行SQL:</p>
<pre class="language-bash hljs">diesel migration run
</pre>
<p>我们可以开始编写Rust来执行表上的查询。</p>
<h3 id="creating-rows-diesel-orm">使用Diesel ORM创建行</h3>
<p>让我们编写代码，使用在<code>.env</code>文件中设置的连接字符串建立到MySQL服务器的连接。</p>
<pre class="language-rust hljs">#[macro_use]
extern crate diesel;
extern crate dotenv;

pub mod models;
pub mod schema;

use diesel::prelude::*;
use dotenv::dotenv;
use std::env;

pub fn create_connection() -&gt; MysqlConnection {
    dotenv().ok();

    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    MysqlConnection::establish(&amp;database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", database_url))
}
</pre>
<p>接下来，我们必须为<code>Students</code>表编写一个模型。模型是对象关系映射发生的地方。该模型将生成将<code>Students</code>表上的一行或多行转换为Rust 中的<code>Student</code> <a href="https://blog.logrocket.com/fundamentals-for-using-structs-in-rust/" target="_blank" rel="noreferrer noopener">结构所需的代码。</a></p>
<pre class="language-rust hljs">cd ./src
touch model.rs
</pre>
<p>在我们刚刚创建的新<code>model.rs</code>文件中，添加以下内容:</p>
<pre class="language-rust hljs">use super::schema::students;

#[derive(Queryable)]
pub struct Student {
    pub id: i32,
    pub firstname: String,
    pub lastname: String,
    pub age: i32,
}

#[derive(Insertable)]
#[table_name = "students"]
pub struct NewStudent&lt;'a&gt; {
    pub firstname: &amp;'a str,
    pub lastname: &amp;'a str,
    pub age: &amp;'a i32,
}
</pre>
<p>有了这个模型，<code>Students</code>表中的信息将映射到Rust中相应的<code>Student</code>结构。<code>src</code>文件夹现在应该是这样的:</p>
<pre class="language-rust hljs">src/
├── lib.rs
├── models.rs
└── schema.rs
</pre>
<p>现在，我们可以编写一个脚本来添加学生:</p>
<pre class="language-bash hljs">cd src
mkdir bin
cd bin
touch create_students.rs
</pre>
<p>在<code>create_students.rs</code>文件中，我们可以调用前面编写的模型和函数来创建一个新学生:</p>
<pre class="language-rust hljs">extern crate classroom_diesel;
extern crate diesel;

use self::classroom_diesel::*;
fn main() {
    let connection = create_connection();
    let firstname = "John";
    let lastname = "Doe";
    let age: i32 = 64;

    let student = create_post(&amp;connection, firstname, lastname, &amp;age);
    println!(
        "Saved student {} with id {}",
        student.firstname, student.id
    );
}
</pre>
<p>项目的结构现在看起来如下所示:</p>
<pre class="language-rust hljs">./
│
├── migrations/
│   │
│   ├── 2022-07-04-062521_create_students/
│   │   ├── down.sql
│   │   └── up.sql
│   │
│   └── .gitkeep
│
├── src/
│   │
│   ├── bin/
│   │   └── create_students.rs
│   │
│   ├── lib.rs
│   ├── models.rs
│   └── schema.rs
│
├── .env
├── .gitignore
├── Cargo.lock
├── Cargo.toml
└── diesel.toml
</pre>
<p>使用以下命令执行新脚本:</p>
<pre class="language-bash hljs">cargo run --bin create_students
</pre>
<p>如下图所示，<code>John</code>的新学生档案已经保存，并带有<code>1</code>的<code>id</code>。我们可以使用这个<code>id</code>来查询Rust数据库，这将在下一节中介绍。</p>
<p><img data-attachment-id="127642" data-permalink="https://blog.logrocket.com/interacting-databases-rust-diesel-vs-sqlx/attachment/image1-result-mapping-students-table-struct-create-new-student/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student.png" data-orig-size="730,56" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-mapping-Students-table-struct-create-new-student" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student-300x23.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student.png" decoding="async" class="aligncenter size-full wp-image-127642 jetpack-lazy-image" src="../Images/e496eb2c2d50fcb58118984a5809aa3e.png" alt="Result Of Mapping Students Table To A Struct To Create A New Student File In Diesel ORM" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student-300x23.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="127642" data-permalink="https://blog.logrocket.com/interacting-databases-rust-diesel-vs-sqlx/attachment/image1-result-mapping-students-table-struct-create-new-student/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student.png" data-orig-size="730,56" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-mapping-Students-table-struct-create-new-student" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student-300x23.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-127642" src="../Images/e496eb2c2d50fcb58118984a5809aa3e.png" alt="Result Of Mapping Students Table To A Struct To Create A New Student File In Diesel ORM" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student-300x23.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/image1-Result-mapping-Students-table-struct-create-new-student.png"/></noscript>
<h3 id="rust-database-querying-diesel-orm">用Diesel ORM查询铁锈数据库</h3>
<p>在上一节中，我们回顾了如何使用Diesel ORM在Rust中写入数据库。理解查询或阅读是如何工作的也很重要。</p>
<p>让我们写一个脚本来查询一个<code>id</code>是<code>1</code>的学生。首先创建一个<code>query_students.rs</code>文件:</p>
<pre class="language-bash hljs">cd bin
touch query_students.rs
</pre>
<p>然后，在我们刚刚创建的<code>query_students.rs</code>文件中，添加以下内容:</p>
<pre class="language-rust hljs">extern crate classroom_diesel;
extern crate diesel;

use self::models::*;
use classroom_diesel::*;
use diesel::prelude::*;

fn main() {
    use self::schema::students::dsl::*;

    let connection = create_connection();
    let result = students
        .filter(id.eq(1))
        .load::&lt;Student&gt;(&amp;connection)
        .expect("Error loading students");

    println!(
        "Student: {} {} {} years",
        result[0].firstname, result[0].lastname, result[0].age
    );
}
</pre>
<p>执行脚本:</p>
<pre class="language-bash hljs">cargo run --bin query_students
</pre>
<p>如下图所示，结果是一个打印行，包含我们从数据库中查询的学生文件的名字、姓氏和年龄:</p>
<p><img data-attachment-id="127644" data-permalink="https://blog.logrocket.com/interacting-databases-rust-diesel-vs-sqlx/attachment/image2-result-querying-rust-database-diesel-orm/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM.png" data-orig-size="730,65" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-querying-Rust-database-Diesel-ORM" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM-300x27.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM.png" decoding="async" class="aligncenter size-full wp-image-127644 jetpack-lazy-image" src="../Images/9ff25ff3a074e6a413eb236801d1382e.png" alt="Result Of Querying A Student File From A Rust Database Using Diesel ORM" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM-300x27.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="127644" data-permalink="https://blog.logrocket.com/interacting-databases-rust-diesel-vs-sqlx/attachment/image2-result-querying-rust-database-diesel-orm/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM.png" data-orig-size="730,65" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Result-querying-Rust-database-Diesel-ORM" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM-300x27.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-127644" src="../Images/9ff25ff3a074e6a413eb236801d1382e.png" alt="Result Of Querying A Student File From A Rust Database Using Diesel ORM" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM-300x27.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/image2-Result-querying-Rust-database-Diesel-ORM.png"/></noscript>
<h2 id="getting-started-sqlx">SQLx入门</h2>
<p>现在我们知道了如何创建一个使用Diesel ORM与Rust中的数据库进行交互的项目，让我们看看如何创建一个使用SQLx的项目。</p>
<h3 id="initializing-new-project-sqlx">用SQLx初始化新项目</h3>
<p>通过运行以下命令开始:</p>
<pre class="language-bash hljs">cargo new classroom_sqlx --bin
</pre>
<p>然后，将所需的依赖项添加到<code>cargo.toml</code>文件中:</p>
<pre class="language-toml hljs">[dependencies]
sqlx = { version = "0.5", features = [  "runtime-async-std-native-tls", "mysql" ] }
async-std = { version = "1", features = [ "attributes" ] }
</pre>
<p>关于设置，这就是你所需要的全部。简单吧？</p>
<p>要使用SQLx与Rust中的数据库进行交互，我们所要做的就是编写一些SQL查询和Rust代码。在Diesel ORM部分，我们创建并读取了一个学生记录；在本节中，我们将编写查询来更新和删除记录。</p>
<h3 id="using-sqlx-rust-update-delete-database-records">使用SQLx和Rust更新或删除数据库记录</h3>
<p>首先，我们需要编写一些Rust代码来将SQLx连接到MySQL服务器:</p>
<pre class="language-rust hljs">//main.rs

use sqlx::mysql::MySqlPoolOptions;

#[async_std::main]
async fn main() -&gt; Result&lt;(), sqlx::Error&gt; {
    let pool = MySqlPoolOptions::new()
        .max_connections(7)
        .connect("mysql://root:@localhost/classroom_diesel")
        .await?;

    Ok(())
}
</pre>
<p>SQLx支持准备好的和未准备好的SQL查询。准备好的SQL查询反对SQL注入。</p>
<p>让我们看看如何更新主键为1的记录的名字和姓氏:</p>
<pre class="language-rust hljs">use sqlx::mysql::MySqlPoolOptions;

#[async_std::main]
async fn main() -&gt; Result&lt;(), sqlx::Error&gt; {
    let pool = MySqlPoolOptions::new()
        .max_connections(5)
        .connect("mysql://root:@localhost/classroom_diesel")
        .await?;

    sqlx::query("UPDATE students SET firstname=?, lastname=? WHERE id=?")
        .bind("Richard")
        .bind("Roe")
        .bind(1)
        .execute(&amp;pool)
        .await?;
    Ok(())
}
</pre>
<p>使用以下命令执行脚本:</p>
<pre class="language-bash hljs">cargo run
</pre>
<p>删除记录也采用类似的模式；唯一的区别是SQL查询:</p>
<pre class="language-rust hljs">use sqlx::mysql::MySqlPoolOptions;

#[async_std::main]
async fn main() -&gt; Result&lt;(), sqlx::Error&gt; {
    let pool = MySqlPoolOptions::new()
        .max_connections(5)
        .connect("mysql://root:@localhost/classroom_diesel")
        .await?;

    sqlx::query("DELETE FROM students WHERE id=?")
        .bind(1)
        .execute(&amp;pool)
        .await?;
    Ok(())
}
</pre>
<p>使用以下命令执行脚本:</p>
<pre class="language-bash hljs">cargo run
</pre>
<p>现在，您可以使用Diesel或SQLx与Rust中的数据库进行交互。</p>
<h2 id="conclusion">结论</h2>
<p>柴油之类的ORM就足够了；它们帮助您生成一些您需要的SQL。大多数情况下，在应用程序中，足够是您所需要的。</p>
<p>然而，在更广泛的应用程序中，要让ORM正常工作并生成高性能的SQL查询，可能需要更多的“魔力”——换句话说，需要您的时间和精力。</p>
<p>如果需要创建具有高容量和低延迟需求的更复杂的查询，使用像SQLx这样的库来执行原始SQL查询可能会更好。</p><div class="code-block code-block-29">
<div class="blog-plug inline-plug rust-plug"><h2><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">log rocket</a>:Rust应用的web前端的全面可见性</h2><p>调试Rust应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪Rust应用程序的性能、自动显示错误、跟踪缓慢的网络请求和加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/rust-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a><p>LogRocket 就像是网络和移动应用程序的DVR，记录你的Rust应用程序上发生的一切。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>现代化调试Rust应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/rust-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Implement in-app notifications with NestJS, MySQL, and Firebase </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用NestJS、MySQL和Firebase实现应用内通知</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/#0001-01-01">https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/#0001-01-01</a></blockquote><div><article class="article-post">
<p>应用内提醒是为你的应用用户提供实时信息的好方法。<a href="https://blog.logrocket.com/react-native-push-notifications-firebase-cloud-messaging/"> Firebase Cloud Messaging (FCM)是一个跨平台的消息系统</a>,是向您的客户端应用发送推送通知的绝佳工具。</p>
<p>在本文中，我们将介绍在NestJS项目中设置Firebase云消息传递。我们将使用MySQL数据库来存储和检索通知数据，并根据数据库信息向用户发送推送通知。</p>
<p><em>向前跳转:</em></p>

<h2 id="prerequisites">先决条件</h2>
<p>开始之前，请确保您具备以下条件:</p>
<ul>
<li>全球安装NestJS CLI</li>
<li>启用了云消息服务的Firebase项目</li>
</ul>
<p>要跟进，您可以<a href="https://github.com/Caesarsage/inapp-notification-with-nestJS">查看GitHub repo </a>。我们开始吧！</p>
<h2 id="setting-up-firebase-cloud-messaging">设置Firebase云消息传递</h2>
<p>要开始使用NestJS中的FCM，您需要建立一个Firebase项目并启用FCM API。为此，请遵循<a href="https://firebase.google.com/docs/cloud-messaging/js/client"> Firebase文档</a>中的说明。</p>
<p>设置好Firebase项目后，您需要创建一个服务帐户并下载私钥文件，该文件是一个JSON文件，包含认证Firebase Admin SDK所需的凭证。</p>
<p>将私钥文件移动到应用程序的根目录；对于本教程，我们将重命名文件<code>firebase-admin-sdk.json</code>。用下面的命令安装<a href="https://www.npmjs.com/package/firebase-admin"> <code>firebase-admin</code> </a>包:</p>
<pre class="language-bash hljs">npm install --save firebase-admin
</pre>
<h2 id="create-nest-js-user-notification-resources">创建NestJS用户和通知资源</h2>
<p>在使用推送通知的系统中，用户资源是指为每个用户存储和管理的信息；这可能包括用户的设备类型、推送通知偏好和联系信息等信息。通常，此信息用于根据每个用户的偏好和历史来定制推送通知的内容和传送。</p>
<p>另一方面，通知资源指的是用于启用、禁用和发送推送通知的逻辑和功能。这可能包括安排通知、创建和管理通知组以及自定义通知的内容和外观的能力。这可能还包括跟踪通知的交付和参与，例如，通过使用打开率、点击率等。</p>
<p>我们将使用下面的代码片段生成这些新的NestJS资源:</p>
<pre class="language-javascript hljs"> nest g res notification --no-spec</pre>
<pre class="language-javascript hljs"> nest g res users --no-spec
</pre>
<h2 id="setting-up-mysql">设置MySQL</h2>
<p>在处理通知资源之前，让我们设置MySQL数据库来存储通知数据。首先，安装<a href="https://www.npmjs.com/package/mysql2"> MySQL2 </a>和<a href="https://typeorm.io/"> TypeORM </a>包:</p>
<pre class="language-bash hljs">npm install --save mysql2 typeorm @nestjs/typeorm @nestjs/config
</pre>
<p>现在，让我们更新一下<code>app.module.ts</code>:</p>
<pre class="language-typescript hljs">import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppService } from './app.service';
import { Notification } from './notification/entities/notification.entity';
import { NotificationModule } from './notification/notification.module';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: "mysql",
      host: process.env.DB_HOST,
      port: 3306,
      username: procees.env.DB_NAME,
      password: process.env.DB_PASSWORD,
      database: "in_app_notification",
      entities: [Notification],
      synchronize: true,
  }),
    NotificationModule
  ],
  controllers: [],
  providers: [AppService],
})

export class AppModule {}
</pre>
<p>首先，<code>TypeOrmModule.forRoot({...})</code>导入<code>TypeOrmModule</code>。然后，它使用<code>.forRoot()</code>方法为模块提供一个配置对象，该对象建立到MySQL数据库的连接，指定<code>host</code>、<code>port</code>、<code>username</code>、<code>password</code>、<code>database name</code>、<code>database</code>的类型、用于表的<code>entities</code>和<code>synchronization</code>状态。</p>
<p>我们在位于应用程序根目录的<code>.env</code>文件中定义环境变量。请记住，在生产环境中，建议使用<code>migrations</code>并将<code>synchronization</code>设置为<code>false</code>。</p>
<h2 id="user-resources">用户资源</h2>
<p>我们将使用<code>TypeOrmModule</code>来建立MySQL连接并创建<code>User</code>实体。将以下代码添加到<code>user.module.ts</code>:</p>
<pre class="language-typescript hljs">import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { NotificationModule } from 'src/notification/notification.module';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([User]),
    NotificationModule
  ],
  controllers: [UsersController],
  providers: [UsersService]
})

export class UsersModule {}
</pre>
<h2 id="create-user-entity">创建<code>User</code>实体</h2>
<p>实体帮助我们定义数据库表模式；默认情况下，<code>User</code>实体将<code>ID</code>、<code>email</code>、<code>username</code>、<code>status</code>定义为<code>ACTIVE</code>:</p>
<pre class="language-javascript hljs">import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';

@Entity({ name: 'users' })
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  email: string;

  @Column()
  username: string;

  @Column({
    default: 'ACTIVE',
  })
  status: string;
}
</pre>
<p>目前，这些都将存储在<code>user</code>模块中。我们稍后将再次讨论这个模块，以利用推送通知。</p>
<h2 id="notification-resources">通知资源</h2>
<p>在该模块中，我们将使用<code>TypeOrmModule</code>来建立MySQL连接，创建<code>Notification</code>实体，并导出服务。将下面的代码添加到<code>notification.module.ts</code>:</p>
<pre class="language-typescript hljs">import { Module } from '@nestjs/common';
import { NotificationService } from './notification.service';
import { NotificationController } from './notification.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Notifications } from './entities/notification.entity';
import { NotificationToken } from './entities/notification-token.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([Notifications, NotificationToken])
  ],
  controllers: [NotificationController],
  providers: [NotificationService],
  exports: [NotificationService]
})

export class NotificationModule {}
</pre>
<h2 id="create-notifications-notificationtoken-entity">创建通知和<code>NotificationToken</code>实体</h2>
<p>将以下代码添加到<code>notification.entity.ts</code>:</p>
<pre class="language-typescript hljs">import { Entity, Column, PrimaryGeneratedColumn, JoinColumn, ManyToOne } from 'typeorm';
import { NotificationToken } from './notification-token.entity';

@Entity({ name: 'notifications' })
export class Notifications {
  @PrimaryGeneratedColumn()
  id: number;

  @JoinColumn({ name: 'notification_token_id', referencedColumnName: 'id' })
  @ManyToOne(() =&gt; NotificationToken)
  notification_token: NotificationToken;

  @Column()
  title: string;

  @Column({ type: 'longtext', nullable: true })
  body: any;

  @Column()
  created_by: string;

  @Column({
    default: 'ACTIVE',
  })
  status: string;
}
</pre>
<p><code>Notification</code>实体有以下几列:<code>id</code>、<code>title</code>、<code>body</code>、<code>status</code>和<code>created_by</code>。</p>
<p><code>id</code>列是主键，由数据库自动生成。<code>notification_token</code>与<code>NoticationToken</code>表有一个<code>ManyToOne</code>关系，其他列存储通知的数据。</p>
<p>接下来，将以下代码添加到<code>notification-token.entity.ts</code>文件中:</p>
<pre class="language-typescript hljs">import { User } from 'src/users/entities/user.entity';
import { Entity, Column, JoinColumn, ManyToOne, PrimaryGeneratedColumn } from 'typeorm';

@Entity({ name: 'notification_tokens' })
export class NotificationToken {
  @PrimaryGeneratedColumn()
  id: number;

  @JoinColumn({ name: 'user_id', referencedColumnName: 'id' })
  @ManyToOne(() =&gt; User)
  user: User;

  @Column()
  device_type: string;

  @Column()
  notification_token: string;

  @Column({
    default: 'ACTIVE',
  })
  status: string;
}
</pre>
<p><code>NotificationToken</code>实体有<code>id</code>、<code>user</code>、<code>device_type</code>、<code>status</code>和<code>notification_token</code>列；<code>notification_token</code>是在注册的FCM设备上生成的唯一字符串。</p>
<p><code>id</code>列是主键，由数据库自动生成。<code>notification_token</code>与<code>User</code>表有一个<code>ManyToOne</code>关系，而其他列存储通知的数据。</p>
<h2 id="fcm-notification-token-usecase-server">服务器上的FCM通知令牌用例</h2>
<p>移动应用程序或浏览器向FCM注册，然后FCM给该设备一个唯一的令牌。设备将这个令牌发送给我们的NestJS服务器，我们将这个FCM令牌存储在数据库中。</p>
<p>当用户获得推送通知时，注册到用户设备的唯一令牌将负责使用Firebase Admin SDK发送推送通知。</p>
<h3><code>notification.service.ts</code></h3>
<pre class="language-typescript hljs">import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Notifications } from './entities/notification.entity';
import { Repository } from 'typeorm';
import * as firebase from 'firebase-admin';
import * as path from 'path';
import { NotificationToken } from './entities/notification-token.entity';
import { NotificationDto } from './dto/create-notification.dto';
import { UpdateNotificationDto } from './dto/update-notification.dto';

firebase.initializeApp({
  credential: firebase.credential.cert(
    path.join(__dirname, '..', '..', 'firebase-adminsdk.json'),
  ),
});

@Injectable()
export class NotificationService {
  constructor(
    @InjectRepository(Notifications) private readonly notificationsRepo: Repository&lt;Notifications&gt;,
    @InjectRepository(NotificationToken) private readonly notificationTokenRepo: Repository&lt;NotificationToken&gt;,
  ) {}

  acceptPushNotification = async (
    user: any,
    notification_dto: NotificationDto ,
  ): Promise&lt;NotificationToken&gt; =&gt; {};

  disablePushNotification = async (
    user: any,
    update_dto: UpdateNotificationDto,
  ): Promise&lt;void&gt; =&gt; {};

  getNotifications = async (): Promise&lt;any&gt; =&gt; {};

  sendPush = async (user: any, title: string, body: string): Promise&lt;void&gt; =&gt; {};
}
</pre>
<p>上面的代码首先导入必要的模块和依赖项，包括nestj<code>Injectable</code>和<code>InjectRepository</code>装饰器，TypeORM <code>Repository</code>、<code>Notifications</code>和<code>NotificationToken</code>实体，以及Firebase <code>firebase-admin</code>模块。然后，它使用存储在<code>firebase-adminsdk.json</code>文件中的服务帐户密钥初始化Firebase应用程序。</p>
<p>然后用<code>Injectable</code>装饰器定义并装饰<code>NotificationService</code>类。它有三个存储库作为私有属性，分别为<code>Notifications</code>和<code>NotificationToken</code>实体的<code>notificationsRepo</code>和<code>notificationTokenRepo</code>。</p>
<p><code>NotificationService</code>类有四个方法:</p>

<h3 id="accept-push-notification"><code>acceptPushNotification</code></h3>
<pre class="language-typescript hljs">acceptPushNotification = async (
    user: any,
    notification_dto: NotificationDto ,
  ): Promise&lt;NotificationToken&gt; =&gt; {
    await this.notificationTokenRepo.update(
      { user: { id: user.id } },
      {
        status: 'INACTIVE',
      },
    );
    // save to db
    const notification_token = await this.notificationTokenRepo.save({
      user: user,
      device_type: notification_dto.device_type,
      notification_token: notification_dto.notification_token,
      status: 'ACTIVE',
    });
    return notification_token;
  };
</pre>
<p><code>acceptPushNotification</code>使用<code>notificationTokenRepo.update</code>方法将用户的所有现有通知令牌的状态更新为<code>INACTIVE</code>。它使用提供的用户对象、令牌和设备类型创建一个新的通知令牌对象，并将状态设置为<code>ACTIVE</code>。</p>
<p>最后，它使用<code>notificationTokenRepo.save</code>方法将新的通知令牌保存到数据库。</p>
<h3 id="disable-push-notification"><code>disablePushNotification</code></h3>
<pre class="language-typescript hljs">disablePushNotification = async (
    user: any,
    update_dto: UpdateNotificationDto,
  ): Promise&lt;void&gt; =&gt; {
    try {
      await this.notificationTokenRepo.update(
        { user: { id: user.id }, device_type: update_dto.device_type },
        {
          status: 'INACTIVE',
        },
      );
    } catch (error) {
      return error;
    }
  };
</pre>
<p><code>disablePushNotification</code>根据更新DTO中提供的用户ID和设备类型，使用<code>notificationTokenRepo.update</code>方法将用户的特定通知令牌的状态更新为<code>INACTIVE</code>。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h3 id="get-notifications"><code>getNotifications</code></h3>
<pre class="language-typescript hljs">getNotifications = async (): Promise&lt;any&gt; =&gt; {
    return await this.notificationsRepo.find();
  };</pre>
<p><code>getNotifications</code>使用<code>notificationsRepo.find()</code>方法从数据库中检索所有通知。</p>
<h3 id="sendpush"><code>sendPush</code></h3>
<pre class="language-javascript hljs">sendPush = async (user: any, title: string, body: string): Promise&lt;void&gt; =&gt; {
    try {
      const notification = await this.notificationTokenRepo.findOne({
        where: { user: { id: user.id }, status: 'ACTIVE' },
      });
      if (notification) {
        await this.notificationsRepo.save({
          notification_token: notification,
          title,
          body,
          status: 'ACTIVE',
          created_by: user.username,
        });
        await firebase
          .messaging()
          .send({
            notification: { title, body },
            token: notification.notification_token,
            android: { priority: 'high' },
          })
          .catch((error: any) =&gt; {
            console.error(error);
          });
      }
    } catch (error) {
      return error;
    }
  };
</pre>
<p><code>sendPush</code>使用<code>notificationTokenRepo.findOne</code>方法为用户找到一个活动的通知令牌；它搜索用户ID和状态为<code>ACTIVE</code>的令牌。</p>
<p>如果找到通知令牌，它会使用<code>notificationsRepo.save</code>方法将通知保存到数据库，其中<code>title</code>、<code>body</code>和<code>status</code>由用户创建。</p>
<p>它使用FCM <code>firebase.messaging().send()</code>方法将通知发送到用户的设备，传入通知的<code>title</code>、<code>body</code>、用户的通知令牌以及为Android设置的优先级<code>high</code>。</p>
<ul>
<li><code>token</code>:应该向其发送通知的设备的FCM注册令牌</li>
<li><code>title</code>:通知的标题</li>
<li><code>body</code>:通知的正文</li>
<li><code>android</code>:设置设备类型优先级</li>
</ul>
<p>值得注意的是，<code>sendPush</code>方法使用<code>firebase-admin</code>包发送推送通知，这是Node.js的官方Firebase Admin SDK，允许您从服务器环境与Firebase服务进行交互。</p>
<h2 id="utilizing-push-notifications-users">对用户使用推送通知</h2>
<p>现在我们已经设置了FCM和MySQL，我们可以使用它们根据MySQL数据库中的数据向用户发送推送通知。使用Firebase服务，我们可以更新用户服务以启用、从数据库中检索通知并发送它们。</p>
<p>为了演示这一点，让我们使用一个更新端点。只要用户启用了通知，每次他们更新配置文件时，我们都会调用通知服务中的<code>sendPush</code>方法，向用户发送推送通知，并将通知保存在数据库中。</p>
<h2 id="configuring-user-services">配置用户服务</h2>
<p>首先，将<code>NotificationService</code>注入用户服务:</p>
<pre class="language-javascript hljs">import { Injectable } from '@nestjs/common';
import { NotificationService } from 'src/notification/notification.service';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User) private readonly userRepository: Repository&lt;User&gt;,
    private readonly notificationService: NotificationService,
  ) {}

  create(user: CreateUserDto): Promise&lt;User&gt; {}

  updateProfile = async (user_id: number, update_dto: any): Promise&lt;any&gt; =&gt; {}

  enablePush = async (
   user_id: number,
    update_dto: NotificationDto,
  ): Promise&lt;any&gt; =&gt; {};

  disablePush = async (
    user_id: number,
    update_dto: UpdateNotificationDto,
  ): Promise&lt;any&gt; =&gt; {};

  getPushNotifications = async (): Promise&lt;any&gt; =&gt; {};

}
</pre>
<p><code>UsersService</code>类有五个方法:</p>

<h3 id="create"><code>create</code></h3>
<pre class="language-javascript hljs">create(user: CreateUserDto): Promise&lt;User&gt; {
    return this.userRepository.save(user);
  }
</pre>
<p><code>create</code>创建一个新的用户帐户并保存到数据库。</p>
<h3 id="update-profile"><code>updateProfile</code></h3>
<pre class="language-javascript hljs">updateProfile = async (user_id: number, update_dto: any): Promise&lt;any&gt; =&gt; {
    try {
      const user = await this.userRepository.findOne({
        where: { id: user_id },
      });
      const updated_user = {
        ...user,
        username: update_dto.username,
        email: update_dto.email,
      }
      const saved_user = await this.userRepository.save(updated_user);
      if (saved_user) {
        // send push notification
        await this.notificationService.sendPush(
          updated_user,
          'Profiie update',
          'Your Profile have been updated successfully',
        )
        .catch((e) =&gt; {
          console.log('Error sending push notification', e);
        }); 
      }
      return saved_user;
    } catch (error) {
      return error;
    }
  }
</pre>
<p><code>updateProfile</code>使用提供的用户对象创建新的用户对象，从更新DTO更新用户名和电子邮件。</p>
<p>它使用<code>userRepository.save</code>方法将更新的用户对象保存到数据库中。如果用户保存成功，它使用<code>notificationService.sendPush</code>方法向用户发送推送通知，传入更新后的用户对象、标题<code>Profile update</code>和正文阅读信息<code>Your Profile have been updated successfully</code>。</p>
<p>它有一个<code>try...catch</code>块来处理在执行该方法时可能出现的任何错误，如果有错误就返回错误。</p>
<h3 id="enablepush"><code>enablePush</code></h3>
<pre class="language-javascript hljs">enablePush = async (
   user_id: number,
    update_dto: NotificationDto,
  ): Promise&lt;any&gt; =&gt; {
    const user = await this.userRepository.findOne({
      where: { id: user_id },
    });
    return await this.notificationService.acceptPushNotification(
      user,
      update_dto,
    );
  };
</pre>
<p>通过搜索ID与提供的用户ID相匹配的用户，<code>enablePush</code>使用<code>userRepository.findOne</code>方法在数据库中找到该用户。</p>
<p>然后，它调用<code>notificationService.acceptPushNotification</code>方法并传递用户和更新DTO作为参数。这允许用户接受任何发送的推送通知，或者在我们的例子中，当用户配置文件更新时接受推送通知。</p>
<h3 id="disable-push"><code>disablePush</code></h3>
<pre class="language-javascript hljs">disablePush = async (
    user_id: number,
    update_dto: UpdateNotificationDto,
  ): Promise&lt;any&gt; =&gt; {
    const user = await this.userRepository.findOne({
      where: { id: user_id },
    });
    return await this.notificationService.disablePushNotification(
      user,
      update_dto,
    );
  };
</pre>
<p>通过搜索ID与提供的用户ID相匹配的用户，<code>disablePush</code>使用<code>userRepository.findOne</code>方法在数据库中找到该用户。然后它调用<code>notificationService.disablePushNotification</code>方法，传递用户和更新DTO作为参数。</p>
<h3 id="get-push-notification"><code>getPushNotifications</code></h3>
<pre class="language-javascript hljs">getPushNotifications = async (): Promise&lt;any&gt; =&gt; {
    return await this.notificationService.getNotifications();
  };
</pre>
<p><code>getPushNotifications</code>调用<code>notificationService.getNotifications()</code>方法并返回结果。</p>
<p>值得注意的是，这些方法分别使用<code>userRepository</code>和<code>notificationService</code>与数据库交互和处理推送通知。它可以被认为是使用特定服务来分别处理推送通知和用户简档的更高级服务。</p>
<h2 id="configuring-user-controllers">配置用户控制器</h2>
<p>既然我们的用户服务配置了上面提到的五种方法，我们将通过初始化<code>UsersService</code>类的私有实例来创建不同的端点作为控制器，它负责执行实际的用户操作:</p>
<pre class="language-javascript hljs">import { Controller, Get, Post, Body, Patch, Param, Delete, HttpStatus, HttpCode, Put } from '@nestjs/common';
import { NotificationDto } from 'src/notification/dto/create-notification.dto';
import { UpdateNotificationDto } from 'src/notification/dto/update-notification.dto';
import { UsersService } from './users.service';

@Controller('users')
export class UsersController {
  constructor(
    private readonly usersService: UsersService,
  ) {}

  @Post()
  @HttpCode(HttpStatus.OK)
  async CreateUser(@Body() user: CreateUserDto) {
    return await this.usersService.create(user);
  }

  @Put()
  @HttpCode(HttpStatus.OK)
  async updateProfile(
    @Body() update_dto: any,
    @Param('id') user_id: number,
  ) {
    return await this.usersService.updateProfile(user_id ,update_dto);
  }

  @Put('push/enable')
  @HttpCode(HttpStatus.OK)
  async enablePush(
    @Body() update_dto: NotificationDto,
    @Param('id') user_id: number,
  ) {
    return await this.usersService.enablePush(user_id, update_dto)  
  }

  @Put('push/disable')
  @HttpCode(HttpStatus.OK)
  async disablePush(
    @Param('id') user_id: number,
    @Body() update_dto: UpdateNotificationDto,
  ) {
    return await this.usersService.disablePush(user_id, update_dto)
  }

  @Get('push/notifications')
  @HttpCode(HttpStatus.OK)
  async fetchPusNotifications() {
    return await this.usersService.getPushNotifications();
  }
}
</pre>
<p><code>@Controller('users')</code>定义了基本端点。<code>@Post</code>装饰器处理HTTP <code>POST</code>请求，用于创建新用户。创建一个新用户，调用<code>UsersService</code>的<code>create</code>方法，用户信息作为<code>@Body</code>传递。</p>
<p><code>@Put</code>装饰器处理HTTP <code>PUT</code>请求，更新用户的档案。然后调用<code>UsersService</code>的<code>updateProfile</code>方法，用用户ID作为请求<code>@Param</code>和更新的用户信息来更新用户的配置文件。</p>
<p>类似地，<code>@Put('push/enable')</code>和<code>@Put('push/disable')</code>方法处理为用户启用或禁用推送通知。<code>@Param</code>装饰器用于从URL中提取用户ID，而<code>@Body</code>装饰器用于提取启用或禁用推送通知所需的信息。</p>
<p>然后用用户ID和必要的信息调用<code>UsersService</code>的<code>enablePush</code>和<code>disablePush</code>方法，为用户启用或禁用推送通知。最后，<code>@Get('push/notifications')</code>方法处理获取推送通知。然后调用<code>UsersService</code>的<code>getPushNotifications</code>方法来获取推送通知。</p>
<p><code>@HttpCode</code>装饰器用于为每个方法设置HTTP响应代码，默认为所有方法的<code>200 (OK)</code>。</p>
<h2 id="testing-controller-endpoints">测试控制器端点</h2>
<p>为了测试我们的用户控制器，我们将使用<a href="https://marketplace.visualstudio.com/items?itemName=rangav.vscode-thunder-client"> VS Code Thunder Client </a>。首先，让我们创建一个用户:</p>
<p><img data-attachment-id="159225" data-permalink="https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/attachment/test-controllers-vscode-thunder-client/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client.png" data-orig-size="730,193" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="test-controllers-vscode-thunder-client" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client-300x79.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client.png" decoding="async" class="aligncenter wp-image-159225 size-full jetpack-lazy-image" src="../Images/3cd73448969ca4949c5d355662250518.png" alt="Test Controllers VSCode Thunder Client" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client-300x79.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159225" data-permalink="https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/attachment/test-controllers-vscode-thunder-client/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client.png" data-orig-size="730,193" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="test-controllers-vscode-thunder-client" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client-300x79.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client.png" decoding="async" loading="lazy" class="aligncenter wp-image-159225 size-full" src="../Images/3cd73448969ca4949c5d355662250518.png" alt="Test Controllers VSCode Thunder Client" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client-300x79.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/test-controllers-vscode-thunder-client.png"/></noscript>
<p>用户必须启用推送通知才能接收它们。因此，我们将发送我们的<code>device_type</code>和唯一的FCM令牌。请记住，特定设备上您的客户端应用程序的FCM标识由<code>notification token</code>表示。</p>
<p>当它第一次向FCM注册时，您的应用程序在设备或浏览器上运行时会获得一个注册令牌；注册令牌在运行时创建。</p>
<p><code>notification_token</code>:</p>
<p><img data-attachment-id="159223" data-permalink="https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/attachment/registration-token-created-runtime/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime.png" data-orig-size="730,545" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="registration-token-created-runtime" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime-300x224.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime.png" decoding="async" class="aligncenter wp-image-159223 size-full jetpack-lazy-image" src="../Images/4e871715f3f0252066a6b77d93b234bd.png" alt="Registration Token Created Runtime" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime-300x224.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159223" data-permalink="https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/attachment/registration-token-created-runtime/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime.png" data-orig-size="730,545" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="registration-token-created-runtime" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime-300x224.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime.png" decoding="async" loading="lazy" class="aligncenter wp-image-159223 size-full" src="../Images/4e871715f3f0252066a6b77d93b234bd.png" alt="Registration Token Created Runtime" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime-300x224.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/registration-token-created-runtime.png"/></noscript>
<p>用户接受了推送通知，其从前端生成的<code>notification token</code>被存储。因此，用户可以更新其配置文件和通知首选项，保存并在前端处理时获得有关其配置文件更新的通知:</p>
<p><img data-attachment-id="159221" data-permalink="https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/attachment/user-accepted-push-notification/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification.png" data-orig-size="730,514" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="user-accepted-push-notification" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification-300x211.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification.png" decoding="async" class="aligncenter wp-image-159221 size-full jetpack-lazy-image" src="../Images/2ece34dafc1906e42133fd0491148888.png" alt="User Accepted Push Notification" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification-300x211.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159221" data-permalink="https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/attachment/user-accepted-push-notification/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification.png" data-orig-size="730,514" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="user-accepted-push-notification" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification-300x211.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification.png" decoding="async" loading="lazy" class="aligncenter wp-image-159221 size-full" src="../Images/2ece34dafc1906e42133fd0491148888.png" alt="User Accepted Push Notification" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification-300x211.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/user-accepted-push-notification.png"/></noscript>
<p>最后，您可以查看所有通知:</p>
<p><img data-attachment-id="159219" data-permalink="https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/attachment/view-all-notifications-firebase-nest-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js.png" data-orig-size="730,535" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="view-all-notifications-firebase-nest-js" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js-300x220.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js.png" decoding="async" class="aligncenter wp-image-159219 size-full jetpack-lazy-image" src="../Images/6c945211aaaf329d14e4ad1c29dd7cdc.png" alt="View All Notifications Firebase NestJS" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js-300x220.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="159219" data-permalink="https://blog.logrocket.com/implement-in-app-notifications-nestjs-mysql-firebase/attachment/view-all-notifications-firebase-nest-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js.png" data-orig-size="730,535" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="view-all-notifications-firebase-nest-js" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js-300x220.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js.png" decoding="async" loading="lazy" class="aligncenter wp-image-159219 size-full" src="../Images/6c945211aaaf329d14e4ad1c29dd7cdc.png" alt="View All Notifications Firebase NestJS" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js-300x220.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/view-all-notifications-firebase-nest-js.png"/></noscript>
<p>在客户端，您需要使用Firebase JavaScript SDK来请求显示推送通知和处理传入推送通知的权限。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们学习了如何使用Firebase和MySQL在NestJS应用程序中实现应用程序内通知。首先，我们设置Firebase Admin SDK来发送推送通知。然后，我们设置了一个MySQL数据库来存储通知数据，并创建了一个服务来基于数据库中的数据检索和发送通知。</p>
<p>我希望你喜欢这篇文章。有问题就留言吧，编码愉快！</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
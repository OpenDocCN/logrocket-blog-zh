<html>
<head>
<title>CSS vs. CSS-in-JS: How and why to use each </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CSS与CSS-in-JS:如何以及为什么使用它们</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/css-vs-css-in-js/#0001-01-01">https://blog.logrocket.com/css-vs-css-in-js/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发人员在使用JavaScript框架时通常面临的一个难题是是否使用CSS-in-JS。如果你是一名React开发人员，你很可能曾经使用过CSS-in-JS。</p>
<p>如今，CSS vs. CSS-in-JS是一个热门话题。这主要是因为CSS-in-JS因其性能问题而受到关注。然而，还有一些<a href="https://web.dev/state-of-css-2022/">新的CSS特性正在酝酿中</a>,应该会在不久的将来解决这些问题。</p>
<p>本文的目的是帮助你根据现代CSS的现状和未来可能的变化，在即将到来的项目中选择CSS或CSS-in-JS。</p>
<p>向前跳:</p>

<p>本文中的所有代码片段和演示都以React和CSS为特色。在前进之前，请确保您熟悉这两种web技术。</p>
<p>注意，任何JavaScript前端框架或库都可以实现CSS-in-JS的思想。本文使用React——到目前为止最流行的JavaScript前端库——来讨论CSS-in-JS的应用，以及它显著的优缺点。</p>
<h2 id="render-blocking-css">渲染阻塞和CSS</h2>
<p>在深入讨论什么是最好的，什么不是之前，让我们先讨论一下由CSS引起的渲染问题。</p>
<p>传统上，浏览器首先加载HTML，然后从所有外部资源加载CSS。之后，浏览器使用所有外部和内部CSS信息创建CSSOM。现在，浏览器已经准备好根据CSS级联规则为呈现的HTML提供样式。</p>
<p>这个过程导致CSS<a href="https://blog.logrocket.com/9-tricks-eliminate-render-blocking-resources/">阻止页面呈现</a>，并延迟所请求页面的第一次绘制。First paint是浏览器在屏幕上打印所请求页面的第一个像素时发生的事件。</p>
<p>第一次绘制延迟超过半秒会增加用户不满意的风险，并会对应用程序的目标产生负面影响。将CSS交付给客户端的速度越快，就越能优化页面的首次绘制时间。</p>
<h3>对抗CSS渲染块</h3>
<p>使用HTTP/2驱动的应用程序，可以并行加载多个HTML、CSS和JS文件。HTTP/1.1限制了这种能力。大多数现代浏览器和网站现在都支持HTTP/2，这可以最大限度地减少因等待其他文件加载而导致的渲染块:</p>
<p><img data-attachment-id="142302" data-permalink="https://blog.logrocket.com/css-vs-css-in-js/attachment/img1-graphic-showing-difference-file-loading-http1-http2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.png" data-orig-size="730,502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graphic-showing-difference-file-loading-HTTP1-HTTP2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2-300x206.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.png" decoding="async" src="../Images/1071897e339347e96346f15542b57d7e.png" alt="Graphic Separated Into Top And Bottom Sections. Top Section Shows In Red How Http 1.1 Loads Js Css And Html Files Sequentially. Bottom Section Shows In Green How Js Css And Html Files Load In Parallel. Bottom Text Explains How This Makes Http 2 Much Faster Than Http 1.1" class="aligncenter size-full wp-image-142302 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2-300x206.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142302" data-permalink="https://blog.logrocket.com/css-vs-css-in-js/attachment/img1-graphic-showing-difference-file-loading-http1-http2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.png" data-orig-size="730,502" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Graphic-showing-difference-file-loading-HTTP1-HTTP2" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2-300x206.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.png" decoding="async" loading="lazy" src="../Images/1071897e339347e96346f15542b57d7e.png" alt="Graphic Separated Into Top And Bottom Sections. Top Section Shows In Red How Http 1.1 Loads Js Css And Html Files Sequentially. Bottom Section Shows In Green How Js Css And Html Files Load In Parallel. Bottom Text Explains How This Makes Http 2 Much Faster Than Http 1.1" class="aligncenter size-full wp-image-142302" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2-300x206.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/img1-Graphic-showing-difference-file-loading-HTTP1-HTTP2.png"/></noscript>
<p>然而，除了文件加载速度之外，渲染阻塞还涉及其他因素。</p>
<p>假设我们的应用程序的一个页面有很多CSS。它可能包含选择器，这些选择器甚至没有被使用过，但是因为我们在每个页面上导入了一个主CSS文件而存在。</p>
<p>上面的场景基本上描述了我们是如何习惯于直接使用一个<a href="https://blog.logrocket.com/comparing-tailwind-css-bootstrap-time-ditch-ui-kits/"> CSS UI框架或者一个UI工具包</a>来快速简化我们的设计系统。并非所有从该框架或工具包引用的样式都会在每个页面上使用。结果，我们最终页面的CSS样式中会有更多的垃圾。</p>
<p>CSS越多，浏览器构建CSSOM的时间就越长，导致完全不必要的渲染阻塞。</p>
<p>为了解决这个问题，将CSS分成小块是非常有帮助的。换句话说，将全局样式和关键CSS保存在一个通用CSS文件中，然后将其他内容组件化。这种策略更有意义，并且解决了不必要的阻塞问题:</p>
<p><img data-attachment-id="142306" data-permalink="https://blog.logrocket.com/css-vs-css-in-js/attachment/img2-project-structure-componentized-css/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS.png" data-orig-size="730,536" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Project-structure-componentized-CSS" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS-300x220.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS.png" decoding="async" src="../Images/bbf0ab8fed2ae37273f55fe7b5a7c8d9.png" alt="Visual Studio Code Window Open Over Colorful Leafy Background. Window Shows Example File Structure With Label Pointing To Different Css Components To Show How Componentizing Or Splitting Css Helps With Organization" class="aligncenter size-full wp-image-142306 jetpack-lazy-image" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS-300x220.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="142306" data-permalink="https://blog.logrocket.com/css-vs-css-in-js/attachment/img2-project-structure-componentized-css/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS.png" data-orig-size="730,536" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Project-structure-componentized-CSS" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS-300x220.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS.png" decoding="async" loading="lazy" src="../Images/bbf0ab8fed2ae37273f55fe7b5a7c8d9.png" alt="Visual Studio Code Window Open Over Colorful Leafy Background. Window Shows Example File Structure With Label Pointing To Different Css Components To Show How Componentizing Or Splitting Css Helps With Organization" class="aligncenter size-full wp-image-142306" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS-300x220.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/img2-Project-structure-componentized-CSS.png"/></noscript>
<p>上图显示了在React中为不同组件创建和管理单独CSS文件的传统方式。因为每个CSS文件都直接附加到其各自的组件，所以它只在导入相关组件时才导入，而在移除该组件时消失。</p>
<p>这种方法有一个缺点。假设我们的应用程序包含100个组件，从事同一项目的其他开发人员无意中在这些CSS文件中使用了相同的类名。</p>
<p>在这里，每个组件的每个CSS文件的范围都是全局的，所以这些偶然复制的样式会不断地覆盖彼此并得到全局应用。像这样的场景将导致严重的布局和设计不一致。</p>
<p>据说CSS-in-JS可以解决这个范围问题。接下来的部分将从高层次上回顾CSS-in-JS，并讨论它是否一劳永逸地有效解决了作用域问题。</p>
<h2 id="what-css-in-js-offers">CSS-in-JS提供了什么</h2>
<p>简而言之，CSS-in-JS是一个外部功能层，允许您通过JavaScript为组件编写CSS属性。</p>
<p>这一切都始于2015年的一个名为JSS的JavaScript库，该库目前仍在积极维护中。您必须使用JavaScript语法向选择器提供CSS属性，一旦页面加载，这些属性就会自动应用于各自的选择器。</p>
<p>当JavaScript接管了React等库的前端渲染和管理时，一个名为styled-components 的<a href="https://blog.logrocket.com/how-style-react-router-links-styled-components/"> CSS-in-JS解决方案出现了。另一个越来越受欢迎的方法是通过</a><a href="https://blog.logrocket.com/styled-components-vs-emotion-for-handling-css/">使用情感库</a>。</p>
<p>我们将展示一个带有样式化组件库的CSS-in-JS用例，因为这是在React中使用CSS-in-JS最流行的方式。</p>
<h3>将CSS-in-JS用于样式化组件的示例</h3>
<p>在React应用程序中，使用下面的Yarn命令安装样式组件库。如果您正在使用不同的软件包管理器，请查看<a href="https://styled-components.com/docs/basics#installation">风格组件安装文档</a>以找到合适的安装命令:</p>
<pre class="language-bash hljs">yarn add styled-components
</pre>
<p>安装好样式组件库后，导入<code>styled</code>函数，如下面的代码所示使用它:</p>
<pre class="language-javascript hljs">import styled from "styled-components";

const StyledButton = styled.a`
  padding: 0.75em 1em;
  background-color: ${ ({ primary }) =&gt; ( primary ? "#07c" : "#333" ) };
  color: white;

  &amp;:hover {
    background-color: #111;
  }
`;

export default StyledButton;
</pre>
<p>如果您没有React环境的访问权限，这里有一个CodePen演示供您查看上面的代码:</p>
<p class="codepen" data-height="500" data-theme-id="0" data-default-tab="result" data-user="_rahul" data-slug-hash="oNywWXR" data-pen-title="“" demoing="" css-in-js="" with="" styled-components="">参见<a href="https://codepen.io"> CodePen </a>上Rahul Chhodde(<a href="https://codepen.io/_rahul">@ _ Rahul</a>)<br/>的带CSS 的Pen <a href="https://codepen.io/_rahul/pen/dyeZeGL">下拉菜单。</a></p>
<p/>
<p>上面的代码演示了如何在React中设计一个按钮链接组件的样式。这种样式化的组件现在可以导入到任何地方，并直接用于构建功能性组件，而不必担心样式:</p>
<pre class="language-javascript hljs">import StyledButton from './components/styles/Button.styled';

function App() {
  return (
    &lt;div className="App"&gt;
      ...
      &lt;StyledButton href="..."&gt;Default Call-to-action&lt;/StyledButton&gt;
      &lt;StyledButton primary href="..."&gt;Primary Call-to-action&lt;/StyledButton&gt;
    &lt;/div&gt;
  );
}

export default App;
</pre>
<p>请注意，应用于样式化组件的样式是局部范围的，这消除了留意CSS类命名和全局范围的麻烦。此外，我们可以根据提供给组件的道具或应用程序功能所需的任何其他逻辑来动态添加或删除CSS。</p>
<h2 id="pros-css-in-js">CSS-in-JS的优点</h2>
<p>JavaScript开发人员可能更喜欢用CSS-in-JS来设计东西，而不是通过CSS类。JS中的CSS方法解决的最大问题是全局范围。如果您是一名JavaScript开发人员，它还具有其他一些非常有意义的优势。</p>
<p>现在让我们来探讨一下这些好处。</p>
<h3>没有范围和特殊性问题</h3>
<p>由于样式在局部范围内可用，它们不容易与其他组件的样式冲突。你甚至不必担心命名的事情严格避免风格冲突。</p>
<p>样式是专门为一个组件编写的，没有预先考虑子选择器，所以很少出现特殊性问题。</p>
<h3>动态造型</h3>
<p>条件CSS是CSS-in-JS的另一个亮点。如上面的按钮示例所示，检查属性值并添加合适的样式比为每个变体编写单独的CSS样式要酷得多。</p>
<h3>较少CSS特异性</h3>
<p>CSS-in-JS帮助您将CSS声明的特异性保持在最低水平，因为您唯一可以使用它的是元素本身。这同样适用于创建组件变体，您可以检查属性对象值，并在需要时添加动态样式。</p>
<h3>轻松主题化</h3>
<p>使用自定义CSS属性为应用程序设置主题是有意义的。最后，您必须转到JavaScript端，编写逻辑来根据用户输入切换和记住主题。</p>
<p>CSS-in-JS允许你完全用JavaScript编写主题逻辑。使用styled-components <code>ThemeProvider</code>包装器，您可以快速地对组件的主题进行颜色编码。看一下<a href="https://codepen.io/_rahul/pen/qBKXevo">这个CodePen示例</a>，看看组件主题化和样式化组件的作用:</p>
<p class="codepen" data-height="500" data-theme-id="0" data-default-tab="result" data-user="_rahul" data-slug-hash="qBKXevo" data-pen-title="“Dropdown" menus="" with="" css="">参见<a href="https://codepen.io"> CodePen </a>上Rahul Chhodde(<a href="https://codepen.io/_rahul">@ _ Rahul</a>)<br/>用样式组件库进行的笔<a href="https://codepen.io/_rahul/pen/qBKXevo">组件主题化。</a></p>
<p>无痛维护</p>
<h3>考虑到CSS-in-JS提供的特性和优势，JavaScript开发人员可能会发现CSS-in-JS比管理数百个CSS文件更方便。</h3>
<p>然而，事实是，要有效地管理和维护由CSS-in-JS驱动的大型项目，必须对JavaScript和CSS都有很好的理解。</p>
<p>CSS-in-JS的缺点</p>
<h2 id="cons-css-in-js">CSS-in-JS确实很好地解决了范围问题。但正如我们最初讨论的那样，我们面临着更大的挑战，比如渲染阻塞，这直接影响了用户体验。除此之外，CSS-in-JS的概念还需要解决其他一些问题。</h2>
<p>延迟渲染</p>
<h3>CSS-in-JS将执行JavaScript从JavaScript组件中解析CSS，然后将这些解析的样式注入DOM。组件越多，浏览器第一次绘制花费的时间就越长。</h3>
<p>缓存问题</p>
<h3>CSS缓存通常用于改善连续页面加载时间。由于使用CSS-in-JS时不涉及CSS文件，所以缓存是个大问题。此外，动态生成的CSS类名使得这个问题更加复杂。</h3>
<p>不支持CSS预处理程序</p>
<h3>使用常规的组件化CSS方法，很容易添加对SASS 、Less、PostCSS等预处理程序的支持。这在CSS-in-JS中是不可能的。</h3>
<p>混乱的DOM</p>
<h3>CSS-in-JS的思想是将JavaScript中的所有样式定义解析成普通的CSS，然后使用样式块将样式注入DOM。</h3>
<p>对于每个使用CSS-in-JS样式的组件，可能有100个样式块必须首先被解析，然后被注入。简单来说，会有更多的管理费用。</p>
<p>库依赖性</p>
<h3>正如我们已经知道的，我们可以用外部库添加CSS-in-JS功能。在实际的CSS解析之前，将包含并运行大量的JavaScript，因为从JavaScript到CSS样式的解析样式依赖于styled-components之类的库。</h3>
<p>学习曲线</p>
<h3>CSS-in-JS缺少许多原生CSS和SCSS特性。对于习惯了CSS和SCSS的开发者来说，适应CSS-in-JS可能是非常具有挑战性的。</h3>
<p>没有广泛的支持</p>
<h3>大多数UI和组件库现在都不支持CSS-in-JS方法，因为它仍然有许多问题需要解决。</h3>
<p>上面讨论的问题可能共同导致一个低性能、难以维护的产品，它有几个UI和UX不一致的地方。</p>
<p>关于在哪里使用CSS-in-JS的建议</p>
<h2 id="recommendations-where-use-css-in-js">当您处理一个较小的应用程序，性能是较低的优先级时，CSS-in-JS解决方案是理想的。在处理具有庞大设计系统的性能关键型应用程序时，这可能并不理想。</h2>
<p>随着应用程序变得越来越大，考虑到这个概念的所有缺点，使用CSS-in-JS很容易变得复杂。将一个设计系统转换成CSS-in-JS需要做大量的工作，在我看来，没有一个JavaScript开发人员想要处理这些。</p>
<p>CSS模块概述</p>
<h2 id="overview-css-module">一个<a href="https://blog.logrocket.com/a-deep-dive-into-css-modules/"> CSS模块是一个CSS文件</a>,其中所有的属性默认情况下都在呈现的CSS中的本地范围内。JavaScript进一步处理CSS模块文件，并封装它们的样式声明来解决作用域问题。</h2>
<p>要使用CSS模块，您需要用扩展名<code>.module.css</code>命名您的CSS文件，然后将它们导入JavaScript文件。下面的代码片段提供了一个如何使用CSS模块的基本示例:</p>
<p>看看这个在React 中实现CSS模块的<a href="https://stackblitz.com/edit/react-hbivvp?file=src/components/Button/Button.module.css"> StackBlitz示例。这个例子展示了如何使用CSS模块来解决作用域问题。</a></p>
<pre class="language-javascript hljs">import styles from './Button.module.css';

export default function Button(props) {
  return (
    &lt;a
      href={props.href ? props.href : '#'}
      className={styles.btn}
    &gt;
      {props.name}
    &lt;/a&gt;
  );
}
</pre>
<p>在StackBlitz示例中，注意如何智能地处理和优化<code>Button.module.css</code>和<code>AnotherButton.module.css</code>中的相同类名，以防止命名冲突。</p>
<p>CSS模块的优点</p>
<h2 id="pros-css-module">CSS模块提供的最大好处是消除了对CSS-in-JS的依赖，从而解决了范围和特性问题。如果我们可以通过尽可能保持CSS的传统性来解决范围和特性问题，那么CSS-in-JS将会是多余的工作。</h2>
<p>没有范围和特殊性问题</p>
<h3>如上面的例子所示，CSS模块成功地解决了传统的旧式CSS的作用域问题。由于规则是松散地写在CSS模块文件中的，所以很难观察到任何特殊性问题。</h3>
<p>有组织的代码</p>
<h3>保存单独的CSS文件似乎是一种限制。然而，这种方法实际上促进了更好的组织。例如，下面是我如何通过将组件分离到它们自己的文件夹中来组织它们:</h3>
<p>缓存可能性</p>
<pre>- Project
  - src
    - components
      - Button
          - Button.jsx
          - Button.modules.css
      - Carousel
          - Carousel.jsx
          - Carousel.modules.css
</pre>
<h3>浏览器可以缓存最终版本生成的缩小的CSS文件，以提高连续页面加载时间。</h3>
<p>CSS预处理</p>
<h3>很容易添加对PostCSS 、SASS、Less等<a href="https://blog.logrocket.com/using-postcss-media-queries-level4/"> CSS预处理程序的支持。然而，你必须依靠额外的软件包来完成。</a></h3>
<p>零学习曲线</p>
<h3>如果你知道CSS是如何工作的，你可以使用CSS模块，而不需要学习任何新的东西，除了我们在上面介绍部分讨论的几点。</h3>
<p>大力支持</p>
<h3>你不需要添加额外的包来使用CSS模块。所有主要的框架和库都提供内置支持。</h3>
<p>CSS模块的缺点</p>
<h2 id="cons-css-module">虽然CSS模块提供了许多好处，但它并不是一个完美的解决方案。以下是一些需要记住的注意事项。</h2>
<p>非标准的<code>:global</code>属性</p>
<h3>当在全局范围内定位选择器时，必须使用<code>:global</code>规则。这不是CSS规范的一部分，但是JavaScript使用它来标记全局样式。</h3>
<p>没有动态样式</p>
<h3>对于CSS模块，所有的声明都放在单独的CSS文件中。因此，不可能实现像CSS-in-JS这样的动态样式，因为我们不能在CSS文件中实现任何JavaScript。</h3>
<p>外部CSS文件</p>
<h3>你不能忽略CSS文件和组件中CSS模块的使用。使用CSS模块的唯一可能方式是维护和导入外部CSS文件。</h3>
<p>打字限制</p>
<h3>要在TypeScript中使用CSS模块，您必须在<code>index.d.ts</code>文件中添加模块定义，或者<a href="https://blog.logrocket.com/how-to-configure-css-modules-webpack/">使用webpack加载器</a>:</h3>
<p>在哪里使用CSS模块的建议</p>
<pre class="language-typescript hljs">/** index.d.ts **/
declare module "*.module.css";  // TS module for CSS Module files
declare module "*.module.scss"; // TS module for CSS Module files in SCSS format
</pre>
<h2 id="recommendations-where-use-css-module">如果您有一个具有大UI的性能关键型应用程序，使用CSS模块是一个不错的选择。由于CSS模块提供的一切最终都是基于传统的、非实验性的使用，这种方法使得监控和修复性能变得更加容易。</h2>
<p>CSS模块文件很容易从你选择的任何CSS框架中改编代码，因为你处理的只是CSS。如前所述，CSS的一些基本知识足以完成这项任务。</p>
<p>值得关注的现代CSS功能</p>
<h2 id="modern-css-features-watch">在引言中，我提到了一些现代CSS特性如何在不依赖CSS模块、CSS-in-JS或任何其他JavaScript解决方案的情况下帮助解决未来的作用域问题。</h2>
<p>新的和计划中的特性——比如范围指令和<code>@scope</code>伪元素——旨在解决传统CSS的老问题。反过来，这可能会减少开发人员求助于CSS-in-JS等方法来解决这些问题的需要。</p>
<p>让我们看看当前的作用域CSS草案如何解决JS中的CSS甚至CSS模块的问题。关于其他现代CSS特性的完整列表，请查看CSS 2022的状态。</p>
<p>CSS作用域的潜在未来</p>
<h3>在奇怪的引入和从CSS规范中删除了 <code><a href="https://github.com/whatwg/html/issues/552">&lt;style scope&gt;</a></code>之后，<a href="https://drafts.csswg.org/css-cascade-6/#scoped-styles">当前的CSS </a>草案看起来足够好，可以通过编写CSS规则来定义元素的范围前提。</h3>
<p>它目前的状态包括使用一个指令和一个伪类来控制给定元素的范围设置。下面是它如何在边界内锁定一个元素的作用域，并在不考虑cascade的作用域规则的情况下维护它的大致情况:</p>
<p>这个新特性可以消除CSS模块或CSS-in-JS来解决作用域问题的需要。我们必须拭目以待，直到它在我们的浏览器中可用。</p>
<pre class="language-css hljs">&lt;div class="card"&gt;
  &lt;img src="..."&gt;
  &lt;div class="content"&gt;
    &lt;p&gt;...&lt;/p&gt;
  &lt;/div&gt;&lt;!-- .content --&gt;
&lt;/div&gt;&lt;!-- .card --&gt;

&lt;style&gt;
@scope (.card) {
  :scope {
    display: grid;
    ...
  }
  img {
    object-fit: cover;
    ...
  }
  .content { ... }
}
&lt;/style&gt;
</pre>
<p>结论</p>
<h2 id="conclusion">上面，我们讨论了CSS渲染阻塞如何成为web应用程序的主要性能问题。然后，我们讨论了解决这个问题的一些解决方案，这让我们探索了CSS-in-JS、CSS模块以及新的CSS功能的官方进展草案的当前状态。</h2>
<p>喜欢JavaScript的开发人员喜欢CSS-in-JS，因为它几乎涵盖了JavaScript的所有样式方面。另一方面，那些喜欢CSS的人——希望当前的技术能够平等地支持开发者和最终用户——可能更喜欢CSS模块。</p>
<p>我希望你喜欢这篇文章。请在评论中告诉我你的想法、问题和建议。</p>
<p>你的前端是否占用了用户的CPU？</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>随着web前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端CPU使用、内存使用等感兴趣，</h2><p>.</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>LogRocket 就像是网络和移动应用的DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>现代化您调试web和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p><p>Modernize how you debug web and mobile apps — <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Simplify proxy state with Valtio - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 Valtio - LogRocket 博客简化代理状态</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/simplify-proxy-state-with-valtio/#0001-01-01">https://blog.logrocket.com/simplify-proxy-state-with-valtio/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React 中的状态管理是开发人员有时会忽略的一个问题。总会有一些新的库，为您的应用程序选择正确的库可能是一项相当困难的工作。</p>
<p>对于每一个现代应用程序来说，拥有一个状态管理库是至关重要的，在选择库的时候有很多需要考虑的地方。</p>
<p>我们将使用一个名为<a href="https://github.com/pmndrs/valtio" target="_blank" rel="noopener"> Valtio </a>的新状态管理库，这个库使得 JavaScript 和 React 应用程序的代理状态变得简单。</p>
<h2>什么是代理？</h2>
<p>代理是一种计算机软件模式。代理是一些可以拥有自定义行为的对象的包装。我们几乎可以代理任何东西，比如网络连接、对象、文件等等。代理的工作方式不同，但在结构上类似于<a href="https://en.wikipedia.org/wiki/Adapter_pattern" target="_blank" rel="noopener">适配器</a>和<a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="noopener">装饰器</a>。</p>
<blockquote><p>代理是一个包装对象，客户端调用它来访问幕后的真实服务对象</p></blockquote>
<p>代理是<a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener"> GoF 设计模式</a>的一部分，这本书是由<a href="https://en.wikipedia.org/wiki/Erich_Gamma" target="_blank" rel="noopener">埃里希·伽马</a>、<a href="https://en.wikipedia.org/?title=Richard_Helm&amp;redirect=no" target="_blank" rel="noopener">理查德·赫尔姆</a>、<a href="https://en.wikipedia.org/wiki/Ralph_Johnson_%28computer_scientist%29" target="_blank" rel="noopener">拉尔夫·约翰逊</a>和<a href="https://en.wikipedia.org/wiki/John_Vlissides" target="_blank" rel="noopener">约翰·维里西德斯</a>撰写的。作者探索了面向对象编程和 23 种软件设计模式的能力。</p>
<p>代理可以帮助开发人员解决现代应用程序中反复出现的问题。代理更容易，因为它们帮助我们处理对象，它们对于验证、跟踪属性访问、web 服务、监控对象等情况非常有用。它们是更容易放置、更改、测试和重用的对象。</p>
<p>代理有两条规则:</p>
<ul>
<li>应该控制对对象的访问</li>
<li>当访问一个对象时，应该提供额外的功能</li>
</ul>
<p>从 ES6 版本开始，我们在 JavaScript 中提供了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">代理</a>。一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">代理</a>接收两个参数:</p>
<ul>
<li><code>target</code>–您想要代理的原始对象</li>
<li><code>handler</code>–将定义操作的对象</li>
</ul>
<p>这就是我们如何使用 JavaScript 创建一个简单的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">代理</a>:</p>
<pre>const target = {
  addition: () =&gt; 2 + 2,
  subtraction: () =&gt; 2 - 2,
};

const handler = {
  get: function(target, prop, receiver) {
    return target;
  },
};

const proxy = new Proxy(target, handler);

console.log(proxy.addition()); // 4
console.log(proxy.subtraction()); // 0
</pre>
<p>代理是一种非常强大的设计模式，用于观察对象并对其进行更改。它允许我们为对象设计自定义行为。</p>
<p>想象一下，如果我们可以在 React 应用程序中做到这一点。利用代理来处理我们的状态数据。我们不再需要建立庞大的状态管理库来处理我们所有的状态。有了瓦提奥，我们可以！</p>
<h2>州政府</h2>
<p>Valtio 是一个为 React 和 JavaScript 应用程序简化代理状态的库。</p>
<p>它是由一个名为<a href="https://github.com/pmndrs" target="_blank" rel="noopener"> Poimandres </a>的开源团体创建的。这个开源集体负责 React 社区中的其他重要库，比如<a href="https://github.com/pmndrs/react-spring" target="_blank" rel="noopener"> react-spring </a>、<a href="https://github.com/pmndrs/zustand" target="_blank" rel="noopener"> zustand </a>、<a href="https://github.com/pmndrs/react-three-fiber" target="_blank" rel="noopener"> react-three-fiber </a>、<a href="https://github.com/pmndrs/react-use-gesture" target="_blank" rel="noopener">React-use-手势</a>。</p>
<p>我们需要做的是包装我们的状态对象，然后我们可以在应用程序中的任何地方改变它:</p>
<pre>import { proxy } from 'valtio'

const state = proxy({ count: 0 });
() =&gt; { ++state.count };
</pre>
<p><a href="https://github.com/pmndrs/valtio" target="_blank" rel="noopener"> Valtio </a>有一个名为<code>useProxy</code>的钩子帮助我们从快照中读取数据。只有当组件正在访问的状态部分发生变化时，<code>useProxy</code>钩子才会重新呈现我们的组件:</p>
<pre>const Counter = () =&gt; {
  const snapshot = useProxy(state);
  return (
    &lt;div&gt;
      {snapshot.count}
      &lt;button onClick={() =&gt; ++state.count}&gt;Add&lt;/button&gt;
    &lt;/div&gt;
  );
};
</pre>
<p><a href="https://github.com/pmndrs/valtio" target="_blank" rel="noopener"> Valtio </a>有一个非常强大的功能叫做<code>subscribe</code>。我们可以从任何地方订阅我们的状态，并在组件中使用它。</p>
<p>想象一下，我们有一个非常复杂的代理状态，有一堆不同的状态。在我们的代理状态中，我们有一个身份验证状态，我们用它来知道用户何时通过身份验证:</p>
<pre>import { proxy } from 'valtio'

const state = proxy({
  authenticated: false,
  settings: { ... },
  filters: { ... },
  ...
});
</pre>
<p>我们可以使用<code>subscribe</code>函数订阅我们状态的特定部分。<code>subscribe</code>函数接受两个参数，状态和回调。<code>state</code>是我们想要订阅的州的哪一部分。<code>callback</code>是一个回调函数，当状态改变时会被触发；</p>
<pre>subscribe(state.authenticated, () =&gt; console.log('State changed to', state.authenticated));
</pre>
<p><a href="https://github.com/pmndrs/valtio" target="_blank" rel="noopener">瓦尔蒂奥</a>也有一个叫做<code>subscribeKey</code>的函数，类似于<code>subscribe</code>函数。<code>subscribeKey</code>将订阅一个状态代理的原始属性。只有当指定的属性发生变化时，它才会被触发:</p>
<pre>subscribeKey(state.authenticated, () =&gt; console.log('Authenticated state changed to', state.authenticated));
</pre>
<p>虽然现在普通 JavaScript 可能不太常见，但是<a href="https://github.com/pmndrs/valtio" target="_blank" rel="noopener"> Valtio </a>的另一个特性是它可以用在普通 JavaScript 应用程序中:</p>
<pre>import { proxy, subscribe, snapshot } from 'valtio/vanilla'

const state = proxy({ books: [...], isAuthenticated: false })

subscribe(state, () =&gt; {
  console.log('state:')
  const obj = snapshot(state);
})
</pre>
<p>现在我们对<a href="https://github.com/pmndrs/valtio" target="_blank" rel="noopener"> Valtio </a>有了一点了解，让我们看看它在实践中是如何工作的。我们将使用<a href="https://github.com/pmndrs/valtio" target="_blank" rel="noopener"> Valtio </a>为 React 中的状态代理创建一个简单的示例应用程序，并看看它的好处。</p>
<h2>入门指南</h2>
<p>我们将使用<a href="https://create-react-app.dev/docs/getting-started/" target="_blank" rel="noopener"> Create React App </a>创建一个新的应用程序:</p>
<pre>npx create-react-app simple-state-with-valtio
</pre>
<p>现在我们将安装<a href="https://github.com/pmndrs/valtio" target="_blank" rel="noopener"> Valtio </a>:</p>
<pre>yarn add valtio
</pre>
<p>首先，我们将从 Valtio 导入函数<code>proxy</code>和<code>useProxy</code>。<code>proxy</code>函数用于创建新的代理状态。<code>useProxy</code>函数用于在我们的 React 组件上创建一个本地快照，以监视更改:</p>
<pre>import { proxy, useProxy } from 'valtio'
</pre>
<p>现在，我们将创建我们的代理状态。我们的状态中有三个属性<code>firstName</code>、<code>lastName</code>和<code>users</code>:</p>
<pre>const state = proxy({ firstName: "", lastName: "", users: [{}] })
</pre>
<p>在我们的组件中，我们将有一个表单、两个输入和一个按钮。我们将跟踪每个输入的变化，并将其存储在我们的状态代理中。该按钮将用于提交我们的表单:</p>
<pre>const App = () =&gt; {
  return (
    &lt;form&gt;
      &lt;input type="text" /&gt;
      &lt;input type="text" /&gt;
      &lt;button type="submit"&gt;Create&lt;/button&gt;
    &lt;/form&gt;
    );
}
</pre>
<p>在我们的组件内部，我们将使用<code>useProxy</code>钩子创建一个快照。该快照将用于从代理状态获取状态数据，并在状态发生变化时更新数据:</p>
<pre>const App = () =&gt; {
  const snapshot = useProxy(state, { sync: true });
  return (
    &lt;form&gt;
      &lt;input type="text" /&gt;
      &lt;input type="text" /&gt;
      &lt;button type="submit"&gt;Create&lt;/button&gt;
    &lt;/form&gt;
  );
}
</pre>
<p>注意，我们向<code>useProxy</code>函数传递了第二个参数。第二个参数是一个对象，我们告诉 Valtio 在触发 rerender 之前进行批处理。</p>
<p>现在，在我们的输入中，对于每个输入，我们将把值设置为我们的代理状态，并从我们的<code>snapshot</code>中读取值，就像这样:</p>
<pre>const App = () =&gt; {
  const snapshot = useProxy(state, { sync: true });
return (
    &lt;form&gt;
      &lt;input type="text" value={snapshot.firstName} onChange={(e) =&gt; (state.firstName = e.target.value)} /&gt;
      &lt;input type="text" value={snapshot.lastName} onChange={(e) =&gt; (state.lastName = e.target.value)} /&gt;
      &lt;button type="submit"&gt;Create&lt;/button&gt;
    &lt;/form&gt;
  );
}
</pre>
<p>现在，我们需要创建提交函数来提交表单。在我们的函数中，我们将创建一个新的用户分组<code>firstName</code>和<code>lastName</code>值，并将其推送到<code>users</code>数组。在新用户被推送到<code>users</code>数组后，我们希望将<code>firstName</code>和<code>lastName</code>的值都改为一个空字符串:</p>
<pre>const App = () =&gt; {
  const snapshot = useProxy(state, { sync: true });
  const handleSubmit = (e: any) =&gt; {
    e.preventDefault();
    const newUser = { firstName: state.firstName, lastName: state.lastName };
    state.users.push(newUser);
    state.firstName = "";
    state.lastName = "";
  }
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input type="text" value={snapshot.firstName} onChange={(e) =&gt; (state.firstName = e.target.value)} /&gt;
      &lt;input type="text" value={snapshot.lastName} onChange={(e) =&gt; (state.lastName = e.target.value)} /&gt;
      &lt;button type="submit"&gt;Create&lt;/button&gt;
    &lt;/form&gt;
  );
}
</pre>
<p>现在，我们的组件工作得非常好。我们能够使用 Valtio 管理我们的状态值，并向我们的代理状态提交新用户。现在唯一缺少的是显示用户数量的方法。</p>
<p>我们将再次使用<code>snapshot</code>并映射到我们的用户数组，对于每个用户，我们将显示一个<code>h1</code>元素:</p>
<pre>const App = () =&gt; {
  const snapshot = useProxy(state, { sync: true });
const handleSubmit = (e: any) =&gt; {
    e.preventDefault();
    const newUser = { firstName: state.firstName, lastName: state.lastName };
    state.users.push(newUser);
    state.firstName = "";
    state.lastName = "";
  }
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input type="text" value={snapshot.firstName} onChange={(e) =&gt; (state.firstName = e.target.value)} /&gt;
      &lt;input type="text" value={snapshot.lastName} onChange={(e) =&gt; (state.lastName = e.target.value)} /&gt;
      &lt;button type="submit"&gt;Create&lt;/button&gt;

      &lt;div&gt;
        {snapshot.users.map((user: any) =&gt; (&lt;h1&gt;Hello {user.firstName} {user.lastName}&lt;/h1&gt;))}
      &lt;/div&gt;
    &lt;/form&gt;
  );
}
</pre>
<p>Valtio 背后的<a href="https://github.com/pmndrs" target="_blank" rel="noopener">集体</a>在 React 社区中非常重要且受到尊重。他们也是重要项目的作者，如<a href="https://github.com/pmndrs/zustand" target="_blank" rel="noopener"> zustand </a>、<a href="https://github.com/pmndrs/react-spring" target="_blank" rel="noopener"> react-spring </a>、<a href="https://github.com/pmndrs/react-three-fiber" target="_blank" rel="noopener"> react-three-fiber </a>等。</p>
<p>随着一群 T2 人和开发者愿意为这个项目做贡献，Valtio 图书馆的未来是非常光明的。</p>
<h2>结论</h2>
<p>状态数据对于现代应用程序来说是必不可少的。Valtio 简单、强大，结合了 React 和 JavaScript 中代理的力量，使得状态数据易于使用和更改。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">使用 LogRocket 消除传统反应错误报告的噪音</h2>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" vwo-el-id="19356441070">LogRocket
</a><p>是一款 React analytics 解决方案，可保护您免受数百个误报错误警报的影响，只针对少数真正重要的项目。LogRocket 告诉您 React 应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<a href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="35866400580">LogRocket
</a><p>自动聚合客户端错误、反应错误边界、还原状态、缓慢的组件加载时间、JS 异常、前端性能指标和用户交互。然后，LogRocket 使用机器学习来通知您影响大多数用户的最具影响力的问题，并提供您修复它所需的上下文。</p><p vwo-el-id="28675661060">关注重要的 React bug—<a class="signup" href="https://lp.logrocket.com/blg/react-signup-issue-free" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">今天就试试 LogRocket】。</a></p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
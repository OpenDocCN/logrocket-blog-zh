<html>
<head>
<title>Introducing Turbopack: A Rust-based successor to webpack </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Turbopack简介:基于Rust的webpack的继任者</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/#0001-01-01">https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/#0001-01-01</a></blockquote><div><article class="article-post">
<p>很久以前，在web开发中，构建网页只需要HTML、CSS和一些JavaScript来实现交互性。这是大多数网站的典型代码结构:</p>
<p><img data-attachment-id="143688" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/typical-code-structure-most-websites/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites.png" data-orig-size="730,458" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typical-code-structure-most-websites" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites-300x188.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites.png" decoding="async" class="aligncenter wp-image-143688 size-full jetpack-lazy-image" src="../Images/c49581b661a9f71c9dc8d539366ac1b9.png" alt="The typical code structure of most websites" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites-300x188.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143688" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/typical-code-structure-most-websites/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites.png" data-orig-size="730,458" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="typical-code-structure-most-websites" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites-300x188.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites.png" decoding="async" loading="lazy" class="aligncenter wp-image-143688 size-full" src="../Images/c49581b661a9f71c9dc8d539366ac1b9.png" alt="The typical code structure of most websites" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites-300x188.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/typical-code-structure-most-websites.png"/></noscript>
<p>大多数情况下，开发人员会引入第三方JavaScript库来获得额外的交互性:</p>
<p><img data-attachment-id="143693" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/third-party-javascript-libraries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries.png" data-orig-size="730,792" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="third-party-javascript-libraries" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries-277x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries.png" decoding="async" class="aligncenter wp-image-143693 size-full jetpack-lazy-image" src="../Images/dde0436c1501c9a27ed6fd7f88269ba7.png" alt="Third-party JavaScript libraries for extra interactivity" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries-277x300.png 277w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143693" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/third-party-javascript-libraries/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries.png" data-orig-size="730,792" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="third-party-javascript-libraries" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries-277x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries.png" decoding="async" loading="lazy" class="aligncenter wp-image-143693 size-full" src="../Images/dde0436c1501c9a27ed6fd7f88269ba7.png" alt="Third-party JavaScript libraries for extra interactivity" srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries-277x300.png 277w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/third-party-javascript-libraries.png"/></noscript>
<p>在此期间，JavaScript被视为客户端脚本语言，仅此而已。这种情况很快就会改变，尤其是随着Node.js的引入</p>
<p>Node.js证明了JavaScript不仅仅具有客户端功能，还可以处理网络请求、路由、复杂动画和存储。</p>
<p>然后，我们开始构建大规模产品，如电子商务网站、社交媒体应用、学习平台等。，用JavaScript。这引入了更多的第三方库，但是由于内容交付网络(cdn)当时并不流行，所以你必须下载库的JS文件。这使得代码混乱且难以维护，开发人员的体验也很糟糕。</p>
<p>在此期间，不断进步的JS社区开始关注用开发工具改善开发人员的体验。这导致了bundlers的诞生。</p>
<p><em>向前跳转:</em></p>

<h2 id="what-are-bundlers">什么是捆扎机？</h2>
<p>bundler是一个简单的开发工具，它将所有JS文件作为输入进行聚合，并输出一个可在web浏览器上加载的JS文件。捆绑器确保所有源代码和第三方依赖项都是最新的并且没有错误。</p>
<p>在捆绑代码时代之前，优化和日志记录是主要问题。捆扎机通过以下功能解决了这一问题:</p>
<ul>
<li>代码拆分</li>
<li>热模块更换(HMR)</li>
<li>记录器</li>
</ul>
<h3>那么bundlers是如何在幕后工作的呢？</h3>
<ul>
<li>依赖关系解析:捆绑器生成所有服务文件的依赖关系图</li>
<li>捆绑:捆绑器输出浏览器可以解析的静态资产。这个过程被称为包装</li>
</ul>
<p>像Browserify这样的捆绑器从2010年就已经存在，使用<code>require</code>在浏览器中加载npm包。然而，JavaScript在ES2015推出之前没有内置的模块系统。随后的新一轮模块化编程浪潮导致了webpack、Rollup、Parcel和esbuild等模块捆绑器的诞生。</p>
<p>在所有捆绑软件中，webpack最先获得了所有人的关注，目前是使用最多的捆绑软件，周下载量约为2800万次。</p>
<h2 id="webpack-approaches-dependency-resolution">webpack如何解决依赖关系</h2>
<p>webpack是一个静态模块捆绑器。当引入到一个项目中时，它从一个或多个入口点(更像<code>index.js</code>)生成一个依赖图，并将所有模块(JS和非JS)组合成一个包——或者更多，这取决于您的配置。</p>
<p>这些包变成了浏览器可以处理的静态文件(HTML、CSS、JS、assets)。它不需要任何配置来捆绑您的项目，但是非常易于配置。</p>
<p>让我们简单地看一下webpack是如何解决依赖关系的。</p>
<ul>
<li><strong>入口</strong> <b>点</b>:这是webpack构建内部依赖图的起点。默认情况下，它是一个<code>index.js</code>文件，但是您可以选择不同的入口点或多个入口点</li>
</ul>
<pre class="language-javascript hljs">webpack.config.js:
module.exports = {
  entry: ['../../index.js', '../../server.js'],
};
</pre>
<ul>
<li><strong>输出</strong>:这是捆的位置。默认情况下，输出属性创建一个<code>dist</code>文件夹</li>
</ul>
<pre class="language-javascript hljs">const path = require('path');module.exports = {
output: {
path: path.resolve(__dirname, 'dist'), },
};</pre>
<ul>
<li>加载器:想知道webpack是如何解析HTML、CSS和媒体文件等资源的吗？它使用加载器，加载器将这些文件转换成可消耗的模块，并将它们添加到依赖图中</li>
</ul>
<pre class="language-javascript hljs">module.exports = {
module: {
rules: [
{
test: /.(js|jsx)$/,
exclude: "/node-modules/",
use: "babel-loader"
     },
     {
        test: /\.html$/,
        use: "html-loader"
     },
     {
        test: /\.(scss|sass)$/,
        use: ["style-loader", "css-loader", "sass-loader"]
     },
                    {
    test: /\.(png|jpe?g|gif)$/i,
    use: [
      {
        loader: 'file-loader',
      },
    ],
  },
  ]
</pre>
<p>}</p>
<p>}</p>
<ul>
<li><strong>插件:【webpack受到大家喜爱的一大原因就是它的插件系统。webpack插件允许您通过插件执行诸如包优化、资产管理和环境变量注入等任务</strong></li>
</ul>
<pre class="language-javascript hljs">const BrotliPlugin = require('brotli-webpack-plugin');
module.exports = {
plugins: [
new BrotliPlugin({
asset: '[path].br[query]',
test: /.(js|css|html|svg)$/,
})
]
}
</pre>
<ul>
<li><strong>模式:</strong>通过设置模式，您可以选择webpack优化的环境</li>
</ul>
<pre class="language-javascript hljs">module.exports = {
  mode: 'development',
};</pre>
<p>这些都是webpack的核心概念。如果您使用过Vue、React、Angular等JavaScript框架，您会注意到这些核心webpack概念已经实现。这是因为这些框架使用webpack进行捆绑。</p>
<p>webpack对前端工具和架构的影响是巨大的。它广泛用于单页面应用程序(spa)、使用服务器端呈现(SSR)的应用程序和静态站点生成器(SSG)。简而言之，其他语言框架，如PHP (Laravel)和Ruby (Rails)，使用webpack来管理JavaScript、CSS和静态资产，如图像或字体。</p>
<p>而且，随着浏览器中的原生ES模块的出现，以及用编译到原生语言编写的JavaScript工具的兴起，bundler的选择需要更多的关注。</p>
<h3 id="known-issues-webpack">webpack的已知问题</h3>
<ul>
<li>缓慢的开发服务器:webpack插件系统是其最大的优点和缺点之一:它严重依赖插件来执行某些任务，这会降低bundler的速度，并增加启动开发服务器的时间</li>
<li>更改时重建:每次对文件进行更改时，都会重建整个应用程序。想象一下在更大的项目中会发生什么</li>
<li>复杂性:随着项目的增长和更多插件的引入，配置变得更加复杂</li>
<li>它会生成无法阅读的代码。这总是一个问题，尤其是在大型项目中重构代码时</li>
</ul>
<p>这些问题导致不断进步的JS社区开发出更好的webpack替代品。迄今为止最成功的替代品之一是Vite。我们来简单探讨一下Vite。</p>
<h2 id="comparing-vite-webpack">比较Vite和webpack</h2>
<p>Vite是一个构建工具，在web项目中提供更快的开发体验。与捆绑器不同，Vite由两部分组成:</p>
<ol>
<li>汇总，用于代码绑定</li>
<li>具有广泛功能的开发服务器，包括快速热模块更换(HMR)</li>
</ol>
<p>Vite中的HMR API比webpack快得多。Vite解决了我们在webpack中遇到的开发服务器速度慢的问题，即使项目在扩展。它还开创了一个基于ESM的开发工具和无捆绑架构的新时代。我们不会<a href="https://blog.logrocket.com/vite-3-vs-create-react-app-comparison-migration-guide/#how-do-vite-and-create-react-app-work">深入介绍Vite </a>，因为这已经超出了本文的范围，但是介绍它的目的是为了让您注意到以下几点:</p>
<ul>
<li>Vite是一个构建工具，而不是捆绑器。速度更快，结果是大多数团队都从webpack迁移到Vite</li>
<li>Vite不是webpack的直接替代品——它只是在大多数情况下比webpack更好</li>
</ul>
<p>这些观点提出了一个问题，“如果Vite不是Webpack的继任者，那么什么是？”几周前，Vercel发布了Turbopack，回答了这个问题。在下一节中，我们将了解什么是Turbopack，它的优缺点，如何在Next.js项目中使用它，以及它比webpack更好的地方。我们还将简要讨论基于webpack的项目的未来。</p>
<h2 id="what-is-turbopack">什么是Turbopack？</h2>
<p>Turbopack是一个增量捆绑器，为您的JavaScript和TypeScript项目进行了优化。与用JS/TS编写的其他打包程序不同，Turbopack是基于Rust的。它是webpack的正式继任者，由webpack和Next.js的创建者开发。</p>
<p>Turbopack号称比webpack 快<a href="https://vercel.com/blog/turbopack#how-fast-is-turbopack">700倍，在大型项目中比Vite快10倍(虽然Vite的创造者</a><a href="https://twitter.com/youyuxi/status/1585040266964406273?s=20&amp;t=w6axhN13RgMeLJ5VPI7HPQ">不同意这个</a>)。那么是什么让Turbopack如此之快呢？</p>
<h3 id="compilation-by-request">请求编译</h3>
<p>我们已经讨论了启动时间在开发人员体验中的重要性，以及随着项目变大，webpack dev服务器启动缓慢的原因，因为每次文件发生变化时，它都会重新构建整个应用程序。另一方面，Turbopack只编译启动项目所需的代码。</p>
<h3 id="using-turbo-engine">使用涡轮发动机</h3>
<p><a href="https://github.com/vercel/turbo">涡轮引擎</a>是一个强大的Rust库，支持增量计算。在计算机科学中，增量计算是指当一系列输入彼此略有不同时，在计算新输出时使用先前计算的输出，而不是从头开始计算新输出。优化编译器时会应用这种计算。实现增量计算的一种方法是通过缓存。涡轮引擎使用<a href="https://turbo.build/pack/docs/core-concepts#function-level-caching">功能级缓存</a>实现增量计算。让我们来探讨一下Turbopack的特点和缺点。</p>
<p><img data-attachment-id="143705" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/function-level-caching/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching.png" data-orig-size="730,274" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="function-level-caching" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching-300x113.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching.png" decoding="async" class="aligncenter wp-image-143705 size-full jetpack-lazy-image" src="../Images/47b67aa0ca299c4e4172d585b33adb61.png" alt="How function-level caching works. " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching-300x113.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143705" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/function-level-caching/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching.png" data-orig-size="730,274" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="function-level-caching" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching-300x113.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching.png" decoding="async" loading="lazy" class="aligncenter wp-image-143705 size-full" src="../Images/47b67aa0ca299c4e4172d585b33adb61.png" alt="How function-level caching works. " srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching-300x113.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/function-level-caching.png"/></noscript>
<h2 id="features-drawbacks-turbopack">Turbopack的特点和缺点</h2>
<p>让我们来强调一下Turbopack的一些特性:</p>
<ul>
<li>更快的开发服务器时间:Turbopack支持开箱即用的HMR，由于增量计算，它的速度更快。HMR确保您的开发服务器不会在每次文件更改后完全刷新</li>
<li>对JS &amp; TS的现成支持:Turbopack捆绑了JavaScript和TypeScript，但没有Babel。相反，Turbopack使用了一个基于Rust的编译工具，<a href="https://blog.logrocket.com/why-you-should-use-swc/"> SWC </a> <a href="https://blog.logrocket.com/why-you-should-use-swc/">(快速网络编译器)</a>。作为背景，SWC声称比巴别塔快17倍</li>
<li>对CJS和ESM导入的开箱即用支持:无论您使用什么方法导入模块，Turbopack都支持</li>
<li>环境变量的实时重新加载:开发时最恼人的体验之一是在更改环境变量后必须关闭并重新加载服务器。Turbopack带有针对环境变量的实时重装功能</li>
</ul>
<p>让我们强调一下Turbopack早期的一些缺点。值得注意的是，Turbopack仍然是非常新的和实验性的，所以随着它的成熟，这些问题可能会得到解决。</p>
<ul>
<li>缺乏上帝级别的可扩展性:webpack的插件API具有我所说的上帝级别的可扩展性。Turbopack不支持插件，但他们承诺bundler在未来的版本中将是可扩展的。然而，他们不会移植webpack插件API，这意味着你今天喜欢的大多数webpack插件不会与Turbopack一起工作。</li>
<li>不执行类型检查:Turbopack使用SWC来编译TypeScript，并且没有现成的类型检查支持。像Vite和esbuild一样，使用Turbopack，您必须运行<code>tsc --watch</code>或者依赖您的代码IDE进行类型检查。</li>
<li>仅支持Next.js开发服务器</li>
</ul>
<h2 id="use-turbopack">如何使用Turbopack</h2>
<p>Turbopack仍处于其alpha版本，并且只被部署为Next.js 13开发服务器。要运行由Turbopack支持的Next.js 13项目，请在您的终端上运行以下命令:</p>
<p>&lt;</p>
<p>pre class = " language-bash hljs &gt; npx create-next-app–使用-turbopack的示例</p>
<p>这个命令将引导一个带有React服务器组件的Next.js 13示例。运行<code>yarn install</code>来安装依赖项。</p>
<p>现在是关键时刻了。让我们用<code>yarn dev</code>运行项目:</p>
<p><img data-attachment-id="143711" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/running-project-yarn-dev/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev.png" data-orig-size="730,142" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="running-project-yarn-dev" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev-300x58.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev.png" decoding="async" class="aligncenter wp-image-143711 size-full jetpack-lazy-image" src="../Images/672056c8ee47681f7912694d3eed5790.png" alt="Running the project with yarn.dev." data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev-300x58.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143711" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/running-project-yarn-dev/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev.png" data-orig-size="730,142" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="running-project-yarn-dev" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev-300x58.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev.png" decoding="async" loading="lazy" class="aligncenter wp-image-143711 size-full" src="../Images/672056c8ee47681f7912694d3eed5790.png" alt="Running the project with yarn.dev." srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev-300x58.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/running-project-yarn-dev.png"/></noscript>
<p>20+组件的编译时间为6.264毫秒！</p>
<p>作为背景，让我们将这个启动时间与一个非Turbopack Next.js 13项目进行比较，该项目具有更少的组件和依赖项。</p>
<p><img data-attachment-id="143713" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/turbopack-next-js-project/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project.png" data-orig-size="730,61" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="turbopack-next-js-project" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project-300x25.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project.png" decoding="async" class="aligncenter wp-image-143713 size-full jetpack-lazy-image" src="../Images/f9dea1acdf6849d00ddc7947b422d6a3.png" alt="Turbopack Next.js project " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project-300x25.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="143713" data-permalink="https://blog.logrocket.com/introducing-turbopack-rust-based-successor-webpack/attachment/turbopack-next-js-project/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project.png" data-orig-size="730,61" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="turbopack-next-js-project" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project-300x25.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project.png" decoding="async" loading="lazy" class="aligncenter wp-image-143713 size-full" src="../Images/f9dea1acdf6849d00ddc7947b422d6a3.png" alt="Turbopack Next.js project " srcset="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project-300x25.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/turbopack-next-js-project.png"/></noscript>
<p>我们在11s内编译了客户机和服务器，几乎是Turbopack编译时间的两倍！</p>
<p>区别很明显。我们只能期待Turbopack什么时候能成为其他框架的底层引擎。</p>
<h2 id="migrating-webpack">从webpack迁移</h2>
<p>正如我们已经讨论过的，Turbopack仍然处于实验模式，还没有为生产环境做好准备。所以在撰写本文时，您还不能将您的项目移植到Turbopack。</p>
<h2 id="means-webpack-users">这对webpack用户意味着什么</h2>
<p>首先，对于webpack爱好者来说，Turbopack是未来的预演。webpack每周大约有2600万次下载，这种情况会持续尽可能长的时间，直到项目维护人员停止下载。</p>
<p>如果您访问不再维护的<a href="https://blog.logrocket.com/vite-vs-snowpack-a-comparison-of-frontend-build-tools/"> Snowpack </a>，将建议您使用Vite。我想未来webpack和Turbopack也会发生同样的事情。</p>
<p>然而，Turbopack是由Vercel管理的，我们不知道bundler何时可以广泛用于生产级应用。如果你正在寻找webpack的替代品，我建议暂时使用Vite。</p>
<h2>结论</h2>
<p>Turbopack是一个很有前途的项目，在Vite和esbuild等构建工具正在取代捆绑器的时代，它无疑将重新定义捆绑工具架构。在本文中，我们了解了捆扎机是什么以及它们是如何工作的。然后我们引入了webpack作为bundler卓越工具；我们继续学习它的核心概念，并简要探索了Vite作为webpack的替代方案。</p>
<p>我们还介绍了Vite作为一个构建工具，而不是webpack的继承者。这向我们介绍了Turbopack。我们了解了什么是Turbopack，它是如何工作的，它的主要特性和问题，如何在项目中使用它，以及它如何影响现有的webpack用户。</p><div class="code-block code-block-28">
<div class="blog-plug inline-plug js-libraries-plug"><h2>您是否添加了新的JS库来提高性能或构建新特性？如果他们反其道而行之呢？</h2><p>毫无疑问，前端变得越来越复杂。当您向应用程序添加新的JavaScript库和其他依赖项时，您将需要更多的可见性，以确保您的用户不会遇到未知的问题。</p>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放JavaScript错误，就像它们发生在您自己的浏览器中一样，这样您就可以更有效地对错误做出反应。</p><a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/e8a0ab42befa3b3b1ae08c1439527dc6.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/errors-screenshot.png"/></noscript></a>
<a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p><a href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自Redux、Vuex和@ngrx/store的额外上下文。您可以汇总并报告问题发生时应用程序的状态，而不是猜测问题发生的原因。LogRocket还可以监控应用的性能，报告客户端CPU负载、客户端内存使用等指标。</p><p>自信地构建— <a class="signup" href="https://lp.logrocket.com/blg/javascript-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>


</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
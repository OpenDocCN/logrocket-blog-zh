<html>
<head>
<title>Modeling NestJS app data with Dynamoose - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>用Dynamoose - LogRocket博客对NestJS应用数据建模</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/nestjs-data-dynamoose/#0001-01-01">https://blog.logrocket.com/nestjs-data-dynamoose/#0001-01-01</a></blockquote><div><article class="article-post">
<p>DynamoDB是一个<a href="https://www.mongodb.com/nosql-explained" target="_blank" rel="noopener"> NoSQL数据库</a>，这意味着它没有预定义的结构。使用DynamoDB，您可以存储任何想要的数据，而不用担心数据模型，这使它成为处理非结构化数据时使用的强大工具。</p>
<p>但是NoSQL是有代价的。不定义结构意味着您必须一致地维护结构和数据类型，否则您的应用程序有崩溃的风险。</p>
<p>开发人员已经想出了防止这些问题的方法。在本文中，我们将探讨为什么应该使用ORM或对象关系映射和DynamoDB来管理数据库模型。我们还将看到为什么Dynamoose是最好的ORM工具。最后，我们将把Dynamoose与NestJS应用程序集成在一起，构建一个完整的CRUD应用程序，您可以将其作为参考。</p>
<p>在这篇文章中:</p>

<p>我们开始吧！</p>
<h2 id="pain-points-dynamodb">DynamoDB的难点</h2>
<p>从JavaScript应用程序与DynamoDB交互的最常见方式是使用<code><a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-dynamodb/index.html" target="_blank" rel="noopener">aws-sdk</a></code>的DynamoDB客户端。但是这带来了几个问题。</p>
<h3 id="dynamodb-manage-data-models">1.DynamoDB没有管理数据模型的方法</h3>
<p>客户端没有提供管理应用模型的方法。如果您的应用程序需要一致性，这就变得很麻烦。</p>
<h3 id="dynamodb-data-validation">2.DynamoDB没有数据验证</h3>
<p>这可能是一个有争议的话题，因为使用DynamoDB的一个重要好处是能够在数据库中存储任何东西。</p>
<p>但是，实际上，我们并不经常要求这样。例如，我们不把电子邮件放入年龄字段，对吗？那我们该怎么办？</p>
<pre class="language-typescript hljs">if(name.length &gt; 0 &amp;&amp; isEmail(email)){
  // store the value
}
</pre>
<p>我们必须自己进行验证，并且对每个领域进行验证，这变得很难维护。</p>
<h3 id="syntax-dynamodb">3.DynamoDB的奇怪语法</h3>
<p>访问DynamoDB的语法很奇怪，经常依赖于字符串查询，很不方便。下面是来自官方文档的一个例子，它查询一个包含视频系列中某一集信息的表格。</p>
<pre class="language-typescript hljs">var params = {
  ExpressionAttributeValues: {
    ':s': {N: '2'},
    ':e' : {N: '09'},
    ':topic' : {S: 'PHRASE'}
  },
  KeyConditionExpression: 'Season = :s and Episode &gt; :e',
  ProjectionExpression: 'Episode, Title, Subtitle',
  FilterExpression: 'contains (Subtitle, :topic)',
  TableName: 'EPISODES_TABLE'
};

ddb.query(params, function(err, data) {
   // handle the error and the other things here
});
</pre>
<p>这可能需要很长时间才能理解。而当有多个领域可以推理的时候，就变成了噩梦！</p>
<h3 id="maintaining-dynamodb">4.DynamoDB很难维护</h3>
<p>DynamoDB的这些问题让开发人员(包括我自己)很难对查询进行推理。而且因为语法不熟悉，所以需要陡峭的学习曲线，这对于快节奏的项目是不可取的。</p>
<h2 id="solution-dynamodb-issues">DynamoDB问题的解决方案</h2>
<p>我们可以用ORM或对象关系映射来解决前面提到的问题。ORM工具使管理数据库模型变得容易，并且通过使用更简单的语法使访问数据库变得更容易。</p>
<p>使用ORM有很多好处:</p>
<ul>
<li>语法很简单</li>
<li>当您可以利用您最喜欢的类型脚本时，管理模型变得更加容易</li>
<li>这样更安全</li>
<li>数据验证很容易完成</li>
<li>它可以与DynamoDB表通信，并提供类型脚本支持</li>
</ul>
<h2 id="choosing-dynamoose-orm">为什么你应该选择Dynamoose作为你的ORM工具</h2>
<p>DynamoDB有很多ORM工具可供选择，包括<a href="https://github.com/kayomarz/dynamodb-data-types" target="_blank" rel="noopener"> dynamodb-data-types </a>、<a href="https://github.com/aaaristo/dyngodb" target="_blank" rel="noopener"> dyngod </a>、<a href="https://github.com/aaaristo/dyngodb"> b </a>和<a href="https://github.com/tglines/dynasaur" target="_blank" rel="noopener">dynasour</a>。</p>
<p>但是它们都没有<a href="https://dynamoosejs.com/getting_started/Introduction" target="_blank" rel="noopener">电动汽车</a>受欢迎:</p>
<ul>
<li>易于使用</li>
<li>类似于Mongoose，它是MongoDB的ORM工具，使得开发人员对语法非常熟悉</li>
<li>提供良好的类型支持</li>
<li>具有强大的过滤功能</li>
<li>支持DynamoDB事务</li>
<li>提供回拨和承诺支持</li>
</ul>
<p>今天，我们将了解如何在NestJS应用程序中使用Dynamoose。</p>
<h2 id="nest-js-dynamoose">使用Dynamoose创建NestJS应用程序</h2>
<p>创建我们的NestJS项目的第一步是安装NestJS CLI。</p>
<pre class="language-typescript hljs">npm i -g @nestjs/cli
</pre>
<p>接下来，初始化样板项目。</p>
<pre class="language-typescript hljs">nest new nestjs-dynamoose-integration
</pre>
<p>然后，安装所需的依赖项。</p>
<pre class="language-typescript hljs">yarn add dynamoose
</pre>
<p>我们准备开始了！</p>
<h2 id="configuring-dynamoose">1.配置电动主机</h2>
<p>为了让Dynamoose与AWS帐户上的DynamoDB表对话，它需要适当的权限。你可以在这里找到配置<a href="https://dynamoosejs.com/getting_started/Configure/" target="_blank" rel="noopener">的不同方法。</a></p>
<p>出于我们的目的，我们将在应用程序中使用<code>access_key</code>和<code>secret_key</code>来设置凭证。</p>
<p>打开<code>main.ts</code>文件，添加以下配置代码:</p>
<pre class="language-typescript hljs">import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

import * as dynamoose from 'dynamoose';

async function bootstrap() {
  // do this before the app is created.
  dynamoose.aws.sdk.config.update({
    accessKeyId: 'YOUR_ACCESS_KEY',
    secretAccessKey: 'YOUR_SECRET_ACCESS_KEY',
    region: 'YOUR_PREFERRED_REGION',
  });

  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();
</pre>
<p>如果您不确定如何获得这些密钥，您可以<a href="https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/getting-your-credentials.html" target="_blank" rel="noopener">参考文档</a>。理想情况下，您应该使用环境变量来加载它们，而不要在项目中以纯文本的形式使用它们。</p>
<h2 id="user-endpoints">2.创建用户端点</h2>
<p>NestJS的好处在于它会自动为您创建许多样板文件。今天我们将使用Dynamoose构建一个CRUD端点。让我们为它创建样板代码。</p>
<p>在命令行上运行以下命令。</p>
<pre class="language-typescript hljs">nest g resource user
</pre>
<p>运行该命令后，您将看到所有必需的代码都是自动生成的。</p>
<p><img data-attachment-id="128800" data-permalink="https://blog.logrocket.com/nestjs-data-dynamoose/attachment/autogenerated-code-nest-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js.png" data-orig-size="718,634" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Autogenerated code for NestJS app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js-300x265.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js.png" decoding="async" class="aligncenter size-full wp-image-128800 jetpack-lazy-image" src="../Images/3fff730b80bb4e95627c8e72c517e6c6.png" alt="Autogenerated Code For NestJS App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js.png 718w, https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js-300x265.png 300w" data-lazy-sizes="(max-width: 718px) 100vw, 718px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="128800" data-permalink="https://blog.logrocket.com/nestjs-data-dynamoose/attachment/autogenerated-code-nest-js/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js.png" data-orig-size="718,634" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Autogenerated code for NestJS app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js-300x265.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-128800" src="../Images/3fff730b80bb4e95627c8e72c517e6c6.png" alt="Autogenerated Code For NestJS App" srcset="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js.png 718w, https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js-300x265.png 300w" sizes="(max-width: 718px) 100vw, 718px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/09/autogenerated-code-nest-js.png"/></noscript>
<p>多酷啊。</p>
<h2 id="defining-data-structure">3.定义数据结构</h2>
<p>下一步是创建一个扩展Dynamoose提供的<code>Document</code>类的<code>entity</code>类，它将定义我们实体的结构。</p>
<p>打开<code>user.entity.ts</code>文件并粘贴以下代码。</p>
<pre class="language-typescript hljs">import { Document } from 'dynamoose/dist/Document';

export class User extends Document {
  Id = 0;
  Name = '';
}
</pre>
<p>这种结构有两个目的:</p>
<ul>
<li>它帮助其他开发人员快速了解数据结构</li>
<li>它使用TypeScript的功能自动建议字段</li>
</ul>
<p>这一步是可选的，但是我强烈推荐它！</p>
<h2 id="schema-define-dynamoose-database-models">4.创建模式来定义Dynamoose数据库模型</h2>
<p>遵循Mongoose库的足迹，Dynamoose还使用模式的概念定义了数据库模型。模式是我们的DynamoDB表理解的数据模型的定义。</p>
<p>如前所述，DynamoDB不限制我们可以上传到数据库表的数据。但是我们可以使用模式定义所需的数据形状，Dynamoose将确保我们的数据符合该结构。</p>
<p>其他一些好处包括:</p>
<ul>
<li>我们可以将一个字段标记为<code>required</code>，这将确保该字段永远不会为空</li>
<li>我们可以定义一个属性的<code>type</code></li>
<li>我们可以定义嵌套对象的结构</li>
<li>我们可以提供一个<code>custom validation</code>函数来验证字段的值</li>
<li>我们可以自动生成<code>timestamps</code></li>
</ul>
<p>让我们在实体目录中创建新的<code>user.schema.ts</code>文件，并将下面的代码粘贴到那里。</p>
<pre class="language-typescript hljs">import * as dynamoose from 'dynamoose';

export const UserSchema = new dynamoose.Schema(
  {
    Id: {
      type: Number,
      hashKey: true,
      required: true,
    },
    Name: {
      type: String,
      required: true,
      index: {
          name: nameIndex,
          global: true
      }
    },
  },
  {
    timestamps: true,
  },
);
</pre>
<p>让我们了解一下这是怎么回事:</p>
<ul>
<li><code>Id</code>字段被指定为一个<code>Number</code>，所以我们不能在这里传递任何键</li>
<li><code>Name</code>字段是<code>required</code>，所以如果它是空的，就会出错</li>
<li><code>Name</code>的类型是<code>String</code>，所以没有其他数据类型可以放在那里</li>
<li>我们添加了<code>timestamps</code>属性，它将自动为我们生成和维护<code>createdAt</code>和<code>updatedAt</code>字段</li>
<li>我们在<code>Name</code>字段上创建了一个全局索引</li>
</ul>
<p>这些事情的发生并不需要我们编写不必要的验证函数。</p>
<h2 id="crud-operations">5.创建CRUD操作</h2>
<p>让我们打开<code>user.service.ts</code>文件，在这里我们将创建所有需要的CRUD操作。</p>
<p>首先，确保我们有一个本地<code>dbInstance</code>并用用户信息初始化它。</p>
<p>请记住，理想情况下，我们希望创建一个单独的<code>user.repository.ts</code>文件来保存我们的数据库逻辑。我们通常将服务类用于业务逻辑。</p>
<p>为了简单起见，我们现在将DB操作放在服务类中。</p>
<pre class="language-typescript hljs">@Injectable()
export class UserService {
  private dbInstance: Model&lt;User&gt;;

  constructor() {
    const tableName = 'users';
    this.dbInstance = dynamoose.model&lt;User&gt;(tableName, UserSchema);
  }

  //... crud functions
}
</pre>
<p>这里，我们用<code>User</code>模型添加一个私有的<code>dbInstance</code>。在构造函数内部，我们指定想要使用哪个表，并在这里提供<code>UserSchema</code>。</p>
<p>现在，我们的<code>dbInstance</code>知道要访问哪个DynamoDB表，以及预期的数据类型。</p>
<h3 id="creating-user">创建用户</h3>
<p>为了创建一个<code>user</code>，我们可以编写下面的函数。</p>
<pre class="language-typescript hljs">async create (createUserDto: CreateUserDto) {
    return await this.dbInstance.create({
      Id: createUserDto.Id,
      Name: createUserDto.Name,
    });
}
</pre>
<p>注意，我们使用的是<code>CreateUserDto</code>请求对象，NestJS已经为我们定义了这个对象。</p>
<p>它看起来会像这样:</p>
<pre class="language-typescript hljs">export class CreateUserDto {
  Id: number;
  Name: string;
}
</pre>
<h3 id="getting-user">获取用户</h3>
<p>要获得单个用户，我们可以使用主键查询数据库，如下所示:</p>
<pre class="language-typescript hljs">async findOne(id: number) {
    return await this.dbInstance.get({ Id: id });
}
</pre>
<p>您还可以使用许多东西进行查询，比如部分匹配、小于或大于运算符。你可以在文档中找到更多的细节。</p>
<h3 id="updating-user">更新用户</h3>
<p>为了更新<code>user</code>，我们得到了一个由Dynamoose提供的<code>update</code>函数。</p>
<pre class="language-typescript hljs">async update(id: number, updateUserDto: UpdateUserDto) {
    return await this.dbInstance.update({
      Id: id,
      Name: updateUserDto.Name,
    });
}
</pre>
<h3 id="deleting-user">删除用户</h3>
<p>要通过ID删除用户，请输入以下代码:</p>
<pre class="language-typescript hljs">async remove(id: number) {
    return await this.dbInstance.delete({ Id: id });
}
</pre>
<p>最终版本应该是这样的:</p>
<pre class="language-typescript hljs">import * as dynamoose from 'dynamoose';
import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { User } from './entities/user.entity';
import { Model } from 'dynamoose/dist/Model';
import { UserSchema } from './entities/user.schema';

@Injectable()
export class UserService {
  private dbInstance: Model&lt;User&gt;;

  constructor() {
    const tableName = 'users';
    this.dbInstance = dynamoose.model&lt;User&gt;(tableName, UserSchema);
  }

  async create(createUserDto: CreateUserDto) {
    return await this.dbInstance.create({
      Id: createUserDto.Id,
      Name: createUserDto.Name,
    });
  }

  async findOne(id: number) {
    return await this.dbInstance.get({ Id: id });
  }

  async update(id: number, updateUserDto: UpdateUserDto) {
    return await this.dbInstance.update({
      Id: id,
      Name: updateUserDto.Name,
    });
  }

  async remove(id: number) {
    return await this.dbInstance.delete({ Id: id });
  }
}
</pre>
<h2 id="testing-user-endpoints">6.测试用户端点</h2>
<p>让我们转到<a href="https://www.postman.com/" target="_blank" rel="noopener"> Postman </a>并使用下面的主体创建一个用户。</p>
<pre class="language-typescript hljs">endpoint: http://localhost:3000/user
method: POST
body: {
    "Id": 1,
    "Name" : "Faisal"
}
</pre>
<p>如果你试图像这样得到特定的用户…</p>
<pre class="language-typescript hljs">endpoint: http://localhost:3000/user/1
method: GET
</pre>
<p>…它会给你以下的回应:</p>
<pre class="language-typescript hljs">{
    "Id": 1,
    "Name": "Faisal",
    "createdAt": 1660504687981,
    "updatedAt": 1660504687981
}
</pre>
<p>你可以看到有两个额外的字段:<code>createdAt</code>和<code>updatedAt</code>，它们是自动生成的。</p>
<p>同样，你也可以使用<code>update</code>和<code>delete</code>方法。</p>
<p>现在，您已经有了一个完全正常工作的CRUD应用程序，能够使用Dynamoose与实际的DynamoDB对话。</p>

<p>在本文中，您学习了如何在NestJS应用程序中使用Dynamoose。点击查看该项目的GitHub库<a href="https://github.com/Mohammad-Faisal/nestjs-dynamoose-integration" target="_blank" rel="noopener">。另一个名为</a><a href="https://www.npmjs.com/package/nestjs-dynamoose" target="_blank" rel="noopener"> nestjs-dynamoose </a>的包在用法上添加了一些语法糖。</p>
<p>我希望你今天学到了新东西。祝您愉快！</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
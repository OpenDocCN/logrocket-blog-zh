<html>
<head>
<title>Implementing copy-to-clipboard in React with Clipboard API - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 React 中实现复制到剪贴板</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/implementing-copy-clipboard-react-clipboard-api/#0001-01-01">https://blog.logrocket.com/implementing-copy-clipboard-react-clipboard-api/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果你正在阅读这篇博客，很有可能你已经从 GitHub 克隆了一个 git 库。GitHub 添加到其网站上的一个小而强大的功能允许用户点击一个按钮将 Git URL 复制到您的剪贴板上，这样您就可以轻松地将其粘贴到您的终端上，以将存储库克隆到您的本地机器上。</p>
<p>这比选择整行文本，然后点击<code>Control+C</code>或<code>Command+C</code>来复制它要容易得多。它还可以防止您在选择 URL 时遗漏任何字符。</p>
<p>现在，假设你正在为自己建立一个新的博客网站，你想让读者尽可能容易地与他人分享文章。一些社交媒体网站提供使用链接的方法，并自动在其网站上开始新的帖子，但不是每个应用程序都支持这种功能。</p>
<p>如果你想复制一个网址并通过 Zoom 或 iMessage 发送给某人，该怎么办？如果我们给用户一个复制文本的按钮，将会极大地改善用户体验。它对移动用户也特别有帮助。</p>
<p>在本文中，我将向您展示如何通过创建一个可重用的 React 组件来实现这一点，该组件将接受文本作为一个属性值，并在单击时将文本复制到用户的剪贴板。</p>
<h2>什么是 JavaScript 剪贴板 API？</h2>
<p>令人欣慰的是，在现代 web 开发时代，我们获得了许多有用的 web APIs，使得在浏览器中复制和粘贴文本等任务变得容易。当前用于剪贴板交互的事实上的 API 是<a href="https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API" target="_blank" rel="noopener">剪贴板 API </a>，它提供了一些简单的函数，您可以使用这些函数将文本复制到用户的剪贴板并从中读取项目。</p>
<p>不幸的是，在撰写本文时，并不是所有的 web 浏览器都支持这个 API。虽然有些浏览器完全或部分支持它，但 Internet Explorer 根本不支持它。</p>
<figure id="attachment_97240" aria-describedby="caption-attachment-97240" class="wp-caption aligncenter"><img data-attachment-id="97240" data-permalink="https://blog.logrocket.com/implementing-copy-clipboard-react-clipboard-api/image3-22/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image3.png" data-orig-size="730,486" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="implement-copy-clipboard-browser-support" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image3-300x200.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image3.png" decoding="async" class="wp-image-97240 size-full jetpack-lazy-image" src="../Images/5601771a377487042af9c36a0f7dee74.png" alt="browser support for clipboard API" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/image3.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/07/image3-300x200.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/image3.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/image3.png"/><noscript><img data-lazy-fallback="1" data-attachment-id="97240" data-permalink="https://blog.logrocket.com/implementing-copy-clipboard-react-clipboard-api/image3-22/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image3.png" data-orig-size="730,486" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="implement-copy-clipboard-browser-support" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image3-300x200.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image3.png" decoding="async" loading="lazy" class="wp-image-97240 size-full" src="../Images/5601771a377487042af9c36a0f7dee74.png" alt="browser support for clipboard API" srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/image3.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/07/image3-300x200.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/image3.png"/></noscript><figcaption id="caption-attachment-97240" class="wp-caption-text">Source: MDN</figcaption></figure>
<p>然而，如果你仍然必须支持 IE，有一个遗留功能可以作为备份，使用<code>document.execCommand('copy')</code>。</p>
<p>下面是一个接受文本作为参数并将其复制到用户剪贴板的函数示例:</p>
<pre>export async function copyTextToClipboard(text) {
  if ('clipboard' in navigator) {
    return await navigator.clipboard.writeText(text);
  } else {
    return document.execCommand('copy', true, text);
  }
}
</pre>
<p>现在，让我们走一遍。</p>
<p>首先，我们有一个名为<code>copyTextToClipboard</code>的异步函数，它只有一个参数文本。它检查属性剪贴板是否存在于<code>navigator</code>对象上。这是检查当前浏览器是否支持剪贴板 API 的简单方法。</p>
<p>接下来，如果浏览器支持剪贴板 API，我们等待承诺<code>navigator.clipboard.writeText(text)</code>被解析并返回。</p>
<p>否则，我们用参数<code>'copy', true, text</code>调用<code>Document.execCommand</code>函数。你可以在<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand" target="_blank" rel="noopener">的 MDN 文档</a>中读到这个命令的参数。</p>
<p>当您在浏览器中运行此命令时，它会将作为参数传入的任何文本复制到用户的剪贴板，这样当用户粘贴文本时，它就会出现。</p>
<p>现在我们有了一个简单的工作函数，我们将把它实现到一个灵活的 React 组件中。</p>
<h2>在 React 中使用剪贴板 API</h2>
<p>让我们首先设置一个简单的 React 组件，直观地表示我们想要实现的目标:</p>
<pre>function ClipboardCopy({ copyText }) {
  const [isCopied, setIsCopied] = useState(false);

  // TODO: Implement copy to clipboard functionality

  return (
    &lt;div&gt;
      &lt;input type="text" value={copyText} readOnly /&gt;
      &lt;button&gt;
        &lt;span&gt;{isCopied ? 'Copied!' : 'Copy'}&lt;/span&gt;
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>这里，我已经设置了组件<code>ClipboardCopy</code>，它接受属性<code>copyText</code>。这将是我们希望用户复制的文本。它将呈现一个只读的<code>&lt;input&gt;</code>元素，显示我们的<code>copyText</code>字符串和一个按钮，我们将使用它来执行我们的复制功能。</p>
<p>我还添加了状态值<code>isCopied</code>来跟踪文本是否已经被复制到剪贴板，并改变显示在按钮<code>copy</code>上的文本。</p>
<p>现在，我们需要为我们的按钮创建一个<code>onClick</code>处理函数，它将异步调用我们的<code>copyToClipboard</code>函数并将<code>copyText,</code>作为参数传递。</p>
<p>基于函数的结果，我们将把<code>isCopied</code>的状态改为<code>true</code>，或者，如果出现错误，我们将把它打印到控制台。如果命令成功，下一次用户在他们的设备上粘贴文本时，<code>copyText</code>的值将是结果。</p>
<pre>function ClipboardCopy({ copyText }) {
  const [isCopied, setIsCopied] = useState(false);

  // This is the function we wrote earlier
  async function copyTextToClipboard(text) {
    if ('clipboard' in navigator) {
      return await navigator.clipboard.writeText(text);
    } else {
      return document.execCommand('copy', true, text);
    }
  }

  // onClick handler function for the copy button
  const handleCopyClick = () =&gt; {
    // Asynchronously call copyTextToClipboard
    copyTextToClipboard(copyText)
      .then(() =&gt; {
        // If successful, update the isCopied state value
        setIsCopied(true);
        setTimeout(() =&gt; {
          setIsCopied(false);
        }, 1500);
      })
      .catch((err) =&gt; {
        console.log(err);
      });
  }

  return (
    &lt;div&gt;
      &lt;input type="text" value={copyText} readOnly /&gt;
      {/* Bind our handler function to the onClick button property */}
      &lt;button onClick={handleCopyClick}&gt;
        &lt;span&gt;{isCopied ? 'Copied!' : 'Copy'}&lt;/span&gt;
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>我添加了一个新函数<code>handleCopyClick</code>，它充当按钮元素的<code>onClick</code>事件处理程序。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>当用户点击按钮时，事件处理函数被执行，我们的异步函数<code>copyTextToClipboard</code>被执行。</p>
<p>一旦该函数被解析，它或者将<code>isCopied</code>状态值设置为<code>true</code>，或者如果出现错误，则打印该错误。</p>
<p>我还添加了一个<code>setTimeout</code>函数，在 1.5 秒后将复制的状态值重置回<code>false</code>。这允许我们给用户一些交互反馈，因为将文本复制到剪贴板是一个“后台任务”，不提供任何固有的反馈。</p>
<p>现在，我们可以在 React 应用程序中的任何地方使用该组件，如下所示:</p>
<pre>function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ClipboardCopy copyText="https://google.com" /&gt;
      &lt;ClipboardCopy copyText="https://logrocket.com" /&gt;
    &lt;/div&gt;
  );
}
</pre>
<p>最后，当您运行应用程序时，您的用户应该会看到以下内容:</p>
<p><img data-attachment-id="58617" data-permalink="https://blog.logrocket.com/implementing-copy-clipboard-react-clipboard-api/clipboard-copy-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/clipboard-copy-react.gif" data-orig-size="730,418" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Clipboard copy react" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/clipboard-copy-react-300x172.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/clipboard-copy-react.gif" decoding="async" class="aligncenter size-full wp-image-58617 jetpack-lazy-image" src="../Images/42491dad136889b872c26a273928a141.png" alt="Copy Button Next To Link Being Pressed" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/clipboard-copy-react.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/clipboard-copy-react.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="58617" data-permalink="https://blog.logrocket.com/implementing-copy-clipboard-react-clipboard-api/clipboard-copy-react/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/clipboard-copy-react.gif" data-orig-size="730,418" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Clipboard copy react" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/clipboard-copy-react-300x172.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/clipboard-copy-react.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-58617" src="../Images/42491dad136889b872c26a273928a141.png" alt="Copy Button Next To Link Being Pressed" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/clipboard-copy-react.gif"/></noscript>
<p>您可以通过在调用<code>copyTextToClipboard</code>出错的情况下提供更好的反馈来改进这个解决方案。如果您的项目中有一个错误组件，您可以调用一个函数或更改状态来向用户显示错误，而不是将文本打印到用户很可能永远看不到的控制台。</p>
<p>不想手动编写实现复制和读取剪贴板功能的组件？嗯，你可以使用开源的替代方案。让我们来看看其中的一些。</p>
<h2>React 中将文本复制到剪贴板的替代方法</h2>
<h3>反应-复制到剪贴板</h3>
<p><a href="https://www.npmjs.com/package/react-copy-to-clipboard" target="_blank" rel="noopener"> React-copy-to-clipboard </a>是一个 React 组件，允许你将文本复制到剪贴板。它基于 JavaScript <a href="https://www.npmjs.com/package/copy-to-clipboard" target="_blank" rel="noopener">复制到剪贴板 npm 包</a>，与我们之前的例子不同，它使用实验性的<a href="https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent/clipboardData" target="_blank" rel="noopener">剪贴板数据</a> API，大多数浏览器都支持。</p>
<p><img data-attachment-id="97268" data-permalink="https://blog.logrocket.com/implementing-copy-clipboard-react-clipboard-api/image2-20/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1.png" data-orig-size="730,357" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="copy-clipboard-react-third-party-tool" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1.png" decoding="async" class="aligncenter size-full wp-image-97268 jetpack-lazy-image" src="../Images/3ede38865a3200a42efb14028b87b0ff.png" alt="copy clipboard react third-party library browser compatibility" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1-300x147.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="97268" data-permalink="https://blog.logrocket.com/implementing-copy-clipboard-react-clipboard-api/image2-20/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1.png" data-orig-size="730,357" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="copy-clipboard-react-third-party-tool" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-97268" src="../Images/3ede38865a3200a42efb14028b87b0ff.png" alt="copy clipboard react third-party library browser compatibility" srcset="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1-300x147.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/07/image2-1.png"/></noscript>
<p>使用起来也很简单。首先，您需要在终端上运行<code>npm install react-copy-to-clipboard</code>来安装组件。现在您可以使用该组件了，如下所示:</p>
<pre>import "./styles.css";
import { CopyToClipboard } from "react-copy-to-clipboard";

export default function App() {
 return (
   &lt;div className="App"&gt;
     &lt;h1&gt;Clipboard Copy&lt;/h1&gt;
     &lt;CopyToClipboard
     text="text"
     onCopy={() =&gt; alert("Copied")}&gt;
       &lt;span&gt;Copy to clipboard with span&lt;/span&gt;
     &lt;/CopyToClipboard&gt;
   &lt;/div&gt;
 );
}</pre>
<p>组件接受一个<code>text</code>和一个<code>onCopy</code>道具。文本道具允许您设置想要复制的文本，而<code>onCopy</code>道具是一个在复制活动成功执行时触发的事件。在我们的示例中，我们使用本机 JavaScript 警报。在实际的应用程序中，使用一些不太麻烦的东西，比如<a href="https://www.polonel.com/snackbar/" target="_blank" rel="noopener"> Snackbar。</a></p>
<h3><code>useCopy</code>反应钩</h3>
<p><a href="https://github.com/animify/useCopy" target="_blank" rel="noopener"> <code>useCopy</code> </a>是一个 React 钩子，可以让你将文本复制到用户的剪贴板上。它使用我们前面讨论过的复制到剪贴板 JavaScript 库，这意味着它不使用剪贴板 API。相反，它使用剪贴板数据 API。</p>
<p>实现很流畅，就像你通常使用 React 钩子一样。在你的终端上运行<code>npm install useCopy</code>来安装插件，导入<code>useCopy</code>钩子并像这样使用它:</p>
<pre>import React from "react";
import useCopy from "use-copy";

export default function App() {
 const [copied, copy, setCopied] = useCopy("https://logrocket.com, this is the text to copy");

 const copyText = () =&gt; {
   copy();

   setTimeout(() =&gt; {
     setCopied(false);
   }, 3000);
 };

 return (
   &lt;div&gt;
     {copied ? "Copied to clipboard" : &lt;a onClick={copyText}&gt;Copy text&lt;/a&gt;}
   &lt;/div&gt;
 );
}
</pre>
<p>默认情况下，复制的状态变量被设置为<code>false</code>，直到<code>copy</code>函数被调用。然后，我们可以在三秒钟后将状态重置回<code>false</code>，以允许用户再次复制。</p>
<p>您可能也会对我们如何实现这个库感兴趣。我已经从项目的 GitHub 库中提取了代码，所以你可以看到它是多么优雅:</p>
<pre>import copyToClipboard from 'copy-to-clipboard';
import { useState, useRef, useEffect, useCallback } from 'react';

export default function useCopy(str: string): [boolean, () =&gt; void, (value: boolean) =&gt; void] {
    const copyableString = useRef(str);
    const [copied, setCopied] = useState(false);

    const copyAction = useCallback(() =&gt; {
        const copiedString = copyToClipboard(copyableString.current);
        setCopied(copiedString);
    }, [copyableString]);

    useEffect(() =&gt; {
        copyableString.current = str;
    }, [str]);

    return [copied, copyAction, setCopied];
}
</pre>
<h2>结论</h2>
<p>现在我们已经介绍了 JavaScript 剪贴板 API，您可以看到在任何用例中实现它是多么容易，如果您愿意，甚至可以考虑第三方库。这改善了应用程序中的用户体验，当然，如果你想为你的内容赢得观众，让用户分享你的内容变得简单也可以增加你的网站曝光率。看完这些，希望你能为自己收获这些好处！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
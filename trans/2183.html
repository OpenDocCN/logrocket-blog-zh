<html>
<head>
<title>A comprehensive guide to Svelte components with slots - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>带插槽的苗条组件综合指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comprehensive-guide-svelte-components-slots/#0001-01-01">https://blog.logrocket.com/comprehensive-guide-svelte-components-slots/#0001-01-01</a></blockquote><div><article class="article-post">
<h2>介绍</h2>
<p>创建可重用组件的一种方法是将子元素或组件传递给父组件。有了像 React 这样的 UI 库，我们可以用 React 的<code>children</code> prop 创建可重用的组件。但是我们如何在 Svelte 中将子数据传递给父组件呢？</p>
<p/>
<p>在未来的细长插槽。我们可以使用细长插槽来创建接受和呈现任何子组件的组件。这样，我们将能够创建可以在我们的应用程序中多次使用的组件。插槽是有用的，因为它们有助于保持我们的代码库干燥。插槽还使得维护、调试和更新组件更加容易。</p>
<p>在本文中，我们将学习如何使用插槽来构建可重用的苗条组件，包括通过查看一些实际的代码示例来使用它们的不同方式。</p>
<h2>使用细长插槽</h2>
<p>让我们看看老虎机在实践中是如何工作的:</p>
<pre class="language-html hljs">&lt;div class="card"&gt;
  &lt;h1&gt;I am a reusable box&lt;/h1&gt;
  &lt;slot&gt;&lt;/slot&gt;
&lt;/div&gt;

&lt;style&gt;
  .card {
    width: 300px;
    border: 1px solid #aaa;
    border-radius: 2px;
    box-shadow: 2px 2px 8px rgba(0,0,0,0.1);
    padding: 1em;
    margin: 0 0 1em 0;
  }
&lt;/style&gt;
</pre>
<p>在上面的代码中，我们创建了一个<code>Card</code>组件。<code>slot</code>组件允许我们将子数据和内容传递给<code>Card</code>组件，从而使其可重用。</p>
<p>我们可以使用<code>App.svelte</code>中的<code>Card</code>组件，并传入我们的内容:</p>
<pre class="language-html hljs">&lt;script&gt;
  import Card from './Card.svelte';
&lt;/script&gt;

&lt;Card&gt;
  &lt;h1&gt;Hello!&lt;/h1&gt;
  &lt;p&gt;This is a box. It can contain anything.&lt;/p&gt;
&lt;/Card&gt;
</pre>
<h2>插槽回退</h2>
<p>我们可以向槽添加后备内容，以便在槽为空时充当占位符。</p>
<p>假设我们创建了一个博客帖子卡片组件。我们可能希望在卡片收到实际数据之前给每篇文章添加一个后备标题。我们可以通过插槽回退来做到这一点。</p>
<p>我们在<code>slot</code>组件的开始和结束标记之间传递的任何数据都将是回退内容:</p>
<pre class="language-html hljs">    &lt;!-- Card.svelte --&gt;
    &lt;div class="card"&gt;
      &lt;slot&gt;
        &lt;h1&gt;Fallback Blog Title&lt;/h1&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
    
    &lt;!-- App.svelte --&gt;
    
    &lt;script&gt;
      import Card from "./Card.svelte";
    &lt;/script&gt;
    &lt;Card /&gt;
</pre>
<p>这样，在我们传入实际数据之前，我们拥有的每张博客卡都将有一个通用的“后备博客标题”标题。如果在开发过程中需要为组件设置虚拟数据，插槽回退也很有用。</p>
<h2>命名插槽</h2>
<p>通过使用<code>slot</code>组件上的 name 属性，我们可以在一个瘦组件中拥有多个插槽。</p>
<p>让我们假设我们想要扩展博客卡组件。大多数博客卡片不只有标题，它们也有日期和一个包含帖子内容细节的部分。</p>
<p>让我们在博客卡的不同部分进行设置:</p>
<pre class="language-html hljs">&lt;section&gt;
  &lt;slot name="title" /&gt;
  &lt;slot name="date"/&gt;
  &lt;slot name="content" /&gt;
&lt;/section&gt;
</pre>
<p>这里，我们使用插槽将<code>Card</code>组件组装到一个博客卡中。为此，我们设置了两个命名槽，<code>title</code>和<code>content</code>。</p>
<p>我们在<code>App.svelte</code>中使用了<code>Card</code>组件。然后，我们遍历<code>items</code>数组，将<code>title</code>、<code>date</code>和<code>content</code>数据传入它们各自的插槽，如下所示:</p>
<pre class="language-html hljs">&lt;script&gt;
  import Card from "./Card.svelte";
  const items = [
    {title: "Title 1", date: '1-06-2000', content: "Some content content here"},
    {title: "Title 2", date: '1-06-2000', content: "Some more content content here"},
  ];
&lt;/script&gt;

{#each items as item}
  &lt;Card&gt;
    &lt;h1 slot="title"&gt;{item.title}&lt;/h1&gt;
    &lt;span slot="date"&gt;{item.date}&lt;/span&gt;
    &lt;p slot="content"&gt;{item.content}&lt;/p&gt;
  &lt;/Card&gt;
{/each}
</pre>
<h2>命名插槽和细长片段</h2>
<p>我们如何将多个组件传递到一个指定的插槽中呢？假设我们想创建一个带有标题和日期的卡片标题槽，我们该怎么做呢？</p>
<p>让我们看看如何处理下面的场景:</p>
<pre class="language-html hljs">&lt;Card&gt;
  &lt;slot="header"&gt;card title&lt;/slot&gt;
  &lt;slot="header"&gt;card date&lt;/slot&gt;
&lt;/Card&gt;
&lt;!-- ❗ Duplicate slot name "header" in &lt;Card&gt; --&gt;
</pre>
<p>上面的代码不起作用，因为不允许插槽名称重复。怎么才能修好？</p>
<p>解决方案在于使用一种特殊的细长元素<code>Svelte:fragment</code>。<code>svelte:fragment</code>允许您将内容放在一个命名的槽中，而不用将其包装在一个容器 DOM 元素中。这将保持文稿的流动布局不变。</p>
<p>让我们用<code>svelte:fragment</code>重构<code>Card</code>组件:</p>
<pre class="language-html hljs">&lt;Card&gt;
  &lt;svelte:fragment slot="header"&gt;
    &lt;h1&gt;Card title&lt;/h1&gt;
    &lt;p&gt;Card date&lt;/p&gt;
  &lt;/svelte:fragment&gt;
&lt;/Card&gt;
</pre>
<p>使用<code>svelte:fragment</code>，我们避免了添加不必要的 HTML 元素，这些元素会影响布局和样式。</p>
<h2>有条件地显示插槽</h2>
<p>有些时候，我们可能不想为插槽设置后备内容，但希望确保插槽只在有内容时才呈现。</p>
<p>我们可以用特殊的<code>$$slots</code>变量来实现。虽然这可能不是一个需要添加的关键特性，但如果组件在不应该呈现的时候呈现，它会影响应用程序的样式和布局。</p>
<p>让我们确保<code>Card</code>组件在呈现之前没有空槽:</p>
<pre class="language-html hljs">&lt;div class="card"&gt;
  {#if $$slots.title}
    &lt;slot name="title" /&gt;
  {/if}

  {#if $$slots.content}
    &lt;slot name="content"&gt;Content&lt;/slot&gt;
  {/if}
&lt;/div&gt;
</pre>
<p>除了有条件地呈现插槽组件，我们还可以使用<code>$$slots</code>变量有条件地将类应用于组件:</p>
<pre class="language-html hljs">&lt;div class="card"&gt;
  &lt;slot name="title" class:title-style={$$slots.title} /&gt;

  {#if $$slots.content}
    &lt;slot name="content"&gt;Content&lt;/slot&gt;
  {/if}
&lt;/div&gt;

&lt;style&gt;
  .title-style{
    color: red;
  }
&lt;/style&gt;
</pre>
<p><code>$$slots</code>变量是一个对象，它的键是父组件传入的插槽名称，我们可以用它来有条件地显示或样式化插槽组件。</p>
<h2>通过 props 跨插槽传递数据</h2>
<p>我们可以使用 slot props 通过 slots 的<code>let:</code>指令将数据从子进程传递到父进程。这有助于我们在父组件和子组件之间建立关注点的分离。</p>
<p>假设我们有一个雇员数组，我们想在我们的 UI 中呈现。我们设置了一个<code>Contacts.svelte</code>组件，其中将呈现雇员的详细信息，并在<code>App.svelte</code>中调用<code>Contacts.svelte</code>。</p>
<p>我们可以将雇员的数据存储在我们的<code>App.svelte</code>文件中，但是，我们希望避免用不需要的数据污染<code>App.svelte</code>,因为这将使将来更难维护。</p>
<p>让我们在代码中进行设置，看看它是如何工作的:</p>
<pre class="language-html hljs">&lt;!--Contacts.svelte --&gt;
&lt;script&gt;
  const names = ["John", "Jane", "Mary"];
&lt;/script&gt;

&lt;div class="contact"&gt;
  &lt;slot {names} /&gt;
&lt;/div&gt;

&lt;!--App.svelte --&gt;
&lt;script&gt;
  import Card from "./Card.svelte";
&lt;/script&gt;

&lt;Contacts let:names&gt;
  {#each names as name}
    &lt;p&gt;{name}&lt;/p&gt;
  {/each}
&lt;/Contacts&gt;
</pre>
<p>这样，我们可以将处理本地状态和数据的责任留给子组件<code>Contacts.svelte</code>，并保持我们的<code>App.svelte</code>更干净。</p>
<p>我们还可以通过指定的插槽传递数据，如下所示:</p>
<pre class="language-html hljs">&lt;!--Card.svelte --&gt;
&lt;script&gt;
  let title = "I am the title";
  let content = "I am the content";
&lt;/script&gt;

&lt;div class="card"&gt;
  &lt;slot name="title" {title} /&gt;
  &lt;slot name="content" {content} /&gt;
&lt;/div&gt;


&lt;!--App.svelte --&gt;
&lt;script&gt;
  import Card from "./Card.svelte";
&lt;/script&gt;

&lt;Card&gt;
  &lt;h1 slot="title" let:title&gt;{title}&lt;/h1&gt;
  &lt;p slot="content" let:content&gt;{content}&lt;/p&gt;
&lt;/Card&gt;
</pre>
<h2>结论</h2>
<p>在这篇文章中，我们已经学习了如何使用插槽来构建苗条的组件。我们学习了什么是槽，如何设置回退内容，以及命名槽。我们还学习了如何通过 props 将动态数据传递给插槽。除了插槽的特性之外，我们还看了一些场景以及如何在实际中使用它们。</p>
<p>既然你已经了解了细长插槽，我鼓励你深入研究文档，实践并构建一些令人敬畏的应用程序。</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
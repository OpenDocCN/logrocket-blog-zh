<html>
<head>
<title>Web workers, React, and TypeScript </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>网络工作者、反应和打字稿</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/web-workers-react-typescript/#0001-01-01">https://blog.logrocket.com/web-workers-react-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Web workers是Web浏览器在后台运行脚本而不干扰UI的一种方式。如果设置正确，web worker可以从设置它的JavaScript或TypeScript代码发送和接收消息。在本文中，我们将<a href="https://blog.logrocket.com/how-to-improve-interface-responsiveness-with-web-workers/">了解web workers </a>以及如何通过构建分页数据表，在带有React和TypeScript的项目中使用它们。</p>
<p>我们将通过长数组确定<code>length</code>、<code>filter</code>、<code>slice</code>和<code>map</code>，而不会影响我们的web应用程序的性能或UX。本质上，我们将学习如何使用web workerss来提升web应用程序的性能，web worker为我们提供了多线程能力来处理后台的长进程。</p>
<p>为了跟进，您可以<a href="https://github.com/bonarhyme/webworkers-typescript-react">克隆源代码</a>:</p>
<p><img data-attachment-id="161156" data-permalink="https://blog.logrocket.com/?attachment_id=161156" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-react-typescript-app-example.gif" data-orig-size="730,382" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="web-workers-react-typescript-app-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-react-typescript-app-example-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-react-typescript-app-example.gif" decoding="async" class="aligncenter wp-image-161156 size-full jetpack-lazy-image" src="../Images/83f9d7bb8d531e4babacdd97a2584be5.png" alt="Web Workers React Typescript App Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-react-typescript-app-example.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-react-typescript-app-example.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="161156" data-permalink="https://blog.logrocket.com/?attachment_id=161156" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-react-typescript-app-example.gif" data-orig-size="730,382" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="web-workers-react-typescript-app-example" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-react-typescript-app-example-300x157.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-react-typescript-app-example.gif" decoding="async" loading="lazy" class="aligncenter wp-image-161156 size-full" src="../Images/83f9d7bb8d531e4babacdd97a2584be5.png" alt="Web Workers React Typescript App Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-react-typescript-app-example.gif"/></noscript>
<p><em>向前跳转:</em></p>

<h2 id="what-webworkers">什么是网络工作者？</h2>
<p>web worker是在网页后台运行的JavaScript进程。默认情况下，JavaScript是单线程的。因此，JavaScript只有一个线程或执行路径，即主线程，它同步执行网页上的所有JavaScript代码。</p>
<p>另一方面，Web workers是一种浏览器特性，它允许您并行执行多个JavaScript线程，而不会干扰DOM。</p>
<p>与主线程不同，web workers不能访问和操作DOM，但是他们可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest"> XMLHttpRequest </a>或<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"> Fetch </a>来执行I/O。主线程不必执行所有的JavaScript代码，我们可以创建一个web worker来处理任何长时间运行的计算，确保主线程不会不堪重负。</p>
<p>要创建一个worker对象，可以使用<code>worker()</code>构造函数。请记住，web workers是在全局上下文中运行的，这不同于<code>window</code>对象。</p>
<p>在JavaScript中，web workers使开发人员能够实现多线程或真正的并发。并发系统是使用不同的并发模型实现的，这些并发模型指定线程应该如何交互来完成任务。并发模型的一个重要方面是线程是共享状态还是被隔离。</p>
<p>JavaScript支持两种并发模型，即<a href="https://en.wikipedia.org/wiki/Actor_model">角色模型</a>和共享内存。这两种并发模型都有优点和缺点，不同地使用工人，并且经常被归入术语“脱离主线程”架构。</p>
<p>截至2023年，所有主流浏览器都完全支持网络工作者，如下图所示:</p>
<p><img data-attachment-id="161159" data-permalink="https://blog.logrocket.com/?attachment_id=161159" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023.png" data-orig-size="730,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="web-workers-browser-support-2023" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023.png" decoding="async" class="aligncenter wp-image-161159 size-full jetpack-lazy-image" src="../Images/55fa6f03eddcc7086be7535c39a865b0.png" alt="Web Workers Browser Support 2023" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023-300x117.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="161159" data-permalink="https://blog.logrocket.com/?attachment_id=161159" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023.png" data-orig-size="730,285" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="web-workers-browser-support-2023" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023-300x117.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023.png" decoding="async" loading="lazy" class="aligncenter wp-image-161159 size-full" src="../Images/55fa6f03eddcc7086be7535c39a865b0.png" alt="Web Workers Browser Support 2023" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023-300x117.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/web-workers-browser-support-2023.png"/></noscript>
<p>请注意，只有当您的站点需要执行繁重的工作时，您才需要使用web workers。</p>
<h2 id="setting-up-react-typescript-webworker-project">设置React和TypeScript web worker项目</h2>
<p>为了设置我们的项目，我们将创建一个新文件夹来包含我们的代码；我给我的取名<code>app</code>。在您选择的代码编辑器中打开新文件夹，然后在您的终端中运行以下代码来设置React和TypeScript项目:</p>
<pre>npx create-react-app ./ --template TypeScript
</pre>
<p>随着项目的建立，我们将在<code>src</code>中创建三个文件夹:</p>
<ul>
<li><code>components</code>:店铺<code>Loader.tsx</code>、<code>Pagination.tsx</code>、<code>Table.tsx</code></li>
<li><code>data</code>:存储<code>index.ts</code>文件</li>
<li><code>longProcess</code>:店铺<code>count.ts</code>、<code>enums.ts</code>、<code>getData.ts</code>:</li>
</ul>
<p>我们的文件夹和文件结构应该如下所示:</p>
<pre>app
├── README.md
├── node_modules
├── package.json
├── tsconfig.json
├── .gitignore
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
└── src
    ├──components
    │   ├── Loader.tsx
    │   ├── Pagination.tsx
    │   └── Table.tsx
    |
    ├──data
    │   └── index.ts
    |
    ├──longProcesses
    │   ├── count.ts
    │   ├── enums.ts
    │   └── getData.ts
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    ├── serviceWorker.js
    └── setupTests.js
</pre>
<p>要启动开发服务器，请在终端中运行<code>npm start</code>或<code>yarn start</code>。</p>
<h2 id="preparing-typescript-data">准备打字稿数据</h2>
<p>在<code>data/index.ts</code>中，我们将添加一个<a href="https://raw.githubusercontent.com/bonarhyme/webworkers-typescript-react/main/src/data/index.ts">长数组</a>，它包含了5000个看起来类似如下的对象:</p>
<pre>    {
      "albumId": 1,
      "id": 2,
      "title": "reprehenderit est deserunt velit ipsam",
      "url": "https://via.placeholder.com/600/771796",
      "thumbnailUrl": "https://via.placeholder.com/150/771796"
    },
</pre>
<h3 id="creating-enums">创建枚举</h3>
<p><a href="https://blog.logrocket.com/typescript-string-enums-guide/">枚举</a>定义了一组不变的命名常量或变量。enum是TypeScript中的一个特殊类，它表示一组不可更改的变量，就像一个调用了<code>freeze</code>方法的对象。枚举确保在代码中始终使用正确的变量名，防止变量拼写错误时可能发生的错误。要了解更多关于在TypeScript 中扩展枚举的信息，请查看我们的指南。</p>
<p>为了确保我们调用了正确的变量，我们必须在<code>longProcesses/enums.ts</code>中创建并导出<code>processList</code>和<code>ProfileEnum</code>，这些枚举将在文件中使用:</p>
<pre>// longProcesses/enums.ts

export enum processList {
 count = "count",
 getData = "getData",
}

export enum ProfileEnum {
 albumId = "Album Id",
 id = "ID",
 title = "Title",
 url = "Url",
 thumbnailUrl = "Thumbnail",
}
</pre>
<h2 id="building-app-ts-generate-types">建筑类型<code>App.ts</code>和<code>Generate</code></h2>
<p>TypeScript最重要的特性之一是它检查<a href="https://blog.logrocket.com/write-fewer-tests-by-creating-better-typescript-types/">类型</a>的能力。我们可以为任何变量、参数、对象或数组定义类型，确保我们总是使用正确的数据类型。</p>
<p><code>App.ts</code>是我们应用的切入点。这里我们将定义四种类型，<code>LengthCountType</code>、<code>ProfileType</code>、<code>ProfileListType</code>和<code>GetDataType</code>。我们还将创建一个功能组件，它返回一个<code>jsx</code>，两个<code>section</code>组件嵌套在一个<code>div</code>中，如下面的代码所示:</p>
<pre>// App.ts

type LengthCountType = {
  loading: boolean;
  value: number;
};

export type ProfileType = {
  albumId: number | string;
  id: number | string;
  title: string;
  url: string;
  thumbnailUrl: string;
};

export type ProfileListType = {
  loading: boolean;
  list: unknown &amp; Array&lt;ProfileType&gt;;
  page: number;
};

export type GetDataType = {
  action: string;
  period: "initial" | "next" | "prev" | "pageNumber";
  thePageNumber: number;
};

export const listPageSize = 50;

const App = () =&gt; {
    return (
        &lt;main className="main-container"&gt;
            &lt;section className="count"&gt;&lt;/section&gt;
            &lt;section className="table-container"&gt;&lt;/section&gt;
        &lt;/main&gt;
    )
}
</pre>
<h2 id="designing-web-worker-checking-array-lengths">设计用于检查数组长度的web worker</h2>
<p>确定长数组的长度会阻塞web应用程序使用的单线程。然而，使用web worker，我们可以在不阻塞线程的情况下成功地检查长数组的长度。我们将在<code>longProcesses/count.ts</code>中为此添加代码:</p>
<pre>// longProcesses/count.ts

/* eslint-disable no-restricted-globals */
import { profiles } from "../data";
import { processList } from "./enums";

self.onmessage = (e: MessageEvent&lt;string&gt;) =&gt; {
  if (e.data === processList.count) {
    const findLength = profiles.length;

    self.postMessage(findLength);
  }
};

export {};
</pre>
<p>首先，我们禁用表明我们错误使用了<code>self</code>的错误。接下来，我们导入数组和<code>processList</code>枚举。然后，我们监听<code>onmessage</code>事件，当一条消息被发送到工人文件时，该事件被触发。</p>
<p>检查传递的数据是否等同于<code>count</code>枚举。如果是，我们将获得数据的长度，并将其发送回DOM中的原始文件。最后，为了防止TypeScript引发错误，请导出一个空对象。</p>
<h3 id="creating-loader-component">创建<code>Loader</code>组件</h3>
<p><code>Loader</code>组件将指示进程何时在后台被处理。在<code>components/Loader.ts</code>中，添加以下代码:</p>
<pre>// components/Loader.ts

import React from "react";

type Props = {
 color?: "black" | "white";
 size?: number;
 display?: "inline-block" | "block";
};

const Loader = ({
 color = "black",
 size = 20,
 display = "inline-block",
}: Props) =&gt; {
 return (
   &lt;div
     style={{
       border: `4px solid ${color}`,
       width: `${size}px`,
       height: `${size}px`,
       borderRightColor: "transparent",
       borderRadius: "50%",
       display,
       margin: display === "block" ? "50px auto" : "none",
     }}
     className="loader"
   &gt;&lt;/div&gt;
 );
};

export default Loader;
</pre>
<p>我们来分解一下。<code>Loader</code>接受三个道具，<code>color</code>、<code>size</code>和<code>display</code>。它返回一个带有样式的<code>div</code>。它还有一个<code>loader</code>类，已经在<code>index.css</code>中进行了样式化，以引起旋转运动:</p>
<pre>// index.css

.loader {
 animation: spinner 1s linear forwards infinite;
}

@keyframes spinner {
 from {
   transform: rotate(0deg);
 }

 to {
   transform: rotate(360deg);
 }
}
</pre>
<h2 id="using-count-webworker-typescript">在TypeScript中使用<code>count</code> web worker</h2>
<p>web worker决定了我们拥有的长数组的长度。要使用<code>count</code> worker，打开<code>App.ts</code>并从React和<code>processList</code> enum导入<code>useMemo</code>、<code>useEffect</code>和<code>useState</code>钩子:</p>
<pre>// App.ts

import React, { useEffect, useMemo, useRef, useState } from "react";
import { processList } from "./longProcesses/enums";
</pre>
<p>在组件内部，我们将使用已经创建的<code>count.ts</code> worker文件初始化一个新的web worker:</p>
<pre>// App.ts

// const App = () =&gt; {

  const counter: Worker = useMemo(
    () =&gt; new Worker(new URL("./longProcesses/count.ts", import.meta.url)),
    []
  );
</pre>
<p>接下来，我们将创建一个状态，为我们在本地存储数组的长度:</p>
<pre>// App.ts

  const [lengthCount, setLengthCount] = useState&lt;LengthCountType&gt;({
    loading: true,
    value: 0,
  });
</pre>
<p>我们将使用初始化的<code>counter</code>向<code>useEffect</code>钩子内的<code>count</code>工作者发送一条消息:</p>
<pre>// App.ts

  useEffect(() =&gt; {
    if (window.Worker) {
      counter.postMessage(processList.count);
    }
  }, [counter]);
</pre>
<p>然后，我们将为<code>lengthCount</code>状态创建一组适当的值:</p>
<pre>  useEffect(() =&gt; {
    if (window.Worker) {
      counter.onmessage = (e: MessageEvent&lt;string&gt;) =&gt; {
        setLengthCount((prev) =&gt; ({
          ...prev,
          loading: false,
          value: Number(e.data) &amp;&amp; Number(e.data),
        }));
      };
    }
  }, [counter]);
</pre>
<p>最后，我们将使用<code>lengthCount</code>状态在UI上呈现一个加载器和数组的长度:</p>
<pre>// App.ts

    &lt;section className="count"&gt;
        Total count of Profiles is{" "}
        &lt;b&gt;{lengthCount.loading ? &lt;Loader size={14} /&gt; : lengthCount.value}&lt;/b&gt;
      &lt;/section&gt;
</pre>
<p>在<code>counter</code>变量中，我们用<code>useMemo</code>包装worker实例，防止重新渲染时不必要的重新初始化。在函数内部，我们使用了<code>new Worker</code>方法，并传入了一个新的生成的URL实例，它包含了<code>count</code> worker文件的路径。</p>
<p><code>lengthCount</code>状态保持计数器的<code>loading</code>和<code>value</code>状态。第一个<code>useEffect</code>在第一次重新渲染时运行<code>count</code>工作器。本质上，它在向<code>count</code> worker文件发送消息之前检查用户的浏览器是否支持web workers。</p>
<p>第二个<code>useEffect</code>从<code>count</code>工作器接收响应，并将接收到的响应设置为<code>lengthCount</code>状态。</p>
<p>在标记中，我们在流程仍在运行时显示加载器，并在完成时显示值。</p>
<h2 id="create-worker-typescript-get-data">在TypeScript中创建一个worker来获取数据</h2>
<p>从像我们这样的长阵列中获取数据会导致用户设备的延迟，从而导致糟糕的UX；我们可以通过网络工作者来防止这种情况。</p>
<p>首先，我们将向<code>longProcesses/getData.ts</code>添加以下代码:</p>
<pre>// getData.ts

/* eslint-disable no-restricted-globals */
import { GetDataType, listPageSize, ProfileListType } from "../App";
import { profiles } from "../data";
import { processList } from "./enums";

self.onmessage = (e: MessageEvent&lt;string&gt;) =&gt; {
  const data = JSON.parse(e.data) as GetDataType;

  if (data.action !== processList.getData) {
    return;
  }
  if (data.period === "initial") {
    const items = profiles.filter((item, index) =&gt; index &lt; listPageSize);

    const response = {
      loading: false,
      list: items,
      page: data.thePageNumber,
    } as ProfileListType;

    self.postMessage(JSON.stringify(response));
  }
}

export {};
</pre>
<p>首先，我们导入在<code>App.ts</code>、数据列表和<code>processList</code>中定义的类型。然后，我们解析事件中返回的数据，并将其设置为<code>GetDataType</code>。我们检查动作的类型是否无效，动作的周期是否开始；如果是这样，我们将使用<a href="https://blog.logrocket.com/javascript-array-methods/"> JavaScript <code>filter</code>方法</a>获取列表中的前50项，创建一个响应对象，然后将其作为<code>string</code>发布。</p>
<h3 id="building-table">建造一张桌子</h3>
<p>该表将在UI上显示项目列表。在<code>components/Table.tsx</code>中，添加以下代码:</p>
<pre>import React from "react";
import { ProfileType } from "../App";
import { ProfileEnum } from "../longProcesses/enums";

type Props = {
  list: Array&lt;ProfileType&gt;;
};

const Table = ({ list }: Props) =&gt; {
  return (
    &lt;div className="table"&gt;
      &lt;table&gt;
        &lt;thead&gt;
          &lt;tr&gt;
            &lt;th&gt;#&lt;/th&gt;
            &lt;th&gt;{ProfileEnum.id}&lt;/th&gt;
            &lt;th&gt;{ProfileEnum.title}&lt;/th&gt;
            &lt;th&gt;{ProfileEnum.albumId}&lt;/th&gt;
            &lt;th&gt;{ProfileEnum.thumbnailUrl}&lt;/th&gt;
          &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;
          {list.length &gt; 0 &amp;&amp;
            list.map((item, index: number) =&gt; {
              return (
                &lt;tr key={item?.id}&gt;
                  &lt;td&gt;{index + 1}&lt;/td&gt;
                  &lt;td&gt;{item?.id}&lt;/td&gt;
                  &lt;td&gt;{item?.title}&lt;/td&gt;
                  &lt;td&gt;{item?.albumId}&lt;/td&gt;
                  &lt;td&gt;
                    &lt;img
                      src={item?.thumbnailUrl}
                      alt={item?.title}
                      width={50}
                      height={50}
                      loading="lazy"
                    /&gt;
                  &lt;/td&gt;
                &lt;/tr&gt;
              );
            })}
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  );
};

export default Table;
</pre>
<p>首先，我们导入<code>ProfileType</code>和<code>ProfileEnum</code>，然后为我们的<code>Table</code>组件定义一个<code>PropType</code>。接下来，我们创建一个返回<code>table</code>的<code>div</code>:</p>
<ul>
<li><code>table:</code>返回一个<code>thead</code>和<code>tbody</code></li>
<li><code>thead</code>:返回一个包含五个<code>th</code>的<code>tr</code></li>
<li><code>tbody</code>:包含一个<code>map</code>，返回一个<code>tr</code></li>
<li><code>tr</code>:返回五个<code>td</code></li>
</ul>
<p><span>为了提高性能，w </span> e使用<code>loading="lazy"</code> <span>属性使用延迟加载来生成图像。</span></p>
<h2 id="using-getdata-webworker-typescript">在TypeScript中使用<code>getData</code> web worker</h2>
<p>使用<code>getData</code> web worker类似于我们使用<code>count</code> worker的方式。首先，我们将使用下面的代码初始化一个新的worker:</p>
<pre>// App.ts

const getData: Worker = useMemo(
    () =&gt; new Worker(new URL("./longProcesses/getData.ts", import.meta.url)),
    []
  );
</pre>
<p>接下来，我们将定义本地状态来处理<code>profileList</code>状态:</p>
<pre>// App.ts

  const [profileList, setProfileList] = useState&lt;ProfileListType&gt;({
    loading: true,
    list: [],
    page: 1,
  });
</pre>
<p>然后，我们将创建一个<code>useEffect</code>，在初始渲染时使用<code>getData</code>:</p>
<pre>// App.ts

  useEffect(() =&gt; {
    if (window.Worker) {
      const request = {
        action: processList.getData,
        period: "initial",
        thePageNumber: profileList.page,
      } as GetDataType;

      getData.postMessage(JSON.stringify(request));
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
</pre>
<p>我们将创建另一个<code>useEffect</code>，它将处理从<code>getData</code> web worker文件接收响应:</p>
<pre>// App.ts

  useEffect(() =&gt; {
    if (window.Worker) {
      getData.onmessage = (e: MessageEvent&lt;string&gt;) =&gt; {
        const response = JSON.parse(e.data) as unknown as ProfileListType;

        setProfileList((prev) =&gt; ({
          ...prev,
          loading: response.loading,
          list: response.list,
          page: response.page,
        }));
      };
    }
  }, [getData]);
</pre>
<p>最后，我们将使用我们创建的<code>Table</code>组件显示数据:</p>
<pre>    &lt;section className="table-container"&gt;
        {profileList.loading ? (
          &lt;Loader size={40} display="block" /&gt;
        ) : (
          &lt;&gt;
            &lt;Table list={profileList.list} /&gt;
          &lt;/&gt;
        )}
      &lt;/section&gt;
</pre>
<p>在<code>getData</code>变量中，<code>useMemo</code>包装了worker实例，以防止重新渲染时不必要的重新初始化。在函数内部，我们使用了<code>new Worker</code>方法，并传入了一个新的生成的URL实例，它包含了<code>getData</code> worker文件的路径。<code>profileList</code>状态在我们的应用程序中本地保存<code>getData</code>工作者的<code>loading</code>、<code>list</code>和<code>page</code>状态。</p>
<p>第一次重新渲染时，第一个<code>useEffect</code>运行<code>getData</code>。它检查用户的浏览器是否支持web workers它还包含一个请求对象，该对象在被发送到<code>getData</code>工作文件之前被字符串化。请求对象包含一个<code>action</code>、<code>period</code>和<code>thePageNumber</code>键-值对。第二个<code>useEffect</code>接收来自<code>getData</code>的响应，并将接收到的响应设置为<code>profileList</code>状态。</p>
<p>在标记中，我们在流程仍在运行时显示一个加载器，并在流程完成时呈现一个表。请记住，传递给元素的类是用来设计它们的样式的。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>

<p>当用户选择<code>next</code>和<code>prev</code>按钮或页码时，<code>pagination</code>组件将导航到某个页面。</p>
<p>为了实现该功能的worker，我们将修改<code>longProcesses/getData.ts</code>中的<code>getData</code> worker，并向其添加以下代码:</p>
<pre>// longProcesses/getData.ts

  if (
    data.period === "pageNumber" ||
    data.period === "next" ||
    data.period === "prev"
  ) {
    const items = profiles.slice(
      (data.thePageNumber - 1) * listPageSize,
      data.thePageNumber * listPageSize
    );
    const response = {
      loading: false,
      list: items,
      page: data.thePageNumber,
    } as ProfileListType;

    self.postMessage(JSON.stringify(response));
  }
</pre>
<p>从向<code>getData</code>工作者发送消息的文件中，我们将获得一个包含<code>period</code>键的<code>data</code>对象。在使用页码和列表页面大小分割页面之前，我们检查这个键是否等于<code>pageNumber</code>、<code>next</code>或<code>prev</code>。然后，创建一个<code>response</code>对象，并将响应作为字符串化的消息发布。</p>

<p>为了创建分页组件，我们将向<code>components/Pagination</code>添加以下代码，创建<code>pagination component.tsx</code>:</p>
<pre>// Pagination.tsx

import React from "react";

type Props = {
  page: number;
  pages: number;
  pageClick: (page: number) =&gt; void;
  prevHandler: () =&gt; void;
  nextHandler: () =&gt; void;
};

const Pagination = ({
  page,
  pages,
  pageClick,
  prevHandler,
  nextHandler,
}: Props) =&gt; {
  return (
    &lt;div className="pagination-container"&gt;
      &lt;button className="prev" onClick={prevHandler} disabled={page === 1}&gt;
        Prev
      &lt;/button&gt;
      &lt;ul className="pages-container"&gt;
        {[...Array(Math.ceil(pages)).keys()].map((x, i) =&gt; {
          return (
            &lt;li
              key={i}
              className={page - 1 === i ? "active page-item" : "page-item"}
              onClick={() =&gt; {
                pageClick(x + 1);
              }}
            &gt;
              {x + 1}
            &lt;/li&gt;
          );
        })}
      &lt;/ul&gt;
      &lt;button className="next" onClick={nextHandler} disabled={page === pages}&gt;
        Next
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Pagination;
</pre>
<p>首先，我们定义props类型，它包含<code>page</code>和<code>pages</code>，并且必须接受一个数字。<code>pageClick</code>、<code>prevHandler</code>和<code>nextHandler</code>必须接受一个函数。在<code>jsx</code>中，我们用一个类返回一个<code>div</code>。在<code>div</code>中，我们返回三个元素<code>button</code>、<code>ul</code>和第二个<code>button</code>。</p>
<p>第一个<code>button</code>包含一个类和一个运行<code>prevHandler</code>函数的<code>onclick</code>事件监听器。当当前页面是第一页时，它被禁用。<code>ul</code>包含一个类，并使用<code>pages</code>值返回一个数字数组。</p>
<p>我们使用一个<code>map</code>函数遍历新数组并返回一个<code>li</code>元素。每个<code>li</code>包含一个键，一个当<code>li</code>激活时改变的类。它还包含一个运行<code>pageClick</code>函数的<code>onClick</code>事件处理程序。</p>
<p>如果TypeScript抱怨将一个数字转换成数组，那么将下面的密钥对添加到您的<code>tsconfig.json</code>文件中的<code>compilerOption</code>对象中:</p>
<pre>// tsconfig.json
    "downlevelIteration": true /** This fixes error when converting numbers to array of numbers*/,
</pre>
<p>最后一个按钮是<code>next</code>按钮，它接受一个类和一个运行<code>nextHandler</code>功能的<code>onClick</code>事件处理程序。当当前页面是最后一页时，它被禁用。</p>
<h2 id="designing-page-handlers">设计页面处理程序</h2>
<p>页面处理程序是我们在使用组件时传递给它的函数。我们将创建的第一个函数是<code>handlePageNumber</code>，它将在用户点击页面时被调用:</p>
<pre>  const handlePageNumber = (userSelectedPage: number) =&gt; {
    if (window.Worker) {
      const request = {
        action: processList.getData,
        period: "pageNumber",
        thePageNumber: userSelectedPage,
      } as GetDataType;

      getData.postMessage(JSON.stringify(request));
    }
  };
</pre>
<p>点击<strong>上一页</strong>按钮时，将调用第二个函数<code>prevHandler</code>:</p>
<pre>  const prevHandler = (userSelectedPage: number) =&gt; {
    if (profileList.page === 1) {
      return;
    }

    if (window.Worker) {
      const request = {
        action: processList.getData,
        period: "prev",
        thePageNumber: userSelectedPage - 1,
      } as GetDataType;

      getData.postMessage(JSON.stringify(request));
    }
  };
</pre>
<p>我们的最后一个函数是<code>nextHandler</code>，当点击<strong>下一个</strong>按钮时会调用这个函数:</p>
<pre>  const nextHandler = (userSelectedPage: number, thePageLength: number) =&gt; {
    if (userSelectedPage &lt; thePageLength) {
      if (window.Worker) {
        const request = {
          action: processList.getData,
          period: "next",
          thePageNumber: userSelectedPage + 1,
        } as GetDataType;

        getData.postMessage(JSON.stringify(request));
      }
    }
  };
</pre>
<p><code>handlePageNumber</code>接受<code>userSelectedPage</code>作为参数。然后我们检查浏览器是否支持web workers。如果是这样，我们创建一个包含<code>action</code>、<code>period</code>和<code>thePageNumber</code>的<code>request</code>对象。我们将<code>request</code>作为字符串消息发送给<code>getData</code> web worker。</p>
<p>我们的下一个函数，<code>prevHandler</code>接受<code>userSelectedPage</code>作为<code>param</code>。我们检查当前页面是否是第一页，什么也不做。然后，我们创建一个请求对象。然而，我们将发送一个递减的<code>thePageNumber</code>键。</p>
<p>最后，<code>nextHandler</code>和前两个函数一样，但是，它接受两个道具。首先，我们检查<code>userSelectedPage</code>是否小于我们上面定义的<code>thePageLength</code>变量的值。另外，<code>thePageNumber</code>键递增。</p>

<p>要使用<code><a href="https://blog.logrocket.com/guide-pagination-load-more-buttons-infinite-scroll/">pagination</a></code>组件，我们需要将其导入到<code>component/App.ts</code>中:</p>
<pre>// App.ts

import Pagination from "./components/Pagination";
</pre>
<p>接下来，我们将在<code>Table</code>组件下添加以下标记:</p>
<pre>// App.ts

  &lt;Pagination
    page={profileList.page}
    pages={lengthCount.value / listPageSize}
    pageClick={(pageNumber) =&gt; {
      handlePageNumber(pageNumber);
    }}
    prevHandler={() =&gt; prevHandler(profileList.page)}
    nextHandler={() =&gt;
      nextHandler(profileList.page, lengthCount.value / listPageSize)
    }
  /&gt;
</pre>
<p>首先，我们将<code>profileList.page</code>传递给页面，<code>lengthCount.value / listPageSize</code>传递给页面，<code>handlePageNumber</code>函数传递给<code>pageClick</code>属性。最后，我们将<code>prevHandler</code>和<code>nextHandler</code>传递给它们相应的道具。</p>
<h3 id="adding-styling-web-workers">为您的web workers添加样式</h3>
<p>为了设计web workers的样式，我将使用下面的代码。但是，您可以使用自己选择的任何样式:</p>
<pre>// index.css

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  padding-bottom: 4rem;
}

.loader {
  animation: spinner 1s linear forwards infinite;
}

@keyframes spinner {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

.main-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 2rem;
}

.count {
  padding: 2rem 0 3rem;
  font-size: 2rem;
  text-align: center;
}

.table-container {
  width: 95%;
  padding: 0 0.5rem;
  max-width: 700px;
}

table,
td,
th {
  border: 1px solid black;
  padding: 0.2rem;
}

table {
  border-collapse: collapse;
  width: 100%;
  min-height: 700px;
}

th {
  white-space: nowrap;
}

td {
  text-align: left;
  vertical-align: top;
}

td:first-child {
  font-weight: 300;
}

.pagination-container {
  display: flex;
  align-items: center;
  justify-content: center;
  margin: auto;
  gap: 1rem;
  width: 100%;
  max-width: 500px;
}

.pages-container {
  display: flex;
  list-style: none;
  gap: 0.5rem;
  overflow-x: scroll;
  padding-bottom: 0.5rem;
}

.pages-container &gt; * {
  background-color: rgb(49, 150, 238);
  padding: 0.3rem;
  min-width: 40px;
  text-align: center;
  cursor: pointer;
  border: none;
  border-radius: 8px;
}

.page-item.active {
  background-color: blue;
  color: white;
}

.prev,
.next {
  padding: 0.6rem;
  text-align: center;
  cursor: pointer;
}
</pre>
<h2 id="conclusion">结论</h2>
<p>使用带有TypeScript和React的web workers变得容易多了；我们现在可以在后台处理操作和繁重的任务，同时提升性能和改善UX。</p>
<p>感谢阅读！我希望你喜欢这篇文章，如果你有任何问题，一定要留下评论。编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Using tsm as a shebang interpreter in TypeScript - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 TypeScript - LogRocket 博客中使用 tsm 作为 shebang 解释器</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-tsm-shebang-interpreter-typescript/#0001-01-01">https://blog.logrocket.com/using-tsm-shebang-interpreter-typescript/#0001-01-01</a></blockquote><div><article class="article-post">
<p>TypeScript 已经席卷了 web 开发界，对于企业项目和个人开发人员来说越来越受欢迎。</p>
<p>执行 TypeScript 代码通常需要将其转换成普通的 JavaScript，以便在 Node.js 或浏览器等常见环境中使用。这种方法仍然代表了 TypeScript 程序的大部分运行方式，但是已经出现了一些允许开发人员直接运行他们的 TypeScript 代码的项目。</p>
<p>tsm 在这一领域是一个全新的参与者，代表着更广泛的 TypeScript/JavaScript 生态系统向前迈进了一步。</p>
<h2>什么是 tsm？</h2>
<p>tsm 是卢克·爱德华兹创建的 Node.js、<a href="https://twitter.com/lukeed05" target="_blank" rel="noopener">的 TypeScript 模块加载器。它扩展了 Node.js 以提供本机 TypeScript 支持，而无需先将其转换为 JavaScript。</a></p>
<p>相反，tsm 使用<a href="https://blog.logrocket.com/getting-started-esbuild/" target="_blank" rel="noopener"> esbuild </a>在将 TypeScript 源代码传递给 Node.js 运行时之前，快速地将它转换成 JavaScript。这种方法本质上抽象了典型的 transpilation 步骤，使其对用户透明。</p>
<h2>应该使用 tsm 吗？</h2>
<p>使用 tsm 的主要也是最明显的优势是开发人员不需要担心 TypeScript 的移植。这意味着开发反馈循环更短，构建工具更简单，部署更直接。这对于像一次性脚本这样的小项目特别方便。</p>
<p>因为 tsm 运行在 Node.js 之上，熟悉 Node 的开发人员会发现使用 tsm 很自然，只需一个简单的步骤就可以轻松地将 TypeScript 合并到他们的项目中。</p>
<p>例如，esbuild 具有内置的源映射支持，这意味着在 tsm 下运行的 TypeScript 程序可以使用标准的 V8 调试协议(包含在 Node.js 中)和<a href="https://blog.logrocket.com/how-to-debug-node-js-apps-in-visual-studio-code/" target="_blank" rel="noopener">流行的调试工具(如 VS Code </a>)进行调试。</p>
<p>此外，npm 包和节点内置 API 的庞大生态系统可用于运行 tsm 的 TypeScript。</p>
<h2>tsm 的缺点</h2>
<p>使用 tsm 的一个相对较小的代价是，除了 Node.js 本身之外，它还必须安装在需要运行 TypeScript 代码的系统上。</p>
<p>如果分发打算直接从 shell 中运行的脚本(比如通过 shebang 解释器指令将 tsm 用作脚本的解释器)，这可能会带来不便，但对于完全打包的 Node.js 模块来说，这不是问题。</p>
<p>除此之外，假设对新的和新兴的(因此，潜在的变化)技术有兴趣，尝试一下 tsm 没有太多的负面影响。</p>
<p>与项目技术栈的其他元素(如数据库、编程语言、框架等)不同。)，JavaScript 构建工具的好处是它们可以在以后被替换，对应用程序源代码本身的影响很小。</p>
<h2>如何在 Node.js 项目中使用 tsm</h2>
<p>有几种不同的方法可以将 tsm 挂接到 Node.js 项目中。</p>
<h3>作为可执行文件<code>node</code>的替代</h3>
<p>假设您已经全局安装了 tsm(通过<code>npm -- global install tsm</code>或<code>yarn global add tsm</code>，您可以使用<code>tsm</code>可执行文件运行类型脚本文件，如下所示:</p>
<pre class="language-shell hljs">tsm index.ts</pre>
<p>对于本地安装，<code>tsm</code>可执行文件可以在<code>./node_modules/.bin/tsm</code>找到。</p>
<p>注意，任何命令行标志都将被传递给<code>node</code>，这对于实验特性、调试配置等非常方便。</p>
<h3>使用 shebang 解释器指令</h3>
<p>因为 tsm 包含一个可执行文件，所以它可以像任何其他脚本解释器一样在 shebang 指令中使用。Shebang 指令的格式如下:<code>!#&lt;path/to/interpreter&gt; [arguments]</code>。</p>
<p>它们出现在文件的第一行，告诉操作系统使用哪个程序来解析和执行文件的其余部分。</p>
<p>例如:</p>
<pre class="language-typescript hljs">#!/usr/local/bin/tsm

function print(message: string): void {
  console.log(message);
}

print('hello from TypeScript!');</pre>
<h3>使用<code>--require</code>或<code>--loader</code>挂钩</h3>
<p>如果你仍然需要直接使用<code>node</code>而不是<code>tsm</code>可执行文件，你可以使用<code>--require</code>或<code>--loader</code>钩子来指示<code>node</code>使用<code>tsm</code>来加载类型脚本文件。为此，tsm 需要作为本地依赖项(而不是全局依赖项)安装。</p>
<pre class="language-shell hljs">node --require tsm index.ts</pre>
<pre class="language-shell hljs">node --loader tsm index.ts</pre>
<figure id="attachment_80445" aria-describedby="caption-attachment-80445" class="wp-caption aligncenter"><img data-attachment-id="80445" data-permalink="https://blog.logrocket.com/using-tsm-shebang-interpreter-typescript/tsm-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/tsm-demo.gif" data-orig-size="730,466" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tsm-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/tsm-demo-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/tsm-demo.gif" decoding="async" class="wp-image-80445 size-full jetpack-lazy-image" src="../Images/3220e7988822988c3a8d0fd58557beea.png" alt="Demo: using tsm with require hook" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/11/tsm-demo.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/tsm-demo.gif"/><noscript><img data-lazy-fallback="1" data-attachment-id="80445" data-permalink="https://blog.logrocket.com/using-tsm-shebang-interpreter-typescript/tsm-demo/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/11/tsm-demo.gif" data-orig-size="730,466" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="tsm-demo" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/11/tsm-demo-300x192.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/11/tsm-demo.gif" decoding="async" loading="lazy" class="wp-image-80445 size-full" src="../Images/3220e7988822988c3a8d0fd58557beea.png" alt="Demo: using tsm with require hook" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/11/tsm-demo.gif"/></noscript><figcaption id="caption-attachment-80445" class="wp-caption-text">Demo: using tsm with <code>require</code> hook</figcaption></figure>
<h2>deno:TSM 的替代方案</h2>
<p>tsm 不是实现无翻译的可执行类型脚本的唯一方法。Node.js 的创建者 Ryan Dahl 发布了一个名为 Deno 的项目，该项目提供了现成的 TypeScript 支持。</p>
<p>像 Node.js 一样，Deno 建立在 V8 JavaScript 引擎之上，并试图克服 Node.js 的一些设计缺陷。</p>
<p>像 Node.js 和 tsm 一样，Deno 可以直接作为可执行文件使用:</p>
<pre class="language-shell hljs">deno index.ts</pre>
<p>它也可以用在 shebang 指令中:</p>
<pre class="language-typescript&gt; hljs">!#/usr/local/bin/deno

...</pre>
<p>然而，在 TypeScript 中为 Node.js 编写的代码可能无法移植到 Deno，因为<a href="https://blog.logrocket.com/tag/deno/" target="_blank" rel="noopener"> Deno </a>提供了自己的标准库来替代 Node.js APIs。它也有自己的分发模块的范例，而不是利用 npm。查看 Deno 的<a href="https://deno.land/std" target="_blank" rel="noopener">标准库</a>和<a href="https://doc.deno.land/builtin/stable" target="_blank" rel="noopener"> API 文档</a>了解更多细节。</p>
<h2>结论</h2>
<p>tsm 是快速无缝地将 TypeScript 集成到 Node.js 项目中的好方法。因为它是基于 Node.js 构建的，所以 tsm 用户可以利用 npm 中庞大的软件包生态系统和强大的 Node.js APIs，所有这些都可以在 TypeScript 中完成，而无需设置复杂的构建过程。</p>
<p>查看 tsm 的<a href="https://github.com/lukeed/tsm" target="_blank" rel="noopener"> GitHub repo </a>及其<a href="https://github.com/lukeed/tsm/network/dependents?package_id=UGFja2FnZS00OTM3NTU4MzY%3D" target="_blank" rel="noopener">家属名单</a>，了解人们使用它的目的。一些值得注意的例子包括:</p>
<ul>
<li>create-figma-plugin :为 figma 和 FigJam 开发插件和小部件的综合工具包。它是用 TypeScript 编写的，在开发过程中使用 tsm</li>
<li>tinyhttp :用 TypeScript 编写的现代 web 框架。它在其文档示例中使用 tsm 作为让用户快速启动和运行的简单方法</li>
<li>nano stores:JavaScript 项目的微型状态管理器。tsm 用于该模块的开发周期</li>
</ul>
<p>简而言之，当您希望从 TypeScript 内部利用 Node 庞大的生态系统或将 TypeScript 集成到现有的 Node 代码库中时，请使用 tsm。如果您没有太多仅依赖 npm 的依赖项，并且希望享受 Deno 安全模型的好处，那么可以考虑在您的下一个服务器端 TypeScript 项目中使用 Deno。</p>
<p>编码快乐！</p><div class="code-block code-block-21">
<div class="blog-plug inline-plug typescript-plug"><h2><a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>:全面了解您的网络和移动应用</h2>
<a href="https://lp.logrocket.com/blg/typescript-signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p>LogRocket 是一个前端应用程序监控解决方案，可以让您回放问题，就像问题发生在您自己的浏览器中一样。LogRocket 不需要猜测错误发生的原因，也不需要向用户询问截图和日志转储，而是让您重放会话以快速了解哪里出错了。它可以与任何应用程序完美配合，不管是什么框架，并且有插件可以记录来自 Redux、Vuex 和@ngrx/store 的额外上下文。</p>
<p>除了记录 Redux 操作和状态，LogRocket 还记录控制台日志、JavaScript 错误、堆栈跟踪、带有头+正文的网络请求/响应、浏览器元数据和自定义日志。它还使用 DOM 来记录页面上的 HTML 和 CSS，甚至为最复杂的单页面和移动应用程序重新创建像素级完美视频。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200 只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的 web 应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的 DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket 检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录 Redux、NgRx 和 Vuex 操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>
<a class="signup" href="https://lp.logrocket.com/blg/typescript-signup" target="_blank" rel="noopener noreferrer">Try it for free</a><p>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Static site generation with React from scratch - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>从零开始用 React 生成静态站点</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/static-site-generation-with-react-from-scratch/#0001-01-01">https://blog.logrocket.com/static-site-generation-with-react-from-scratch/#0001-01-01</a></blockquote><div><article class="article-post">
<p>如果你问我什么框架有最好的组件模型，我会说毫不犹豫地做出反应。</p>
<p>这有各种各样的原因。一方面，React 制造的组件没有太多的仪式和妥协。该模型也非常独立于 React。有了新的 JSX 工厂，你甚至看不到 React 在 TypeScript 或 Babel 中的导入。</p>
<p>显然，当涉及到在 React 中专门构建每个前端应用程序时，必须有一个警告。除了关于 React 是否真的是做前端的正确方法的明显的宗教讨论之外，房间里的大象是……毕竟……只是 JavaScript。</p>
<p>这是一个 JavaScript 库，它<em>需要</em> JavaScript 才能运行。这意味着更长的下载时间，更臃肿的页面，可能还有不太好的 SEO 排名。</p>
<h2>不使用 JavaScript 使用 React 的选项</h2>
<p>那么我们能做些什么来改善这种情况呢？最初的反应可能是以下情况之一:</p>
<blockquote><p>"哦，是的，让我们用 Node.js 服务器代替，也做 SSR . "</p>
<p>“难道没有生成静态标记的东西吗？那个盖茨比是谁？”</p>
<p>“嗯，我都想要，但显然，一个做类似盖茨比的事情的 SSR 框架会很好。这是 Next.js 级别的吧？”</p>
<p>“听起来太复杂了。还是再用哲基尔吧。”</p>
<p>“为什么？！让我们欢迎所有人来到 2021 年——将任何页面作为水疗中心都很酷。”</p></blockquote>
<p>也许你倾向于认同其中的一个。就个人而言，根据问题的不同，我会选择后两者之一。当然，我用 React 做了相当多的服务器端渲染(SSR ),但我经常发现额外的复杂性不值得付出努力。</p>
<p>同样，我可能是少数几个真正不喜欢盖茨比的人之一。至少对我来说，它把几乎所有的事情都过度复杂化了，我没有看到太多的收获。</p>
<p>就这样了吗？当然，还有另一种方法。如果我们把我们的应用程序放在一个坚实的架构上，我们可以只写一个小脚本，实际上自己执行静态站点生成(SSG)——不需要 Gatsby 或其他任何东西。这不会那么复杂；然而，我们应该看到一些好的收获。</p>
<p>现在我们到底在期待什么呢？</p>
<h2>设定正确的期望</h2>
<p>在本帖中，我们将构建一个简单的解决方案，将使用 React 创建的页面转换为一组完全预生成的静态站点。我们将仍然能够水化这一点，让我们的网站充满活力。</p>
<p>我们的目标是提高初始渲染性能。在我们的 Lighthouse 测试中，我们发现我们自己的主页并不总是像我们希望的那样好。</p>
<p><img data-attachment-id="33165" data-permalink="https://blog.logrocket.com/static-site-generation-with-react-from-scratch/lighthouse-test-rendering-performance/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance.png" data-orig-size="500,119" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Lighthouse-Test-Rendering-Performance" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance-300x71.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance.png" decoding="async" class="aligncenter wp-image-33165 size-full jetpack-lazy-image" src="../Images/bd0a765f2573f88d77420780f5e6ff09.png" alt="React SSR before" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance.png 500w, https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance-300x71.png 300w" data-lazy-sizes="(max-width: 500px) 100vw, 500px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="33165" data-permalink="https://blog.logrocket.com/static-site-generation-with-react-from-scratch/lighthouse-test-rendering-performance/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance.png" data-orig-size="500,119" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Lighthouse-Test-Rendering-Performance" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance-300x71.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance.png" decoding="async" loading="lazy" class="aligncenter wp-image-33165 size-full" src="../Images/bd0a765f2573f88d77420780f5e6ff09.png" alt="React SSR before" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance.png 500w, https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance-300x71.png 300w" sizes="(max-width: 500px) 100vw, 500px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/Lighthouse-Test-Rendering-Performance.png"/></noscript>
<p>我们不会做的是优化静态页面，使它们只有很小的 JavaScript 片段。我们将始终用完整的 JavaScript 来充实页面(可能仍然是延迟加载的，但以后会有更多)。</p>
<p>尽管 SPA 的静态预渲染可能有利于感知性能，但我们不会关注性能优化。如果你对性能优化感兴趣，你应该看看这篇关于使用 webpack 进行性能优化的<a href="https://blog.logrocket.com/guide-performance-optimization-webpack/">深度指南。</a></p>
<h2>一个基本的 React 应用程序</h2>
<p>作为本文的样板，我们使用一个相当简单但非常常见的 React 应用程序。我们安装了一些开发依赖项(是的，我们将使用 TypeScript 进行翻译):</p>
<pre>npm i webpack webpack-dev-server webpack-cli typescript ts-loader file-loader html-webpack-plugin @types/react @types/react-dom @types/react-router @types/react-router-dom --save-dev
</pre>
<p>当然，还有一些运行时依赖性:</p>
<pre>npm i react react-dom react-router-dom react-router --save
</pre>
<p>现在我们设置一个合适的<code>webpack.config.js</code>来捆绑应用程序。</p>
<pre>module.exports = {
  mode: 'production',
  devtool: 'source-map',
  entry: './src/index.tsx',
  output: {
    filename: 'app.js',
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.js'],
  },
  module: {
    rules: [
      { test: /\.tsx?$/, loader: 'ts-loader' },
      { test: /\.(png|jpe?g|gif)$/i, loader: 'file-loader' },
    ],
  },
};
</pre>
<p>这将支持类型脚本和文件作为资产。请注意，对于一个更大的 web 应用程序，我们可能需要许多其他东西，但这对我们的演示来说已经足够了。</p>
<p>我们还应该添加一些有内容的页面来查看这个工作。在我们的结构中，我们将使用一个<code>index.tsx</code>文件来聚合所有内容。这个文件可以像下面这样简单:</p>
<pre>import * as React from 'react';
import { BrowserRouter, Route, Switch } from 'react-router-dom';
import { render } from 'react-dom';

const HomePage = React.lazy(() =&gt; import('./pages/home'));
const FirstPage = React.lazy(() =&gt; import('./pages/first'));
const NotFoundPage = React.lazy(() =&gt; import('./pages/not-found'));

const App = () =&gt; (
  &lt;BrowserRouter&gt;
    &lt;Switch&gt;
        &lt;Route path="/" exact component={HomePage} /&gt;
        &lt;Route path="/first" exact component={FirstPage} /&gt;
        &lt;Route component={NotFoundPage} /&gt;
    &lt;/Switch&gt;
  &lt;/BrowserRouter&gt;
);

render(&lt;App /&gt;, document.querySelector('#app'));
</pre>
<p>这种方法的问题是，我们需要为每个新页面编辑这个文件。如果我们使用将页面存储在<code>src/pages</code>目录中的惯例，我们可以得到更好的结果。我们有两个选择:</p>
<ol>
<li>使用 webpack 的<code>require.context</code>魔法来“读出”目录并获得一个我们可以使用的动态列表</li>
<li>使用一个特殊的编译时生成的模块来获得延迟加载和路径</li>
</ol>
<p>第二种方法提供了一个很大的优势，即路线可以是页面的一部分。对于这种方法，我们需要另一个 webpack 加载器:</p>
<pre>npm i parcel-codegen-loader --save-dev
</pre>
<p>这现在允许我们重构<code>index.tsx</code>文件，看起来像这样:</p>
<pre>import * as React from 'react';
import { BrowserRouter, Route, Switch } from 'react-router-dom';
import { render } from 'react-dom';
import Layout from './Layout';

const pages = require('./toc.codegen');
const [notFound] = pages.filter((m) =&gt; m.route === '*');
const standardPages = pages.filter((m) =&gt; m !== notFound);

const App = () =&gt; (
  &lt;BrowserRouter&gt;
    &lt;Layout&gt;
      &lt;Switch&gt;
        {standardPages.map((page) =&gt; (
          &lt;Route key={page.route} path={page.route} exact component={page.content} /&gt;
        ))}
        {notFound &amp;&amp; &lt;Route component={notFound.content} /&gt;}
      &lt;/Switch&gt;
    &lt;/Layout&gt;
  &lt;/BrowserRouter&gt;
);

render(&lt;App /&gt;, document.querySelector('#app'));
</pre>
<p>现在所有页面都完全由<code>toc.codegen</code>决定，这是一个在捆绑过程中动态生成的模块。此外，我们添加了一个<code>Layout</code>组件，让我们的页面有点共享结构。</p>
<p><code>toc</code>模块的代码生成器如下所示:</p>
<pre>const { getPages } = require('./helpers');

module.exports = () =&gt; {
  const pageDetails = getPages();
  const pages = pageDetails.map((page) =&gt; {
    const meta = [
      `"content": lazy(() =&gt; import('./${page.folder}/${page.name}'))`,
      `${JSON.stringify('route')}: ${JSON.stringify(page.route)}`,
    ];

    return `{ ${meta.join(', ')} }`;
  });

  return `const { lazy } = require('react');
module.exports = [${pages.join(', ')}];`;
};
</pre>
<p>我们只是迭代所有页面并生成一个新模块，导出一个带有<code>route</code>和<code>content</code>属性的对象数组。</p>
<p>此时，我们的目标是预先呈现这个简单(但完整)的应用程序。</p>
<h2>SSG 的基础知识与反应</h2>
<p>如果你知道 SSR 和 React，你已经知道做一些基本的 SSG 所需要的一切。在其核心，我们使用来自<code>react-dom/server</code>的<code>renderToString</code>函数，而不是来自<code>react-dom</code>的<code>render</code>。假设我们有一个嵌套在布局中的页面，下面的代码可能已经工作了:</p>
<pre>const element = (
  &lt;MemoryRouter&gt;
    &lt;Layout&gt;
       &lt;Page /&gt;
    &lt;/Layout&gt;
  &lt;/MemoryRouter&gt;
);
const content = renderToString(element);
</pre>
<p>在上面的代码片段中，我们假设布局完全由一个<code>Layout</code>组件给出。我们还假设 React 路由器用于客户端路由。因此，我们需要提供适当的路由上下文。幸运的是，我们是使用<code>HashRouter</code>、<code>BrowserRouter</code>还是<code>MemoryRouter</code>并不重要，它们都提供了路由上下文。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>现在，什么是<code>Page</code>？<code>Page</code>指实际显示待预渲染页面的组件。你可能有更多的组件，你想把每一页。一个很好的例子是一个<code>ScrollToTop</code>组件，它通常是这样集成的:</p>
<pre>&lt;Route component={ScrollToTop} /&gt;
</pre>
<p>但是，当我们的静态页面变成动态页面时，我们将把这个组件留给水合作用。不需要预先渲染这个。</p>
<p>否则，应用程序本身通常类似于:</p>
<pre>const app = (
  &lt;BrowserRouter&gt;
    &lt;Route component={ScrollToTop} /&gt;
    &lt;Layout&gt;
      &lt;Switch&gt;
        {pages
          .map(page =&gt; (
            &lt;Route exact key={page.route} path={page.route} component={page.content} /&gt;
          ))}
        &lt;Route component={NotFound} /&gt;
      &lt;/Switch&gt;
    &lt;/Layout&gt;
  &lt;/BrowserRouter&gt;
);

hydrate(app, document.querySelector('#app'));
</pre>
<p>这非常接近静态生成的代码片段。主要区别在于，这里我们包括所有页面(和水合物)，而在上面的 SSG 场景中，我们将整个页面内容缩减为一个固定的单个页面。</p>
<h2>SSG 的陷阱</h2>
<p>到目前为止，一切听起来简单明了，对吗？但是问题隐藏在引擎盖下。</p>
<h3>资产支持</h3>
<p>我们如何引用资产？假设我们使用如下代码:</p>
<pre>&lt;img src="/foo.png" /&gt;
</pre>
<p>鉴于<code>foo.png</code>存在于我们的服务器上，这可能行得通。使用完整的 URL 会更可靠一点，例如<code><a href="http://example.com/foo.png" rel="nofollow">http://example.com/foo.png</a></code>。然而，我们会放弃一些关于环境的灵活性。</p>
<p>很多时候，我们会把这些资产留给像 webpack 这样的捆绑商。在这种情况下，我们会有这样的代码:</p>
<pre>&lt;img src={require('../assets/foo.png')} /&gt;
</pre>
<p>在这里，<code>foo.png</code>在构建时被本地解析，然后被散列、优化并复制到目标目录。这一切都很好。然而，对于上述过程，只需要 Node.js 中的模块是不行的。我们将遇到一个异常，即<code>foo.png</code>不是一个有效的模块。</p>
<p>解决这个其实并不复杂。幸运的是，我们可以为 Node.js 中的模块注册额外的扩展:</p>
<pre>['.png', '.svg', '.jpg', '.jpeg', '.mp4', '.mp3', '.woff', '.tiff', '.tif', '.xml'].forEach(extension =&gt; {
  require.extensions[extension] = (module, file) =&gt; {
    module.exports = '/' + basename(file);
  };
});
</pre>
<p>上面的代码假设文件已经/将要被复制到根目录。因此，我们将把<code>require('../assets/foo.png')</code>转换成<code>"foo.png"</code>。</p>
<p>哈希部分呢？如果我们已经有了一个资产文件列表和它们的散列，我们可以使用这样的代码:</p>
<pre>const parts = basename(file).split('.');
const ext = parts.pop();
const front = parts.join('.');
const ref = files.filter(m =&gt; m.startsWith(front) &amp;&amp; m.endsWith(ext)).pop() || '';
module.exports = '/' + ref;
</pre>
<p>这将试图找到一个以“foo”开头、以“png”结尾的文件，比如<code>foo.23fa6b.png</code>。如上休息。</p>
<h3>支持类型脚本</h3>
<p>既然我们知道了如何处理通用资产，我们也可以为<code>.ts</code>和<code>.tsx</code>文件提供一个处理机制。毕竟，这些也可以在内存中传输到 JS。然而，所有这些工作都是不必要的，因为<code>ts-node</code>已经这么做了。所以我们的工作本质上归结为:</p>
<pre>npm i ts-node --save-dev
</pre>
<p>然后使用以下命令为各自的文件扩展名注册处理程序:</p>
<pre>require('ts-node').register({
  compilerOptions: {
    module: 'commonjs',
    target: 'es6',
    jsx: 'react',
    importHelpers: true,
    moduleResolution: 'node',
  },
  transpileOnly: true,
});
</pre>
<p>现在，这允许只需要定义为<code>.tsx</code>文件的模块。</p>
<h3>惰性装载</h3>
<p>如果我们已经编写了一个优化的 React SPA，那么我们还将在路由级别捆绑拆分我们的应用程序。这意味着每个页面都有自己的子包。因此，将有一个核心/公共包(通常包含路由机制、React 本身、一些共享依赖项等。)和每页一个包。如果我们有 10 页，我们最终会有 11(或更多)个包。</p>
<p>但是使用预渲染方法，这并不理想。毕竟，我们已经在预渲染单个页面了。如果我们在一个页面上有一个共享的子组件(例如，一个地图控件),但是它太大了，我们想把它放入自己的包中，那该怎么办？</p>
<p>也就是说，我们有这样一个组件:</p>
<pre>const ActualMap = React.lazy(() =&gt; import('./actual-map'));

const Map = (props) =&gt; (
  &lt;React.Suspense fallback={&lt;div&gt;Loading Map ...&lt;/div&gt;}&gt;
     &lt;ActualMap {...props} /&gt;
  &lt;/React.Suspense&gt;
);
</pre>
<p>其中实际的组件将被延迟加载。在这种情况下，我们会撞上一堵相当大的墙。React 不知道如何预渲染<code>lazy</code>。</p>
<p>幸运的是，我们可以重新定义<code>lazy</code>,只显示一些占位符(我们也可以在这里疯狂地加载或预呈现内容，但让我们保持简单，并假设这里被延迟加载的内容实际上应该在以后被延迟加载):</p>
<pre>React.lazy = () =&gt; () =&gt; React.createElement('div', undefined, 'Loading ...');
</pre>
<p>在<code>renderToString</code>中不可用的另一部分是<code>Suspense</code>。好吧，老实说，实现这一点不会有什么坏处，但是让我们自己来做吧。</p>
<p>我们在这里所要做的就是假装<code>Suspense</code>根本不存在。所以我们只是使用提供的<code>children</code>用一个片段替换它。</p>
<pre>React.Suspense = ({ children }) =&gt; React.createElement(React.Fragment, undefined, children);
</pre>
<p>现在，我们非常有效地处理了延迟加载，尽管根据场景，我们可以(甚至可能想要)做得更多。</p>
<h3>其他事情</h3>
<p>除了像<code>lazy</code>和<code>Suspense</code>这样的东西，React 中可能还缺少其他部分。一个很好的例子是<code>useLayoutEffect</code>。然而，由于<code>useLayoutEffect</code>通常只在运行时应用，支持它的简单方法就是完全避免它。</p>
<p>一个非常简单的实现是用一个无操作函数来代替它。这种方式，<code>useLayoutEffect</code>不符合我们的方式，被简单地忽略:</p>
<pre>React.useLayoutEffect = () =&gt; {};
</pre>
<p>我们<code>require</code>的一些模块实际上不会是 CommonJS 格式的。这是个大问题。在撰写本文时，Node.js 仅支持 CommonJS 模块(<a href="https://blog.logrocket.com/es-modules-in-node-today/"> ES 模块仍处于实验阶段</a>)。</p>
<p>幸运的是，有<a href="https://github.com/standard-things/esm#readme"> esm 包</a>，它使用<code>import ...</code>和<code>export ...</code>语句为我们提供了对 es 模块的支持。太好了！</p>
<p>和<code>ts-node</code>一样，我们从安装依赖项开始:</p>
<pre>npm i esm --save-dev
</pre>
<p>然后实际使用它。在这种情况下，我们需要用它的新版本替换“正常的”<code>require</code>。代码如下:</p>
<pre>require = require('esm')(module);
</pre>
<p>现在我们也支持 ES 模块。唯一缺少的可能是一些与 DOM 相关的功能。</p>
<p>虽然大多数情况下我们应该像这样在代码中放置条件:</p>
<pre>if (typeof window !== 'undefined') {
  // ...
}
</pre>
<p>我们也可以伪造一些其他的全局变量。例如，我们(或我们直接或间接使用的一些依赖关系)可能指<code>XMLHttpRequest</code>、<code>XDomainRequest</code>或<code>localStorage</code>。在这些情况下，我们可以通过扩展<code>global</code>对象来模拟它们。</p>
<p>按照同样的逻辑，我们可能会嘲笑<code>document</code>，或者至少是它的一部分。当然，还有<code>jsdom</code>包，<a href="https://github.com/jsdom/jsdom">已经帮助他们完成了大部分</a>。但是现在让我们简单明了。<br/>只是一个嘲讽的例子:</p>
<pre>global.XMLHttpRequest = class {};
global.XDomainRequest = class {};
global.localStorage = {
  getItem() {
    return undefined;
  },
  setItem() {},
};
global.document = {
  title: 'sample',
  querySelector() {
    return {
      getAttribute() {
        return '';
      },
    };
  },
};
</pre>
<p>现在，我们已经做好了一切准备，可以毫不费力地开始预渲染我们的应用程序了。</p>
<h2>将这一切结合在一起</h2>
<p>我们有很多方法可以概括和使用上面的片段。就我个人而言，我喜欢在一个单独的模块中使用它们，该模块使用<code>fork</code>对每页进行评估/使用。这样，我们总是得到隔离的进程，也可以并行化。</p>
<p>下面显示了一个示例实现:</p>
<pre>const path = require('path');
const { readFileSync, readdirSync } = require('fs');
const { fork } = require('child_process');
const { getPages } = require('./files');

function generatePage(page, files, html, dist) {
  const modPath = path.resolve(__dirname, 'ssg-kernel.js');

  console.log(`Processing page "${page.name}" ...`);

  return new Promise((resolve, reject) =&gt; {
    const ps = fork(modPath, [], {
      cwd: process.cwd(),
      stdio: 'ignore',
      detached: true,
    });

    ps.on('message', () =&gt; {
      console.log(`Finished processing page "${page.name}".`);
      resolve();
    });

    ps.on('error', () =&gt; reject(`Failed to process page "${page.name}".`));

    ps.send({
      source: page.path,
      target: page.route,
      files,
      html,
      dist,
    });
  });
}

function generatePages() {
  const dist = path.resolve(__dirname, 'dist');
  const index = path.resolve(dist, 'index.html');
  const files = readdirSync(dist);
  const html = readFileSync(index, 'utf8');
  const baseDir = path.resolve(__dirname, '..');
  const pages = getPages();
  return Promise.all(pages.map(page =&gt; generatePage(page, files, html, dist)));
}

if (require.main === module) {
  generatePages()
    .then(
      () =&gt; 0,
      () =&gt; 1,
    )
    .then(process.exit);
} else {
  module.exports = {
    generatePage,
    generatePages,
  };
}
</pre>
<p>这个实现可以作为 lib 使用，也可以直接通过<code>node</code>使用。这就是为什么我们使用<code>require.main</code>作为鉴别器来区分这两种情况。在 lib 的情况下，我们导出两个函数<code>generatePages</code>和<code>generatePage</code>。</p>
<p>这里唯一剩下的就是<code>getPages</code>的定义。为此，我们可以只使用我们在关于基本 React 应用程序的介绍部分中指定的定义。</p>
<p><code>ssg-kernel.js</code>模块将包含上面的代码。包装在适当的信封中，以便在分叉过程中使用，我们最终得到:</p>
<pre>// ...

process.on('message', msg =&gt; {
  const { source, target, files, html, dist } = msg;
  setupExtensions(files);

  setTimeout(() =&gt; {
    const { content, outPath } = renderApp(source, target, dist);
    makePage(outPath, html, content);

    process.send({
      content,
    });
  }, 100);
});
</pre>
<p>其中<code>setupExtensions</code>将为<code>require</code>设置必要的修改，而<code>renderApp</code>则执行实际的标记生成。<code>makePage</code>使用<code>renderApp</code>的输出实际写出生成的页面。</p>
<p>使用这样的设置，我们可以预渲染我们的网站并获得显著的性能提升，正如 Lighthouse 所证实的:</p>
<p><img data-attachment-id="33166" data-permalink="https://blog.logrocket.com/static-site-generation-with-react-from-scratch/prerendered-lighthouse-performance-boost/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost.png" data-orig-size="600,169" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Prerendered-Lighthouse-Performance-Boost" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost-300x85.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost.png" decoding="async" class="aligncenter wp-image-33166 size-full jetpack-lazy-image" src="../Images/0a786235a552a46eb1dd1c6578d724f3.png" alt="React SSR After" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost.png 600w, https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost-300x85.png 300w" data-lazy-sizes="(max-width: 600px) 100vw, 600px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="33166" data-permalink="https://blog.logrocket.com/static-site-generation-with-react-from-scratch/prerendered-lighthouse-performance-boost/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost.png" data-orig-size="600,169" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Prerendered-Lighthouse-Performance-Boost" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost-300x85.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost.png" decoding="async" loading="lazy" class="aligncenter wp-image-33166 size-full" src="../Images/0a786235a552a46eb1dd1c6578d724f3.png" alt="React SSR After" srcset="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost.png 600w, https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost-300x85.png 300w" sizes="(max-width: 600px) 100vw, 600px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/Prerendered-Lighthouse-Performance-Boost.png"/></noscript>
<p>作为一个很好的副作用，我们自己的网站现在在某种程度上也适用于没有 JavaScript 的用户。完整的示例应用程序<a href="https://github.com/FlorianRappl/react-prerender-demo">可以在 GitHub </a>上找到。</p>
<h2>结论</h2>
<p>使用 React 创建优秀的静态页面实际上没什么大不了的。没有必要退回到臃肿复杂的框架。这样，我们可以很好地控制什么进入，什么需要留在外面。</p>
<p>此外，我们还了解了 Node.js、React 的内部结构，以及我们使用的一些依赖关系。了解我们实际使用的东西不仅仅是一个学术练习，而是在出现错误或其他问题时至关重要。</p>
<p>使用这种技术预渲染 SPA 的性能增益会很好。更重要的是，我们的页面变得更容易访问，并且在 SEO 中排名更高。</p>
<p>你在哪里看到预渲染发光？这仅仅是一个无意义的练习吗，或者 React 也可以是一个很好的开发模型来编写没有交互性的可重用组件吗？</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
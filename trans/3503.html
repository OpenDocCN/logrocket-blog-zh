<html>
<head>
<title>Improve Node.js app performance with TypeDI and the strategy pattern </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用TypeDI和策略模式提高Node.js应用程序的性能</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/improve-node-js-app-performance-typedi-strategy-pattern/#0001-01-01">https://blog.logrocket.com/improve-node-js-app-performance-typedi-strategy-pattern/#0001-01-01</a></blockquote><div><article class="article-post">
<p>保持应用程序的高性能对于有效的运营目标至关重要。缓存和内存化有助于避免冗余计算，保持应用程序平稳运行。以云为中心的架构模式强调容错，并将状态存储在分布式缓存服务中，如Redis和Memcached。</p>
<p>本教程将研究如何使用<a href="https://docs.typestack.community/typedi/v/develop/01-getting-started"> TypeDI </a>和策略模式来提高Node.js应用程序的性能。更具体地说，我们将构建一个API服务来支持Redis和Memcached之间的切换，并使用策略模式来保持服务提供者设计的灵活性。我们还将使用依赖注入，并依赖TypeDI包来提供控制反转(IoC)容器。你可以在<a href="https://github.com/creatrixity/simple-wallet"> GitHub库</a>中阅读完整的代码。</p>
<p><em>向前跳转:</em></p>

<h2 id="what-strategy-pattern">什么是策略模式？</h2>
<p>策略模式是一种<a href="https://blog.logrocket.com/understanding-design-patterns-typescript-node-js/">软件设计模式</a>，它将相关的实现(策略)组合在一起，并允许其他模块使用一个名为<code>Context</code>的中心类进行交互。使用这种模式，我们可以在一个应用程序中支持多个支付和消息提供者。</p>
<h2 id="dependency-injection-loose-coupling">依赖注入和松散耦合</h2>
<p><a href="https://blog.logrocket.com/dependency-injection-node-js-typedi/">依赖注入</a>是一种软件设计模式，它使一个方法能够接收一个依赖作为参数。依赖注入对于避免紧密耦合的软件设计是至关重要的，并帮助您在设计软件时避免糟糕的架构决策。</p>
<h2 id="why-use-typedi-dependency-injection-container-node-js">为什么要在Node.js中使用TypeDI作为依赖注入容器？</h2>
<p>正确的IoC需要依赖关系解析。依赖性解析过程将依赖性建模为具有节点和连接边的图。获得这种权利以防止无意中引入循环依赖是至关重要的。</p>
<p>TypeDI是正确执行依赖关系解析过程的优秀工具，它允许我们通过构造函数将值注入到类属性中。TypeDI使我们能够定义不变的<a href="https://blog.logrocket.com/youre-wrong-about-singletons/">单体服务</a>和瞬态服务，这在构建利用请求-响应模型的软件时很有帮助。</p>
<h2 id="creating-proof-concept-api-typedi-strategy-pattern">使用TypeDI和策略模式创建概念验证API</h2>
<p>在本文中，我们将创建一个基于Express.js的Node.js应用程序来存储和读取交易记录，类似于财务应用程序中的记录。</p>
<p>我们将从高性能缓存中读写事务记录，这些缓存使用机器上可用的RAM，而不是读取磁盘数据时通常遇到的缓慢且不确定的顺序I/O。</p>
<p>为了允许环境变量的覆盖，我们将默认缓存提供者设置为<code>Redis</code>，并支持<code>Redis</code>和<code>Memcached</code>作为我们的高性能缓存。</p>
<h3 id="set-up-installation">设置和安装</h3>
<p>我们的应用程序具有以下外部依赖性:</p>

<p>我更喜欢将Memcached和Redis作为Docker容器运行。要将它们直接安装在您的计算机上，请执行以下命令:</p>
<pre class="language-bash hljs">mkdir simple-wallet
cd simple-wallet
npm init -y
npm i typescript concurrently @types/dotenv @types/memcached @types/express @types/node nodemon --save-dev
npm i redis memcached memcache-plus typedi express body-parser dotenv --save
</pre>
<p>接下来，我们需要在我们的工作目录中启动一个<a href="https://blog.logrocket.com/tag/typescript/">类型脚本项目</a>。如果您已经全局安装了TypeScript，请运行以下命令:</p>
<pre class="language-bash hljs">tsc --init
</pre>
<p>如果您希望将TypeScript保留为本地安装，请运行以下命令:</p>
<pre class="language-bash hljs">./node_modules/.bin/tsc --init
</pre>
<p>然后，编辑<code>tsconfig.json</code>并允许诸如装饰器和发出装饰器元数据之类的类型脚本特性:</p>
<pre class="language-json hljs">{
  "compilerOptions": {
    "outDir": "./dist",
    "baseUrl": "./",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "skipLibCheck": true,
    "strict": true,
    "esModuleInterop": true,
    "strictPropertyInitialization": true
  }
}
</pre>
<p>现在，我们将为<code>Redis</code>和<code>Memcached</code>设置Docker容器。我更喜欢使用下面最小的<code>alpine</code>图片:</p>
<pre class="language-bash hljs"># We need to create an isolated bridge network to allow us to connect to our instances 
docker create network simple-wallet-network --driver bridge
docker pull redis:alpine memcached:alpine
docker run --name simple-wallet-redis -d -p 6379:6379 redis:alpine
docker run --name simple-wallet-memcached -d -p 11211:11211 memcached:alpine
</pre>
<p><img decoding="async" class="aligncenter size-full wp-image-138197 jetpack-lazy-image" src="../Images/29e3009d803fb0cd94a8a412582dded4.png" alt="Injectable Docker Node.js Caching Example" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/cached-injectable-node-js-example.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/cached-injectable-node-js-example.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter size-full wp-image-138197" src="../Images/29e3009d803fb0cd94a8a412582dded4.png" alt="Injectable Docker Node.js Caching Example" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/cached-injectable-node-js-example.png"/></noscript>
<p>运行我们的<code>Redis</code>和<code>Memcached</code>实例，用下面的代码连接它们:</p>
<pre class="language-bash hljs">npx redis-cli -p 6379
npx memcached-cli localhost:11211
</pre>
<p>然后，添加一个<code>declarations.d.ts</code>文件来声明第三方包的类型，并将以下内容输入到<code>.env</code>:</p>
<pre>PORT=3050
CACHE_PROVIDER=redis
REDIS_PORT=6379
MEMCACHED_PORT=11211
</pre>
<h3 id="configuring-application">配置Express.js应用程序</h3>
<p>我们需要创建一个<code>config singleton</code>对象来导出在其他模块中使用的值。创建<code>src/config.ts</code>并粘贴以下代码:</p>
<pre class="language-typescript hljs">import dotenv from "dotenv";
dotenv.config();

function getEnvVariable(name: string, fallback: string = ""): string {
  const envVariable = process.env[name];
  const fallbackProvided = fallback.length;
  if (!envVariable &amp;&amp; !fallbackProvided) {
    throw new Error(`Environment variable ${name} has not been set.`);
  }
  return envVariable || fallback;
}

const config = {
  server: {
    port: getEnvVariable("PORT"),
  },
  cache: {
    provider: getEnvVariable("CACHE_PROVIDER", "redis"),
  },
  redis: {
    port: getEnvVariable("REDIS_PORT"),
  },
  memcached: {
    port: getEnvVariable("MEMCACHED_PORT"),
  },
};

export default config;
</pre>
<p>然后，我们需要在应用程序启动时建立到Redis和Memcached服务的持久TCP连接，并将这些连接公开给应用程序的其余部分。</p>
<p>我们将使用<code>memcache-plus</code>作为基本<code>memcache</code>包的包装器，因为<code>memcache-plus</code>为我们提供了语法糖，比如async/await，而不是回调。将这些添加到<code>src/connections</code>:</p>
<pre class="language-typescript hljs">import MemcachePlus from "memcache-plus";
import { createClient } from "redis";
import { RedisClientType } from "@redis/client";

let redisClient;

// The Redis client must be created in an async closure
(async () =&gt; {
  redisClient = createClient();
  redisClient.on("error", (err) =&gt;
    console.log("🐕‍🦺[Redis] Redis Client Error: ", err)
  );
  await redisClient.connect();
  console.log("🐕‍🦺[Redis]: Successfully connected to the Redis server");
})();

const createMemcachedClient = (location: string) =&gt; {
  const handleNetworkError = function () {
    console.error(
      `🎖️[Memcached]: Unable to connect to server due to network error`
    );
  };
  const memcache = new MemcachePlus({
    hosts: [location],
    onNetError: handleNetworkError,
  });
  console.log("🎖️[Memcached]: Successfully connected to the Memcached server");
  return memcache;
};

export default {
  redis: redisClient,
  memcached: createMemcachedClient("localhost:11211"),
};
</pre>
<h3 id="boostrapping-application">引导我们的应用程序</h3>
<p>接下来，我们将在<code>src/index.ts</code>中引导我们的Express应用程序。因为<code>TypeDI</code>使用实验性的类型脚本<code>Reflection</code> API，我们将首先导入<code>reflect-metadata</code>。为此，将下面的代码添加到<code>src/index.ts</code>:</p>
<pre class="language-typescript hljs">import "reflect-metadata";
import express, { Express, Request, Response } from "express";
import config from "./config";
import transactionsRouter from "./modules/transaction/transaction.routes";
import bodyParser from "body-parser";

const app: Express = express();
const { server } = config;

app.use(bodyParser.json());
app.use("/transactions", transactionsRouter);

app.get("/", (_req: Request, res: Response) =&gt; {
  res.send("Hello! Welcome to the simple wallet app");
});

app.listen(server.port, () =&gt; {
  console.log(`☁️ Server is running at http://localhost:${server.port}`);
});
</pre>
<p>完成引导后，我们需要设置事务模块。在这样做之前，我们必须为缓存构建一个抽象，将缓存提供者定义为在两者之间切换的策略。</p>
<h3 id="building-cache-provider">构建缓存提供程序</h3>
<p>要构建缓存提供者，将第一个类定义为<code>Context</code>。您可以将<code>Context</code>视为缓存提供者的大脑，当使用策略模式时，它识别所有可用的策略，并为消费者提供在它们之间切换的方法。</p>
<p>我们将在<code>src/providers/cache/cache.definitions.ts</code>定义缓存提供者中使用的<code>Strategy</code>类接口和类型:</p>
<pre class="language-typescript hljs">export interface Strategy {
  get(key: string): Promise&lt;string&gt;;
  has(key: string): Promise&lt;boolean&gt;;
  set(key: string, value: string): void;
}

export type strategiesList = {
  [key: string]: Strategy;
};
</pre>
<p>接下来，我们需要定义一个可供<code>Context</code>选择的策略列表，我们将为<code>Redis</code>和<code>Memcached</code>策略创建具体的实现类。</p>
<p>编辑<code>src/providers/cache/cache.context.ts</code>并添加:</p>
<pre class="language-typescript hljs">import { Service } from "typedi";
import connections from "../../connections";
import config from "../../config";
import { Strategy, strategiesList } from "./cache.definitions";
import RedisStrategy from "./strategies/redis.strategy";
import MemcachedStrategy from "./strategies/memcached.strategy";
import { RedisClientType } from "@redis/client";
</pre>
<p>我们的策略类实现将接收一个连接实例，以使我们的策略尽可能灵活:</p>
<pre class="language-typescript hljs">const strategies: strategiesList = {
  redis: new RedisStrategy(connections.redis as RedisClientType),
  memcached: new MemcachedStrategy(connections.memcached),
};
</pre>
<p>在<code>CacheContext</code>中，将环境中默认的缓存提供者值注入到构造函数中，并执行方法委托或代理。</p>
<p>尽管我们手动委托给所选的策略类，但这也可以通过使用<a href="https://blog.logrocket.com/use-es6-proxies-to-enhance-your-objects/"> ES6代理</a>来动态实现。我们将剩余的<code>CacheContext</code>添加到下面的块中:</p>
<pre class="language-typescript hljs">@Service()
class CacheContext {
  private selectedStrategy: Strategy;
  private strategyKey: keyof strategiesList;

  constructor(strategyKey: keyof strategiesList = config.cache.provider) {
    this.strategyKey = strategyKey;
    this.selectedStrategy = strategies[strategyKey];
  }

  public setSelectedStrategy(strategy: keyof strategiesList) {
    this.selectedStrategy = strategies[strategy];
  }

  public async has(key: string) {
    const hasKey = await this.selectedStrategy.has(key);
    return hasKey
  }

  public async get(key: string) {
    console.log(`Request for cache key: ${key} was served by ${this.strategyKey}`);
    const value = await this.selectedStrategy.get(key);
    return value;
  }

  public async set(key: string, value: string) {
    await this.selectedStrategy.set(key, value);
  }
}

export default CacheContext;
</pre>
<p>接下来，我们将通过向<code>src/providers/cache/strategies/redis.strategy.ts</code>添加下面的代码来创建<code>RedisStrategy</code>的最小实现:</p>
<pre class="language-typescript hljs">import { RedisClientType } from "@redis/client";
import { Strategy } from "../cache.definitions";

class RedisStrategy implements Strategy {
  private connection;

  constructor(connection: RedisClientType) {
    this.connection = connection;
  }

  public async get(key: string): Promise&lt;string | null&gt; {
    const result = await this.connection.get(key);
    return result;
  }

  public async has(key: string): Promise&lt;boolean&gt; {
    const result = await this.connection.get(key);
    return result !== undefined &amp;&amp; result !== null;
  }

  public async set(key: string, value: string) {
    await this.connection.set(key, value);
  }
}

export default RedisStrategy;
</pre>
<p>因为<code>MemcachedStrategy</code>类似于<code>RedisStrategy</code>，我们将跳过它的实现。如需查看<code>MemcachedStrategy</code>，可点击查看实施<a href="https://github.com/creatrixity/simple-wallet">。</a></p>
<h3 id="setting-up-transaction-module">使用TypeDI设置事务模块</h3>
<p>需要公开API端点来保存和检索事务。为此，从TypeDI导入<code>TransactionController</code>和<code>Container</code>。</p>
<p>因为我们是在<code>TransactionController</code>内部动态注入<code>TransactionService</code>，所以我们必须从TypeDI容器中获取一个<code>TransactionController</code>实例。</p>
<p>创建<code>src/modules/transactions/transaction.routes.ts</code>并添加以下代码:</p>
<pre class="language-typescript hljs">import { Request, Response, NextFunction, Router } from "express";
import Container from "typedi";
import TransactionController from "./transaction.controller";

const transactionsRouter = Router();
const transactionController = Container.get(TransactionController);

transactionsRouter.post(
  "/",
  (req: Request, res: Response, next: NextFunction) =&gt;
    transactionController.saveTransaction(req, res, next)
);

transactionsRouter.get("/", (req: Request, res: Response, next: NextFunction) =&gt;
  transactionController.getRecentTransactions(req, res, next)
);

export default transactionsRouter;
</pre>
<p>接下来，我们要定义<code>TransactionController</code>。当我们将<code>TransactionService</code>注入到构造函数中时，依赖关系会自动解决。为了实现这一点，我们必须用<code>Service</code>装饰器将该类注释为一个<code>typedi</code>服务。</p>
<p>创建<code>src/modules/transactions/transaction.service.ts</code>并添加以下代码:</p>
<pre class="language-typescript hljs">import { NextFunction, Request, Response } from "express";
import { Service } from "typedi";
import TransactionService from "./transaction.service";

@Service()
class TransactionController {
  constructor(private readonly transactionService: TransactionService) {}

  async getRecentTransactions(
    _req: Request,
    res: Response,
    next: NextFunction
  ) {
    try {
      const results = await this.transactionService.getTransactions();
      return res
        .status(200)
        .json({ message: `Found ${results.length} transaction(s)`, results });
    } catch (e) {
      next(e);
    }
  }

  async saveTransaction(req: Request, res: Response, next: NextFunction) {
    try {
      const transaction = req.body;
      await this.transactionService.saveTransaction(transaction);
      return res.send("Transaction was saved successfully");
    } catch (e) {
      next(e);
    }
  }
}

export default TransactionController;
</pre>
<p>最后，我们需要创建<code>TransactionService</code>并注入<code>CacheProvider</code>。</p>
<p>然后，在<code>saveTransaction</code>方法中，从缓存中反序列化任何现有的事务记录，更新事务列表，并序列化更新后的列表。</p>
<p>创建<code>/src/modules/transaction/transaction.service.ts</code>并添加以下代码:</p>
<pre class="language-typescript hljs">import { Service } from "typedi";
import CacheProvider from "../../providers/cache";
import Transaction from "./transaction.model";

@Service()
class TransactionService {
  constructor(private readonly cacheProvider: CacheProvider) {}

  async saveTransaction(transaction: Transaction[]) {
    let cachedTransactions = await this.cacheProvider.get("transactions");
    let updatedTransactions: Transaction[] = [];

    if (cachedTransactions &amp;&amp; cachedTransactions.length &gt; 0) {
      updatedTransactions = [...JSON.parse(cachedTransactions), transaction];
    }

    await this.cacheProvider.set(
      "transactions",
      JSON.stringify(updatedTransactions)
    );
  }

  async getTransactions(): Promise&lt;Transaction[]&gt; {
    const cachedTransactions = await this.cacheProvider.get("transactions");
    if (!cachedTransactions) return [];
    return JSON.parse(cachedTransactions);
  }
</pre>
<h3 id="manually-testing-application">手动测试应用程序</h3>
<p>现在，我们准备好手动测试应用程序了。继续启动终端，用<code>curl</code>执行一些HTTP请求:</p>
<pre class="language-bash hljs">curl -X "POST" --data '{"amount":10,"recipient":"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="31535e53715449505c415d541f525e5c">[email protected]</a>","sender":"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0e6f62676d6b4e6b766f637e626b206d6163">[email protected]</a>"}' http://localhost:3050/transactions
</pre>
<p>然后，添加第二个事务:</p>
<pre class="language-bash hljs">curl -X "POST" --data '{"amount":499,"recipient":"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="22564d4c5b62475a434f524e470c414d4f">[email protected]</a>","sender":"<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="57363b3e343217322f363a273b327934383a">[email protected]</a>"}' http://localhost:3050/transactions
</pre>
<p>如果我们在浏览器中访问<code>localhost:3050/transactions</code>，我们应该会看到下面的响应:</p>
<p><img decoding="async" class="aligncenter size-full wp-image-138199 jetpack-lazy-image" src="../Images/2521ddc9af90e90dae356f6b203fcb2d.png" alt="Final Product Using Node.js and the Strategy Pattern" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/node-js-injectable-caching-host-browser-response.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/node-js-injectable-caching-host-browser-response.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter size-full wp-image-138199" src="../Images/2521ddc9af90e90dae356f6b203fcb2d.png" alt="Final Product Using Node.js and the Strategy Pattern" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/node-js-injectable-caching-host-browser-response.png"/></noscript>
<h2>结论</h2>
<p>设计模式和策略模式一样，是解决需要多种实现的问题的便利工具。依赖注入是一种有价值的技术，有助于保持模块随时间推移的可维护性，具有回退功能的分布式缓存有助于提高构建云应用程序时的性能。</p>
<p>我强烈建议探索其他功能设计模式，如代理和适配器模式。请随意从这个教程中克隆这个项目，并尝试一下。</p><div class="code-block code-block-23">
<div class="blog-plug inline-plug node-plug"><h2>200只<img src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> <noscript> <img data-lazy-fallback="1" src="../Images/61167b9d027ca73ed5aaf59a9ec31267.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png"/> </noscript>显示器出现故障，生产中网络请求缓慢</h2><p>部署基于节点的web应用程序或网站是容易的部分。确保您的节点实例继续为您的应用程序提供资源是事情变得更加困难的地方。如果您对确保对后端或第三方服务的请求成功感兴趣，</p><a href="https://lp.logrocket.com/blg/node-signup" target="_blank">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer"><img src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/><noscript><img data-lazy-fallback="1" src="../Images/cae72fd2a54c5f02a6398c4867894844.png" alt="LogRocket Network Request Monitoring" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png"/></noscript></a><a href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用程序的DVR，记录下用户与你的应用程序交互时发生的一切。您可以汇总并报告有问题的网络请求，以快速了解根本原因，而不是猜测问题发生的原因。</p><p>LogRocket检测您的应用程序以记录基线性能计时，如页面加载时间、到达第一个字节的时间、慢速网络请求，还记录Redux、NgRx和Vuex操作/状态。</p><a class="signup" href="https://lp.logrocket.com/blg/node-signup" target="_blank" rel="noopener noreferrer">Start monitoring for free</a><p>. </p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
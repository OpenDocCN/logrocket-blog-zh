<html>
<head>
<title>Build a video upload and compression app with Multer and React Native </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用Multer和React Native构建视频上传和压缩应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/#0001-01-01">https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React Native是一个移动应用开发框架，允许开发人员在Android和iOS中构建原生渲染的应用。“一次编码，随处运行”的原则是框架的固有特性。React Native也与React有许多相似之处，因此使用React的开发人员可以快速掌握React Native。</p>
<p>除了所有这些伟大的特性，它都是在引擎盖下的JavaScript。JavaScript可用于在Node.js中编写后端代码。因此，JavaScript开发人员处于一个独特的位置，能够构建应用程序、web应用程序和服务器端代码。</p>
<p>在本指南中，我们将使用Multer构建一个全栈应用程序，用于在React Native to Firebase上上传视频，Multer是一个处理文件上传的Node.js中间件。</p>
<p>我们的最终产品将是这样的:</p>

<p>向前跳:</p>
<p>先决条件</p>

<h2 id="prerequisites">设置Firebase</h2>

<h2 id="setting-up-firebase">Firebase是谷歌支持的应用程序开发平台。它为构建和扩展应用程序提供了多种服务，包括实时数据库、认证和托管。</h2>
<p>我们教程的第一步是创建一个Firebase帐户，如果你还没有的话。完成后，点击<strong>创建项目</strong>按钮:</p>
<p><img data-attachment-id="160272" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/firebase-create-project-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project.png" data-orig-size="730,305" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Create a project in Firebase" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project-300x125.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project.png" decoding="async" class="aligncenter size-full wp-image-160272 jetpack-lazy-image" src="../Images/4a3c35bea9b649ea5f33cf5e334b6537.png" alt="Create A Project In Firebase " data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project-300x125.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project.png"/></p>
<p id="gdcalert3">给项目起一个名字，这个名字将在以后用来标识正在使用的存储桶。</p><noscript><img data-lazy-fallback="1" data-attachment-id="160272" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/firebase-create-project-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project.png" data-orig-size="730,305" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Create a project in Firebase" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project-300x125.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160272" src="../Images/4a3c35bea9b649ea5f33cf5e334b6537.png" alt="Create A Project In Firebase " srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project-300x125.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/firebase-create-project.png"/></noscript>
<p>一旦您创建了您的项目，您需要选择测试环境。请注意，在部署到生产环境时，您需要选择一个生产环境并限制对您的文件的访问。</p>
<p>在项目设置仪表板上，点击<strong>服务账户</strong>选项卡并生成私钥。将密钥保存到您的后端文件夹，命名为<code>serviceAccount.json</code>:</p>
<p><img data-attachment-id="160274" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/generating-private-keys-firebase/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase.png" data-orig-size="730,266" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Generating private keys in Firebase" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase-300x109.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase.png" decoding="async" class="aligncenter size-full wp-image-160274 jetpack-lazy-image" src="../Images/d7d341eb71ad5c05bf7fa1d103d476ff.png" alt="Generating Private Keys In Firebase" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase-300x109.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase.png"/></p>
<p>设置后端Node.js服务器</p><noscript><img data-lazy-fallback="1" data-attachment-id="160274" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/generating-private-keys-firebase/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase.png" data-orig-size="730,266" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Generating private keys in Firebase" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase-300x109.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160274" src="../Images/d7d341eb71ad5c05bf7fa1d103d476ff.png" alt="Generating Private Keys In Firebase" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase-300x109.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/generating-private-keys-firebase.png"/></noscript>
<h2 id="setting-up-backend-node-js-server">后端将保存与React Native接口的API逻辑。API将有两个端点；一个用于从Firebase检索所有视频文件，另一个用于将图像上传到Firebase。</h2>
<p>后端文件夹结构如下:</p>
<p><code>controllers</code>文件夹保存处理视频上传和检索的业务逻辑。<code>routes</code>文件夹指定了将流量导向右侧控制器的快速路由的结构。<code>package.json</code>将包含用于我们所有依赖项的版本，而<code>server.js</code>将是启动Express服务器和处理路由请求的入口点。最后，<code>serviceAccountKey.json</code>保存了我们之前下载的Firebase配置。</p>
<pre class="language-javascript hljs">project_folder
|__backend
   |__controllers
    | controllers.uploadController.js
   |__routes
      | routes.uploadRoute.js
   | package.json
   | server.js
   | serviceAccountKey.json</pre>
<p>后端所需的包有:</p>
<p>Cors:实现跨源资源共享的中间件</p>
<ul>
<li>Express:用于构建服务器端应用程序的web框架</li>
<li>Multer:处理用于文件上传的多部分/表单数据的中间件</li>
<li>Firebase-admin:从服务器端环境与Firebase服务交互</li>
<li>Nodemon:重启节点应用程序的实用程序</li>
<li>Fluent-ffmpeg:一个使用ffmpeg处理多媒体文件的库</li>
<li>在后端文件夹中，使用npm通过以下命令安装软件包:</li>
</ul>
<p>在<code>package.json</code>中，添加<code>“type” :”module”</code>字段。这使我们能够使用import语句来代替所需的语法。</p>
<pre class="language-bash hljs">npm install cors express multer firebase-admin nodemon fluent-ffmpeg</pre>
<p>接下来，将启动脚本命令改为使用nodemon来运行<code>server.js</code>。Nodemon监听所做的更改，并重新启动节点服务器。最终的<code>package.json</code>如下:</p>
<p>为上传创建API端点</p>
<pre class="language-json hljs">{
 "name": "backend",
 "version": "1.0.0",
 "description": "Backend for the react native app for uploading videos",
 "main": "server.js",
 "type": "module",
 "scripts": {
   "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
   "start": "nodemon server.js"
 },
 "author": "Wamaitha Nyamu",
 "license": "ISC",
 "dependencies": {
   "cors": "^2.8.5",
   "express": "^4.18.2",
   "firebase-admin": "^11.4.1",
   "fluent-ffmpeg": "^2.1.2",
   "multer": "^1.4.5-lts.1",
   "nodemon": "^2.0.20"

 }
}
</pre>
<h2 id="creating-api-endpoints-uploads">Server.js</h2>
<h3 id="server-js">Server.js将是后端的入口点。<code>server.js</code>文件有如下代码:</h3>
<p>在上面的代码中，我们导入相关的库，初始化一个Express app实例，并传递cors和express.json中间件。然后，我们将<code>uploadRoute</code>挂载到<code>/api/uploads</code>路由，并在端口3000上启动服务器。</p>
<pre class="language-javascript hljs">import express from 'express';
import cors from 'cors';
import uploadRoute from './routes/routes.uploadRoute.js';

const app = express();
app.use(cors())
app.use(express.json());
app.use('/api/uploads', uploadRoute)
app.listen(3000, () =&gt; {
   console.log('Server listening on port 3000...');
 });
</pre>
<p>路线</p>
<h3 id="routes">Server.js中的<code>uploadRoute</code>函数从<code>‘./routes/routes.uploadRoute.js</code>导入一个快速路由器，它有如下代码:</h3>
<p>上面的代码从<code>controllers/controllers.uploadAttachment.js</code>导入了Express和两个函数。然后我们定义两个端点路由，分别使用<code>uploadAttachment</code>和<code>getAllAttachments</code>函数发布和获取。然后两者都作为路由器导出。</p>
<pre class="language-javascript hljs">import express from 'express'
import {
   uploadAttachment,
   getAllAttachments
} from "../controllers/controllers.uploadController.js"
const router = express.Router()
router.route('/').post(uploadAttachment)
router.route('/').get(getAllAttachments)
export default router.
</pre>
<p>控制器</p>
<h3 id="controllers">在“controllers/controllers . upload attachment . js”中，我们首先导入相关模块:</h3>
<p>然后，我们定义了将被Multer用作文件过滤函数的<code>videoFilter</code>函数。该功能确保Multer只上传文件扩展名为. mp4，.avi和. mkv。任何其他文件扩展名都将引发错误:</p>
<pre class="language-javascript hljs">import multer from 'multer';
import firebase from 'firebase-admin';
import ffmpeg from 'fluent-ffmpeg';
import path from 'path';
import fs from 'fs';
</pre>
<p>接下来，我们定义一个助手函数<code>checkFileSize</code>，它接受一个视频<code>filePath</code>作为参数，并返回视频的字节大小。</p>
<pre class="language-javascript hljs">const videoFilter = (req, file, cb) =&gt; {
   // Accept video files only
   if (!file.originalname.match(/\.(mp4|avi|mkv)$/)) {
       return cb(new Error('Only video files are allowed!'), false);
   }
   cb(null, true);
};
</pre>
<p><code>fs</code>模块的<code>fs.statSync</code>方法用于为filePath指定的文件检索文件信息。文件大小存储在一个名为<code>fileSizeInBytes</code>的变量中，然后使用<code>console.log</code>方法记录到控制台。最后，该函数返回以字节为单位的文件大小:</p>
<p>然后，我们实例化<code>upload</code>，这创建了一个<code>multer</code>的实例。上传有两个参数:<code>fileFilter</code>和<code>storage</code>。<code>fileFilter</code>使用上一步定义的<code>videoFilter</code>功能。</p>
<pre class="language-javascript hljs">const checkFileSize = async (filePath) =&gt; {

   const stats = fs.statSync(filePath);
   const fileSizeInBytes = stats.size;
   console.log(`Video file size: ${fileSizeInBytes} bytes`);
   return fileSizeInBytes;
}
</pre>
<p><code>multer.memoryStorage()</code>创建Multer内置<code>memoryStorage</code>的新实例，它将上传的文件作为缓冲对象存储在内存中。该实例还指定Multer应该处理正在上传的单个文件，该文件在多格式数据中的字段名是<code>’files’</code>:</p>
<p>现在，我们想用两个配置选项初始化Firebase SDK。<code>credential</code>指定存储在我们之前保存的<code>serviceAccountKey.json</code>文件中的Firebase身份验证凭证。</p>
<pre class="language-javascript hljs">const upload = multer({
   fileFilter: videoFilter,
   storage: multer.memoryStorage(),
}).single('files');
</pre>
<p><code>storageBucket</code>指定用于存储上传文件的Firebase存储桶的名称。这是我们命名为<code>logrocket-uploads.appspot.com</code>的桶:</p>
<p>控制器逻辑将包含在两个函数中:<code>uploadAttachment</code>和<code>getAllAttachments</code>。<code>uploadAttachment</code>函数接受两个参数:<code>req</code>和<code>res,</code>，它们分别是表示HTTP请求和响应的对象:</p>
<pre class="language-javascript hljs">firebase.initializeApp({
   credential: firebase.credential.cert("./serviceAccountKey.json"),
   storageBucket: "logrocket-uploads.appspot.com"
});
</pre>
<p>上述函数利用Multer upload中间件来处理传入的文件，并将其作为缓冲区存储在内存中。上传时的错误会记录到控制台。成功上传后，缓冲区会以临时名称保存到文件系统上的一个文件中。</p>
<pre class="language-javascript hljs">export const uploadAttachment = async (req, res) =&gt; {
   try {
       upload(req, res, async function (err) {
           if (err) {
               console.error(err)
               res.status(403).send({
                   message: "Error uploading document. Make sure it is a video file."
               })
           } else {

               const inputBuffer = req.file.buffer;

               //save buffer to file
               const inputFileExtension = path.extname(req.file.originalname);
               const today = new Date();
               const dateTime = today.toLocaleString();
               const inputFile = `${dateTime}-input${inputFileExtension}`;



               console.log("Saving file to disk...", inputFile);

               fs.writeFileSync(inputFile, inputBuffer);
               console.log("File saved to disk.");

               console.log(`Checking input filesize in bytes`);
               await checkFileSize(inputFile);

               ffmpeg(inputFile)
                   .output(req.file.originalname)
                   .videoCodec("libx264")
                   .audioCodec('aac')
                   .videoBitrate(`1k`)
                   .autopad()
                   .on("end", async function () {
                       console.log("Video compression complete!");

                       const bucket = firebase.storage().bucket();
                       const newFile = bucket.file(req.file.originalname);
                       await newFile.save(`./${req.file.originalname}`);

                       console.log(`Checking output filesize in bytes`);
                       await checkFileSize(`./${req.file.originalname}`);

                       fs.unlinkSync(inputFile);
                       fs.unlinkSync(req.file.originalname)
                       res.json("Files uploaded successfully.");
                   })
                   .run();
           }
       })

   } catch (error) {
       console.log(error)
       res.status(500).send({
           message: "Something went wrong while uploading..."
       })
   }
}
</pre>
<p>接下来，该函数通过调用<code>checkFileSize</code>以字节为单位检查文件大小，它将临时文件路径作为参数，读取文件，并返回文件大小。然后，该函数使用ffmpeg库通过将比特率降低到1K来压缩视频文件。ffmpeg库有一个<code>end</code>事件，一旦压缩完成就会发出。</p>
<p>然后，压缩后的视频被上传到Firebase，并使用<code>unlinkSync</code>方法从系统中删除临时文件。在压缩前后，我们调用<code>checkFileSize</code>方法将视频比特率记录到控制台。</p>
<p>第二个控制器功能是<code>getAllAttachments</code>。此函数将检索Firebase存储器上保存的所有文件:</p>
<p><code>getAllAttachments</code>函数首先初始化Firebase存储桶，然后检索所有文件。这些文件以带有只读访问权限的签名URL的形式检索，到期日期为2024年1月1日。所有检索到的URL都存储在<code>fileList</code>数组中。</p>
<pre class="language-javascript hljs">export const getAllAttachments = async (req, res) =&gt; {
   try {
       const bucket = firebase.storage().bucket();
       const options = {
           action: 'read',
           expires: '01-01-2024'
       };
       const fileList = [];
       const [files] = await bucket.getFiles();
       for (const file of files) {
           const [url] = await file.getSignedUrl(options);
           fileList.push(url);
       }
       res.json(fileList);
   } catch (error) {
       console.log(error)
       res.status(500).send({
           message: "Something went wrong."
       })
   }
}
</pre>
<p><code>controller.uploadController.js</code>中的完整代码是:</p>
<p>使用邮递员测试</p>
<pre class="language-javascript hljs">import multer from 'multer';
import firebase from 'firebase-admin';
import ffmpeg from 'fluent-ffmpeg';
import path from 'path';
import fs from 'fs';

const videoFilter = (req, file, cb) =&gt; {
   // Accept video files only
   if (!file.originalname.match(/\.(mp4|avi|mkv)$/)) {
       return cb(new Error('Only video files are allowed!'), false);
   }
   cb(null, true);
};

const checkFileSize = async (filePath) =&gt; {

   const stats = fs.statSync(filePath);
   const fileSizeInBytes = stats.size;
   console.log(`Video file size: ${fileSizeInBytes} bytes`);
   return fileSizeInBytes;
}

const upload = multer({
   fileFilter: videoFilter,
   storage: multer.memoryStorage(),
}).single('files');

firebase.initializeApp({
   credential: firebase.credential.cert("./serviceAccountKey.json"),
   storageBucket: "logrocket-uploads.appspot.com"
});

export const uploadAttachment = async (req, res) =&gt; {
   try {
       upload(req, res, async function (err) {
           if (err) {
               console.error(err)
               res.status(403).send({
                   message: "Error uploading document. Make sure it is a video file."
               })
           } else {

               const inputBuffer = req.file.buffer;

               //save buffer to file
               const inputFileExtension = path.extname(req.file.originalname);
               const today = new Date();
               const dateTime = today.toLocaleString();
               const inputFile = `${dateTime}-input${inputFileExtension}`;
               console.log("Saving file to disk...", inputFile);

               fs.writeFileSync(inputFile, inputBuffer);
               console.log("File saved to disk.");

               console.log(`Checking input filesize in bytes`);
               await checkFileSize(inputFile);

               ffmpeg(inputFile)
                   .output(req.file.originalname)
                   .videoCodec("libx264")
                   .audioCodec('aac')
                   .videoBitrate(`1k`)
                   .autopad()
                   .on("end", async function () {
                       console.log("Video compression complete!");

                       const bucket = firebase.storage().bucket();
                       const newFile = bucket.file(req.file.originalname);
                       await newFile.save(`./${req.file.originalname}`);

                       console.log(`Checking output filesize in bytes`);
                       await checkFileSize(`./${req.file.originalname}`);

                       fs.unlinkSync(inputFile);
                       fs.unlinkSync(req.file.originalname)
                       res.json("Files uploaded successfully.");
                   })
                   .run();
           }
       })

   } catch (error) {
       console.log(error)
       res.status(500).send({
           message: "Something went wrong while uploading..."
       })
   }
}

export const getAllAttachments = async (req, res) =&gt; {
   try {
       const bucket = firebase.storage().bucket();
       const options = {
           action: 'read',
           expires: '01-01-2024'
       };
       const fileList = [];
       const [files] = await bucket.getFiles();
       for (const file of files) {
           const [url] = await file.getSignedUrl(options);
           fileList.push(url);
       }
       res.json(fileList);
   } catch (error) {
       console.log(error)
       res.status(500).send({
           message: "Something went wrong."
       })
   }
}
</pre>
<h2 id="testing-using-postman">在后端目录中使用<code>npm start</code>启动服务器。这将启动nodemon，如下所示:</h2>
<p><img data-attachment-id="160276" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/launching-nodemon-to-test-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server.png" data-orig-size="730,194" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Launching nodemon to test the server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server-300x80.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server.png" decoding="async" class="aligncenter size-full wp-image-160276 jetpack-lazy-image" src="../Images/8f1bdbe7a51cf94e73a117f9e0b31cf8.png" alt="Launching Nodemon To Test The Server" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server-300x80.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server.png"/></p>
<p>使用postman或您选择的另一个API测试工具(我在这里使用的是失眠症)，上传带有多部分表单数据选项的视频，如下所示。请记住以文件形式给出表单数据的值:</p><noscript><img data-lazy-fallback="1" data-attachment-id="160276" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/launching-nodemon-to-test-server/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server.png" data-orig-size="730,194" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Launching nodemon to test the server" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server-300x80.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160276" src="../Images/8f1bdbe7a51cf94e73a117f9e0b31cf8.png" alt="Launching Nodemon To Test The Server" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server-300x80.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/launching-nodemon-to-test-server.png"/></noscript>
<p><img data-attachment-id="160278" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/uploading-videos-using-insomnia/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia.png" data-orig-size="730,185" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Uploading videos using Insomnia" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia-300x76.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia.png" decoding="async" class="aligncenter size-full wp-image-160278 jetpack-lazy-image" src="../Images/cd61d986bae56466dca3b757451794ce.png" alt="Uploading Videos Using Insomnia" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia-300x76.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia.png"/></p>
<p id="gdcalert6">在终端上，您应该看到视频压缩日志:</p><noscript><img data-lazy-fallback="1" data-attachment-id="160278" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/uploading-videos-using-insomnia/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia.png" data-orig-size="730,185" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Uploading videos using Insomnia" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia-300x76.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160278" src="../Images/cd61d986bae56466dca3b757451794ce.png" alt="Uploading Videos Using Insomnia" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia-300x76.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/uploading-videos-using-insomnia.png"/></noscript>
<p><img data-attachment-id="160280" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/video-compression-log/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log.png" data-orig-size="730,281" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Video compression log" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log.png" decoding="async" class="aligncenter size-full wp-image-160280 jetpack-lazy-image" src="../Images/82727ed38b26c509c4347b6ebb0383d6.png" alt="Video Compression Log" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log-300x115.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log.png"/></p>
<p id="gdcalert7">我们可以从控制台日志中看到压缩后上传视频的字节大小减少了。</p><noscript><img data-lazy-fallback="1" data-attachment-id="160280" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/video-compression-log/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log.png" data-orig-size="730,281" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Video compression log" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log-300x115.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160280" src="../Images/82727ed38b26c509c4347b6ebb0383d6.png" alt="Video Compression Log" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log-300x115.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/video-compression-log.png"/></noscript>
<p>测试GET请求，它应该返回Firebase存储上的所有文件URL:</p>
<p><img data-attachment-id="160282" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/test-get-request/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request.png" data-orig-size="730,302" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Test the get request" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request-300x124.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request.png" decoding="async" class="aligncenter size-full wp-image-160282 jetpack-lazy-image" src="../Images/dff8005f19f382dd98157ed0bc182480.png" alt="Test The Get Request" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request-300x124.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request.png"/></p>
<p id="gdcalert8">ngrok</p><noscript><img data-lazy-fallback="1" data-attachment-id="160282" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/test-get-request/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request.png" data-orig-size="730,302" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Test the get request" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request-300x124.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160282" src="../Images/dff8005f19f382dd98157ed0bc182480.png" alt="Test The Get Request" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request-300x124.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/test-get-request.png"/></noscript>
<h2 id="ngrok">ngrok是一个创建到本地开发服务器的安全隧道的工具。这允许开发人员将本地web服务器、应用程序或服务公开给互联网，使其可被其他设备或客户端访问。</h2>
<p>ngrok生成一个可公开访问的URL，该URL映射到本地开发服务器端口。我们的应用程序将使用ngrok端点与端口3000上的后端进行交互。在您各自的操作系统上安装ngrok后，使用以下命令在新终端的端口3000上启动会话:</p>
<p>这将弹出如下所示的界面:</p>
<pre class="language-bash hljs">Ngrok http 3000</pre>
<p><img data-attachment-id="160284" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/ngrok-interface/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface.png" data-orig-size="730,234" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ngrok interface" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface-300x96.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface.png" decoding="async" class="aligncenter size-full wp-image-160284 jetpack-lazy-image" src="../Images/200c77522e36faf554b92ac059e10d5b.png" alt="Ngrok Interface" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface-300x96.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface.png"/></p>
<p id="gdcalert9">提供的URL将是我们在应用程序中使用的BASEURL。在生产环境中，您将在服务器上托管后端，并将一个域映射到后端服务。在postman上也可以使用相同的URL来测试ngrok隧道。</p><noscript><img data-lazy-fallback="1" data-attachment-id="160284" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/ngrok-interface/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface.png" data-orig-size="730,234" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ngrok interface" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface-300x96.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160284" src="../Images/200c77522e36faf554b92ac059e10d5b.png" alt="Ngrok Interface" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface-300x96.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/ngrok-interface.png"/></noscript>
<p>设置本地反应</p>
<h2 id="setting-up-react-native">现在，后端API正在运行，我们可以继续使用React Native构建前端应用程序。使用以下命令在新终端的项目根上启动React本地项目:</h2>
<p>上面的命令用本地iOS和Android样板创建了一个普通的React本地应用程序模板。项目根目录上更新的文件夹结构应该是:</p>
<pre class="language-bash hljs">npx react-native init frontend</pre>
<p>现在，切换到前端目录。在我们开始视频上传实现之前，您需要在您的笔记本电脑上设置您的开发服务器。React Native有一个<a href="https://reactnative.dev/docs/environment-setup">有用的指南</a>，告诉你如何设置开发服务器，以便在Android和iOS上开发React Native应用。我们开发的代码将适用于iOS和Android。</p>
<pre class="language-javascript hljs">Project_root
   |__backend
    …
   |__frontend</pre>
<p>我们将使用顺风进行造型。在React Native中，我们必须安装nativewind，这是一个使用Tailwind CSS创建通用样式系统的包，可以在任何平台上使用该应用程序。</p>
<p>使用以下命令安装Tailwind CSS和nativewind:</p>
<p>使用以下命令初始化Tailwind:</p>
<pre class="language-bash hljs">npm install tailwindcss nativewind</pre>
<p>这将在根文件夹中创建一个<code>tailwind.config.js</code>文件。编辑<code>tailwind.config.js</code>如下图所示:</p>
<pre class="language-bash hljs">npx tailwindcss init.</pre>
<p>将nativewind插件添加到<code>babel.config.js</code>:</p>
<pre class="language-javascript hljs">// tailwind.config.js

module.exports = {
- content: [],
+ content: ["./App.{js,jsx,ts,tsx}", "./Components/**/*.{js,jsx,ts,tsx}"],
theme: {
  extend: {},
},
plugins: [],
}</pre>
<p>然后，安装依赖项:</p>
<pre class="language-javascript hljs">module.exports = {
  presets: ['module:metro-react-native-babel-preset'],
  plugins: ["nativewind/babel"],
};</pre>
<p><code>react-native-document-picker</code>是一个文档选择器，允许用户从用户的设备上选择文件。这个包适用于Android和iOS。安装后无需进一步配置。</p>
<pre class="language-bash hljs">npm i react-native-document-picker react-native-video 
</pre>
<p>Android设置</p>
<h3 id="android-settings">需要一些配置才能在Android上运行。</h3>
<p>在<code>frontend/android/app/build.gradle</code>中，在依赖对象中添加以下行:</p>
<p>在<code>frontend/android/settings.gradle</code> <strong>、</strong>中添加以下代码:</p>
<pre class="language-javascript hljs">dependencies{
    implementation "androidx.appcompat:appcompat:1.0.0"
    …
}</pre>
<p>iOS设置</p>
<pre class="language-javascript hljs">include ':react-native-video'
project(':react-native-video').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-video/android-exoplayer')</pre>
<h3 id="ios-settings">在Mac上，运行以下命令以确保<code>react-native-video</code>适用于iOS:</h3>
<p>排序完所有依赖项后，启动<code>react-native</code> metro:</p>
<pre class="language-bash hljs">npx pod-install</pre>
<p>然后，在另一个终端上，使用以下命令运行应用程序，以便在Android上运行:</p>
<pre class="language-bash hljs">npx react-native start</pre>
<p>您应该会看到React本机屏幕，如下所示:</p>
<pre class="language-bash hljs"> npx react-native run-android</pre>
<p><img data-attachment-id="160288" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/react-native-android-screen-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1.png" data-orig-size="249,540" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React Native Android screen" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1-138x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1.png" decoding="async" class="aligncenter size-full wp-image-160288 jetpack-lazy-image" src="../Images/494adb53504fa08a2cef9ec8716cb9ca.png" alt="React Native Android Screen" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1.png 249w, https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1-138x300.png 138w" data-lazy-sizes="(max-width: 249px) 100vw, 249px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1.png"/></p>
<p id="gdcalert10">在iOS上，使用以下方式运行应用程序:</p><noscript><img data-lazy-fallback="1" data-attachment-id="160288" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/react-native-android-screen-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1.png" data-orig-size="249,540" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React Native Android screen" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1-138x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160288" src="../Images/494adb53504fa08a2cef9ec8716cb9ca.png" alt="React Native Android Screen" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1.png 249w, https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1-138x300.png 138w" sizes="(max-width: 249px) 100vw, 249px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-android-screen-1.png"/></noscript>
<p>您应该会在iOS上看到React Native屏幕:</p>
<pre class="language-bash hljs">npx react-native run-ios</pre>
<p><img data-attachment-id="160290" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/react-native-ios/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios.png" data-orig-size="249,493" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React Native iOS screen" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios-152x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios.png" decoding="async" class="aligncenter size-full wp-image-160290 jetpack-lazy-image" src="../Images/977520e7a2254b301da34c8767d420b5.png" alt="React Native IOS Screen" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios.png 249w, https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios-152x300.png 152w" data-lazy-sizes="(max-width: 249px) 100vw, 249px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios.png"/></p>
<p id="gdcalert11">创建加载器组件</p><noscript><img data-lazy-fallback="1" data-attachment-id="160290" data-permalink="https://blog.logrocket.com/build-video-upload-compression-app-multer-react-native/attachment/react-native-ios/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios.png" data-orig-size="249,493" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="React Native iOS screen" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios-152x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-160290" src="../Images/977520e7a2254b301da34c8767d420b5.png" alt="React Native IOS Screen" srcset="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios.png 249w, https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios-152x300.png 152w" sizes="(max-width: 249px) 100vw, 249px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/02/react-native-ios.png"/></noscript>
<h2 id="creating-loader-component">创建一个组件文件夹，在其中，<code>Loader.js.</code>该文件包含加载屏幕的代码，当我们等待上传完成或从Firebase成功检索文档时，将显示该屏幕。</h2>
<p><code>Loader.js</code>有以下代码:</p>
<p>上面的代码创建了一个显示加载指示器的组件。<code>ActivityIndicator</code>是一个React本地组件，显示了一个循环加载器。使用顺风CSS，我们将装载机放在<code>View</code>的中心。</p>
<pre class="language-javascript hljs">import { ActivityIndicator, View,Text } from "react-native";

const Loader = () =&gt; {
   return (
       &lt;View className="bg-white h-screen flex justify-center"&gt;

           &lt;ActivityIndicator size="large" color="#4D7902" /&gt;
           &lt;Text className="text-pink-900 font-bold text-center" &gt;Loading...&lt;/Text&gt;
       &lt;/View&gt;
   )
}
export default Loader
</pre>
<p>创建上传和获取组件</p>
<h2 id="creating-uploading-fetching-component">App.js组件将保存从Firebase获取URL和上传视频的逻辑。在<code>App.js</code>中，我们首先从React Native导入以下模块:</h2>
<p>ScrollView:可以容纳多个组件的可滚动容器</p>
<ul>
<li>RefreshControl:用于刷新ScrollView中内容的组件</li>
<li>文本:显示文本的组件</li>
<li>视图:用于容纳其他组件的容器</li>
<li>Alert:向用户显示警报的组件</li>
<li>可按压:用于创建可触摸元素的组件</li>
<li>接下来，我们从<code>react-native-video</code>导入视频组件，从<code>react-native-document-picker</code>导入<code>DocumentPicker</code>组件。</li>
</ul>
<p>然后，从React库中导入<a href="https://blog.logrocket.com/guide-to-react-useeffect-hook/"> useEffect </a>和<a href="https://blog.logrocket.com/a-guide-to-usestate-in-react-ecb9952e406c/"> useState </a>钩子，用于管理组件的状态，并在状态改变时触发副作用。</p>
<p>接下来，导入Axios库来发出服务器HTTP请求。</p>
<p>最后，加载器组件从<code>./Components/Loader.js</code>文件导入。API_ENDPOINT常量是用我们为API生成的实际端点ngrok URL声明和赋值的:</p>
<p>在App.js中，我们首先声明并初始化状态变量，这些变量将用于表示整个组件中不同的状态变化。这方面的代码是:</p>
<pre class="language-javascript hljs">import { ScrollView, RefreshControl, Text,  View, Alert, Pressable} from 'react-native';
import Video from 'react-native-video';
import DocumentPicker from 'react-native-document-picker'
import { useEffect, useState } from 'react'
import axios from 'axios';
import Loader from './Components/Loader.js';


const API_ENDPOINT = '&lt;paste-ngrok-url-here&gt;/api/uploads
'


const App = () =&gt; {
  // upload and fetch URLS logic goes here


};


Export default App;
</pre>
<p>接下来，我们添加一个<code>useEffect</code>钩子，它在组件挂载时触发副作用。钩子接受两个参数:一个回调函数和一个依赖数组。</p>
<pre class="language-javascript hljs">const App = () =&gt; {
 const [uploading, setUploading] = useState(false)
 const [files, setFiles] = useState([])
 const [fetching, setFetching] = useState(false)
 const [refreshing, setRefreshing] = useState(false);

};
Export default App;
</pre>
<p>每当组件被更新时，回调函数就被执行，并且依赖数组被用来确定何时应该触发副作用。在这种情况下，依赖数组是array，这意味着副作用只在组件第一次挂载时触发一次。</p>
<p>副作用是使用<code>getAllMedia function()</code>获取Firebase上上传的所有视频。</p>
<p>当获取承诺完成时，URL会更新文件的状态:</p>
<p>在<code>useEffect</code>之后，我们定义了一个错误处理函数，它将负责抛出上传错误作为警告:</p>
<pre class="language-javascript hljs">const App = () =&gt; {
 const [uploading, setUploading] = useState(false)
 const [files, setFiles] = useState([])
 const [fetching, setFetching] = useState(false)
 const [refreshing, setRefreshing] = useState(false); 

// —------------use effect —-----------------
useEffect(() =&gt; {
   getAllMedia().then((urls) =&gt; {
     setFiles(urls)
     setFetching(false)
   })
 }, [])

};
Export default App;
</pre>
<p>接下来，我们定义一个上传处理器。<code>handleUpload</code>函数是一个回调函数，用于处理将视频文件上传到服务器的过程。</p>
<pre class="language-javascript hljs">const App = () =&gt; {
 const [uploading, setUploading] = useState(false)
 const [files, setFiles] = useState([])
 const [fetching, setFetching] = useState(false)
 const [refreshing, setRefreshing] = useState(false); 

useEffect(() =&gt; {
   getAllMedia().then((urls) =&gt; {
     setFiles(urls)
     setFetching(false)
   })
 }, [])

// —-------- error handler —------------
 const handleError = (e) =&gt; {
   if (DocumentPicker.isCancel(e)) {
     Alert.alert('Upload Cancelled')
   } else {
     Alert.alert('Unknown Error: ' + JSON.stringify(e))
   }
 }

};
Export default App;
</pre>
<p><code>handleUpload</code>调用<code>DocumentPicker</code>组件，允许用户从他们的手机存储器中选择视频。选取的视频通过ngrok端点作为多部分表单数据发布到Firebase。错误由<code>handleError</code>函数处理。</p>
<p><code>handleUpload</code>功能代码如下:</p>
<p>接下来，我们定义<code>getAllMedia</code>函数。这个函数将发送一个get请求，返回一个包含所有已经上传到Firebase的文件的数组。该函数在发出API请求之前将获取状态设置为<code>true</code>，表示正在从API获取数据。如果请求过程中出现错误，将使用alert方法显示带有错误消息的警报:</p>
<pre class="language-javascript hljs">// —-----upload handler —-
const handleUpload = async () =&gt; {
   try {

     setUploading(true)

     const pickerResult = await DocumentPicker.pickSingle({
       type: ['video/*'],
       presentationStyle: 'fullScreen',
       copyTo: 'cachesDirectory',
     })

     const body = new FormData();

     body.append('files', {
       uri: pickerResult.fileCopyUri,
       type: pickerResult.type,
       name: pickerResult.name,
     });
     const config = {
       headers: {
         'Content-Type': 'multipart/form-data',
         'Content-Disposition': 'form-data',
       }
     }

     const response = await axios.post(API_ENDPOINT, body, config)
     if (response.status === 200) {
       Alert.alert('Upload Successful')
     }
     if (response.status === 500) {
       Alert.alert('Server error')
     }
     if (response.status === 403) {
       Alert.alert('Error uploading document.')
     }
     setUploading(false)
   } catch (e) {
     console.log(e.response)
     handleError(e)

   }
 }
</pre>
<p>实现了所有的助手函数和核心逻辑之后，我们现在可以开始呈现组件了。呈现的内容将被分成两个逻辑单元:一个上传按钮和一个呈现Firebase中所有视频文件的列表视图:</p>
<pre class="language-javascript hljs">const getAllMedia = async () =&gt; {
   try {
     setFetching(true)
     const response = await axios.get(API_ENDPOINT)
     return response.data

   } catch (e) {
     console.log(e)
     Alert.alert('Unknown Error: ' + JSON.stringify(e))
   }
 }
</pre>
<p>该视图包含一个触发<code>handleUpload</code>的上传按钮。当下拉时，<code>scrollView</code>通过调用<code>getAllMedia</code>并更新状态，从Firebase中重新提取所有视频。react-native-video包中的视频组件遍历并呈现所有视频URL。</p>
<pre class="language-javascript hljs">const App = () =&gt; {
// other functions here

return (
   &lt;View className="h-full p-10 flex justify-start text-md font-bold text-emerald-900 bg-white"&gt;
     &lt;Pressable
       onPress={handleUpload} &gt;
       &lt;Text className=" bg-pink-900 text-white rounded-md p-3 text-center"&gt;Upload Media&lt;/Text&gt;
     &lt;/Pressable&gt;

     &lt;ScrollView
       className="mt-10"
       refreshControl={
             &lt;RefreshControl
               refreshing={refreshing}
               onRefresh={
                 () =&gt; {
                   setRefreshing(true);
                   getAllMedia().then((urls) =&gt; {
                     console.log(urls)
                     setFiles(urls)
                     setFetching(false)
                     setRefreshing(false);
                   })
                 }
               }
             /&gt;
       }&gt;

       {uploading || fetching ? &lt;Loader /&gt; :
         &lt;&gt;
           {files.map((file, index) =&gt; {
             return (
               &lt;View key={index} className="border border-pink-900 h-60 m-2 "&gt;
                 &lt;Video
                   className="absolute top-0 left-0 bottom-0 right-0"
                   key={index}
                   paused={false}
                   repeat={true}
                   source={{ uri: file }}
                   controls={true}
                 /&gt;
               &lt;/View&gt;
             )
           })}
         &lt;/&gt;
       }

     &lt;/ScrollView&gt;
   &lt;/View&gt;
 );
};
export default App;
</pre>
<p><code>App.js</code>中的完整代码如下:</p>
<p>结论</p>
<pre class="language-javascript hljs">import { ScrollView, RefreshControl, Text,  View, Alert, Pressable} from 'react-native';
import Video from 'react-native-video';
import DocumentPicker from 'react-native-document-picker'
import { useEffect, useState } from 'react'
import axios from 'axios';

import Loader from './Components/Loader.js';
const API_ENDPOINT = '&lt;paste-ngrok-url-here&gt;/api/uploads
'

const App = () =&gt; {
 const [uploading, setUploading] = useState(false)
 const [files, setFiles] = useState([])
 const [fetching, setFetching] = useState(false)
 const [refreshing, setRefreshing] = useState(false);

 useEffect(() =&gt; {
   getAllMedia().then((urls) =&gt; {
     setFiles(urls)
     setFetching(false)
   })
 }, [])

 const handleError = (e) =&gt; {
   if (DocumentPicker.isCancel(e)) {
     Alert.alert('Upload Cancelled')
   } else {
     Alert.alert('Unknown Error: ' + JSON.stringify(e))
   }
 }

 const handleUpload = async () =&gt; {
   try {

     setUploading(true)

     const pickerResult = await DocumentPicker.pickSingle({
       type: ['video/*'],
       presentationStyle: 'fullScreen',
       copyTo: 'cachesDirectory',
     })

     const body = new FormData();

     body.append('files', {
       uri: pickerResult.fileCopyUri,
       type: pickerResult.type,
       name: pickerResult.name,
     });

     const config = {
       headers: {
         'Content-Type': 'multipart/form-data',
         'Content-Disposition': 'form-data',
       }
     }

     const response = await axios.post(API_ENDPOINT, body, config)
     if (response.status === 200) {
       Alert.alert('Upload Successful')
     }
     if (response.status === 500) {
       Alert.alert('Server error')
     }
     if (response.status === 403) {
       Alert.alert('Error uploading document.')
     }
     setUploading(false)

   } catch (e) {
     console.log(e.response)
     handleError(e)

   }
 }

 const getAllMedia = async () =&gt; {
   try {
     setFetching(true)
     const response = await axios.get(API_ENDPOINT)
     return response.data

   } catch (e) {
     console.log(e)
     Alert.alert('Unknown Error: ' + JSON.stringify(e))
   }
 }

 return (
   &lt;View className="h-full p-10 flex justify-start text-md font-bold text-emerald-900 bg-white"&gt;
     &lt;Pressable
       onPress={handleUpload} &gt;
       &lt;Text className=" bg-pink-900 text-white rounded-md p-3 text-center"&gt;Upload Media&lt;/Text&gt;
     &lt;/Pressable&gt;

     &lt;ScrollView
       className="mt-10"
       refreshControl={
         &lt;RefreshControl
           refreshing={refreshing}
           onRefresh={
             () =&gt; {
               setRefreshing(true);
               getAllMedia().then((urls) =&gt; {
                 console.log(urls)
                 setFiles(urls)
                 setFetching(false)
                 setRefreshing(false);
               })
             }
           }
         /&gt;
       }&gt;

       {uploading || fetching ? &lt;Loader /&gt; :
         &lt;&gt;
           {files.map((file, index) =&gt; {
             return (
               &lt;View key={index} className="border border-pink-900 h-60 m-2 "&gt;
                 &lt;Video
                   className="absolute top-0 left-0 bottom-0 right-0"
                   key={index}
                   paused={false}
                   repeat={true}
                   source={{ uri: file }}
                   controls={true}
                 /&gt;
               &lt;/View&gt;
             )
           })}
         &lt;/&gt;
       }

     &lt;/ScrollView&gt;
   &lt;/View&gt;
 );
};
export default App;
</pre>
<h2 id="conclusion">在本文中，我们探讨了如何从React原生应用上传视频。在构建跨平台工具时，React Native是一个强大的工具。使用相同的代码库，我们可以在不同的操作系统上运行两个独立的应用程序。学习母语本身就是一种超能力。这个项目的完整代码可以在GitHub上找到。</h2>
<p><a href="https://lp.logrocket.com/blg/react-native-signup"> LogRocket </a>:即时重现React原生应用中的问题。</p><div class="code-block code-block-18">
<div class="blog-plug inline-plug react-native-plug"><h2><a href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款React原生监控解决方案，可帮助您即时重现问题、确定bug的优先级并了解React原生应用的性能。</h2><a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/110055665562c1e02069b3698e6cc671.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/110055665562c1e02069b3698e6cc671.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/10/react-native-plug_v2-2.png"/></noscript></a><p>LogRocket还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的React原生应用— <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">免费试用LogRocket】。</a></p><p>Start proactively monitoring your React Native apps — <a class="signup" href="https://lp.logrocket.com/blg/react-native-signup" target="_blank" rel="noopener noreferrer">try LogRocket for free</a>.</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
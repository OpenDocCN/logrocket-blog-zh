<html>
<head>
<title>Build a web app in Go with Copper - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在Go with Copper - LogRocket博客中构建web应用程序</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/build-web-app-go-copper/#0001-01-01">https://blog.logrocket.com/build-web-app-go-copper/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Copper是一个包罗万象的Go工具箱，用于创建具有较少样板文件的web应用程序，并高度关注开发人员的效率，这使得在Go中构建web应用程序更加有趣。</p>
<p>Copper仍然依赖Go标准库来维持传统的Go体验，同时允许你在构建后端的同时构建前端应用程序，并在一个二进制文件中发布所有内容。它支持在前端使用React和Tailwind构建全栈web应用程序，并且它还支持构建API，这些API可以更加灵活地与Vue和Svelte等其他前端框架一起工作。</p>
<p>在本文中，我们将看看如何在Go中使用gocopper框架构建一个web应用程序，这样您就可以看到如何在自己的项目中实现它。</p>
<h2 id="prerequisites">先决条件</h2>
<p>要学习本教程，您应该具备以下条件:</p>
<ul>
<li>安装了go 1.16+版本</li>
<li>已安装节点v16+</li>
<li>构建Golang应用程序的经验</li>
</ul>
<h2 id="installation">装置</h2>
<p>为了开始使用Copper，我们将在终端上运行以下命令:</p>
<pre class="language-bash hljs">$ go install github.com/gocopper/cli/cmd/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="24474b5454415664484550415750">[email protected]</a>
</pre>
<p>运行以下命令以确保铜缆安装正常工作:</p>
<pre class="language-bash hljs">$ copper -h
</pre>
<p>如果<code>copper -h</code>不起作用，很可能意味着<code>$GOPATH/bin</code>不在你的<code>$PATH</code>里。将以下内容添加到<code>~/.zshrc</code>或<code>~/.bashrc</code>:</p>
<pre class="language-bash hljs">export PATH=$HOME/go/bin:$PATH
</pre>
<p>然后，重启您的终端会话并再次尝试<code>copper -h</code>。</p>
<h2 id="configuration">配置</h2>
<p>Copper允许您使用<code>-frontend</code>和<code>-storage</code>参数来配置项目模板。</p>
<p><code>-frontend</code>参数允许您使用以下前端框架和库来配置您的前端:</p>

<p><code>-storage</code>参数允许您配置数据库堆栈，默认情况下是<code>sqlite3</code>。您可以选择将其设置为<code>postgres</code>、<code>mysql</code>，或者使用<code>none</code>完全跳过存储。</p>
<h2 id="what-we-will-be-building-a-simple-to-do-app"><strong>我们将构建什么:一个简单的待办事项应用</strong></h2>
<p>我们将构建一个全栈web应用程序，允许我们在SQLite数据库上执行CRUD操作。基本上，我们将构建一个待办事项应用程序。这是完成后的应用程序的外观:</p>
<p><img data-attachment-id="136620" data-permalink="https://blog.logrocket.com/build-web-app-go-copper/attachment/finished-app-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app.png" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Finished app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app.png" decoding="async" class="aligncenter size-full wp-image-136620 jetpack-lazy-image" src="../Images/4bac952465c65330361ea5da429b143b.png" alt="Finished App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app-300x187.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136620" data-permalink="https://blog.logrocket.com/build-web-app-go-copper/attachment/finished-app-3/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app.png" data-orig-size="730,456" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Finished app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app-300x187.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-136620" src="../Images/4bac952465c65330361ea5da429b143b.png" alt="Finished App" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app-300x187.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/finished-app.png"/></noscript>
<p>这个应用程序允许我们从数据库中获取、添加、更新和删除待办事项。事不宜迟，我们开始吧。</p>
<h3 id="project-setup">项目设置</h3>
<p>我们将使用<code>go</code>前端堆栈创建一个使用Go模板的项目，如下所示:</p>
<pre class="language-bash hljs">copper create -frontend=go github.com/&lt;your-username&gt;/todolist
</pre>
<p>通过上面的命令，copper创建了一个基本的scaffold项目，其中Go模板用于前端，而<code>sqlite3</code>用于数据库。</p>
<p>你的项目脚手架应该是这样的:</p>
<p><img data-attachment-id="136623" data-permalink="https://blog.logrocket.com/build-web-app-go-copper/attachment/project-scaffold/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold.png" data-orig-size="512,1023" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Project scaffold" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold-150x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold.png" decoding="async" class="aligncenter size-full wp-image-136623 jetpack-lazy-image" src="../Images/39e681c4b1c86dc0b137241599ccf43f.png" alt="Project Scaffold" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold.png 512w, https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold-150x300.png 150w" data-lazy-sizes="(max-width: 512px) 100vw, 512px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136623" data-permalink="https://blog.logrocket.com/build-web-app-go-copper/attachment/project-scaffold/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold.png" data-orig-size="512,1023" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Project scaffold" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold-150x300.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-136623" src="../Images/39e681c4b1c86dc0b137241599ccf43f.png" alt="Project Scaffold" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold.png 512w, https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold-150x300.png 150w" sizes="(max-width: 512px) 100vw, 512px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/project-scaffold.png"/></noscript>
<p>要启动应用服务器，请运行以下命令:</p>
<pre class="language-bash hljs">$ cd todolist &amp;&amp; copper run -watch
</pre>
<p>打开<a href="http://localhost:5901/" target="_blank" rel="noopener"> http://localhost:5901 </a>看到铜欢迎页面。</p>
<h3 id="updating-the-layout-file">更新布局文件</h3>
<p>让我们用脚本标签更新<code>web/src/layouts/main.html</code>文件，如下所示:</p>
<pre class="language-xml hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;
    &lt;title&gt;Copper App&lt;/title&gt;
    &lt;link rel="stylesheet" href="/static/styles.css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    {{ template "content" . }}
    &lt;script src="/static/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>我们将在<code>static/index.js</code>文件中编写一些javascript来处理应用程序中的删除请求。</p>
<p>我们的待办事项应用程序要求用户将待办事项添加到数据库中。让我们用一个简单的表单和一个列出所有待办事项的部分创建一个新的待办事项页面。</p>
<p>导航到pages目录，使用以下内容创建一个名为<code>todos.html</code>的文件:</p>
<pre class="language-xml hljs">{{ define "content"}}
&lt;div class="gr-container"&gt;
    &lt;h2 class="heading"&gt;Todo List&lt;/h2&gt;
    &lt;form class="add-todo" action="/todos" method="post"&gt;
        &lt;input type="text" name="todo"&gt;
        &lt;button type="submit"&gt;Add Todo&lt;/button&gt;
    &lt;/form&gt;
    &lt;div class="todo-list"&gt;
        &lt;form class="todo-item" action="" method="post"&gt;
            &lt;input type="text" name="todo"&gt;
            &lt;button class="update" type="submit"&gt;Update Todo&lt;/button&gt;
            &lt;button class="delete" type="button"&gt;Remove Todo&lt;/button&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;
{{ end }}
</pre>
<h3 id="styling-our-sample-app">设计我们的示例应用程序</h3>
<p>导航到<code>web/public</code>目录，用以下内容更新<code>style.css</code>:</p>
<pre class="language-css hljs">@import url('https://fonts.googleapis.com/css2?family=Work+Sans:ital,<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6e1909061a2e5e">[email protected]</a>,700;1,400&amp;display=swap');
html, body {
    margin: 0;
    background-color: wheat;
}
#app {
    /* background-color: whitesmoke; */
    padding: 40px 0;
    font-family: 'Work Sans', sans-serif;
    text-align: center;
    height: 100%;
    box-sizing: border-box;
}
.tagline {
    font-style: italic;
    font-weight: 400;
}
hr {
    margin: 40px auto;
    width: 60%;
    border-top: 1px solid #ddd;
}
.video {
    width: 60%;
    margin: 0 auto;
}
.todo-list {
    background-color: greenyellow;
    margin-top: 2rem;
    width: 60%;
    padding: 1.5rem;
}
.add-todo {
    width: 50%;
    display: flex;
    justify-items: center;
}
.add-todo input {
    width: 85%;
    height: 2rem;
}
.add-todo button {
    width: 15%;
    /* height: 1.5rem; */
}
.todo-item {
    display: flex;
    margin-bottom: 1rem;
}
.todo-item input {
    width: 65%;
    height: 1.6rem;
}
.update, .delete {
    width: 16%;
}
.heading {
    text-align: center;
    font-size: 2.5rem;
}
.gr-container {
    padding: 1rem;

    display: flex;
    flex-direction: column;
    align-items: center;
}
</pre>
<p>为了在浏览器上查看待办事项页面，我们将如下更新<code>pkg/app/router.go</code>文件:</p>
<pre class="language-go hljs">func (ro *Router) Routes() []chttp.Route {
    return []chttp.Route{
        {
            Path:    "/",
            Methods: []string{http.MethodGet},
            Handler: ro.HandleIndexPage,
        },
        {
            Path:    "/todos",
            Methods: []string{http.MethodGet},
            Handler: ro.HandleTodosPage,
        },
    }
}
func (ro *Router) HandleTodosPage(w http.ResponseWriter, r *http.Request) {
    ro.rw.WriteHTML(w, r, chttp.WriteHTMLParams{
        PageTemplate: "todos.html",
    })
}
</pre>
<p>在这里，我们用<code>"/todos"</code>路径更新了我们的应用程序路径，还创建了<code>HandleTodosPage</code>处理程序，当用户在浏览器中点击<code>"/todos"</code>路径时，它将服务于<code>todos.html</code>页面。</p>
<p>重启应用服务器，打开<a href="http://localhost:5901/" target="_blank" rel="noopener">http://localhost:5901</a>/todos查看待办事项页面。</p>
<p>待办事项页面应该是这样的:</p>
<p><img data-attachment-id="136625" data-permalink="https://blog.logrocket.com/build-web-app-go-copper/attachment/initial-version-of-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app.png" data-orig-size="730,302" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Initial version of app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app-300x124.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app.png" decoding="async" class="aligncenter size-full wp-image-136625 jetpack-lazy-image" src="../Images/7f0e0a0ff4bec486d9957d7c94bf4bce.png" alt="Initial Version of App" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app-300x124.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136625" data-permalink="https://blog.logrocket.com/build-web-app-go-copper/attachment/initial-version-of-app/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app.png" data-orig-size="730,302" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Initial version of app" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app-300x124.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-136625" src="../Images/7f0e0a0ff4bec486d9957d7c94bf4bce.png" alt="Initial Version of App" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app-300x124.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/initial-version-of-app.png"/></noscript>
<h3 id="implement-a-feature-to-create-now-to-do-items">实现创建当前待办事项的功能</h3>
<p>为了实现create特性，我们设置了一个存储层，可以将待办事项保存到数据库中。</p>
<p>让我们运行下面的命令来创建<code>pkg/todos</code>包和一个<code>pkg/todos/queries.go</code>，我们可以用它来实现我们的SQL查询:</p>
<pre class="language-bash hljs">copper scaffold:pkg todos
copper scaffold:queries todos
</pre>
<p>接下来，我们将创建<code>Todo</code>模型及其数据库迁移。打开<code>pkg/todos/models.go</code>并定义<code>Todo</code>型号:</p>
<pre class="language-go hljs">type Todo struct {
    Name string
    Rank int64 `gorm:"-"`
}
</pre>
<p>然后，打开<code>migrations/0001_initial.sql</code>并定义它的数据库模式:</p>
<pre class="language-sql hljs">-- +migrate Up
CREATE TABLE todos (
    name text
);
-- +migrate Down
DROP TABLE todos;
</pre>
<p>在您的终端中，运行<code>copper migrate</code>来创建表格。</p>
<p>现在我们的数据库中有了一个<code>Todo</code>模型和一个<code>todos</code>表，我们可以在<code>pkg/posts/queries.go</code>文件中编写我们的数据库查询。</p>
<p>让我们添加一个<code>SaveTodo</code>方法，它可以用来将新的待办事项插入到<code>todos</code>表中:</p>
<pre class="language-go hljs">import (
    "context"
    ...
)
func (q *Queries) SaveTodo(ctx context.Context, todo *Todo) error {
    const query = `
    INSERT INTO todos (name)
    VALUES (?)`
    _, err := q.querier.Exec(ctx, query,
        todo.Name,
    )
    return err
}
</pre>
<p>这里，我们使用一个SQL查询将一个新的待办事项插入到数据库中。问号是查询中值的占位符。<code>q.querier.Exec</code>函数接受一个上下文对象、一个查询和尽可能多的要传递给占位符的参数。然后，占位符中的值按照它们在<code>q.querier.Exec</code>函数中出现的顺序插入。</p>
<p>现在，让我们转到<code>pkg/app/router.go</code>并使用<code>SaveTodo</code>方法来处理表单提交以创建新的待办事项。</p>
<p>创建一个新的路由处理器<code>HandleSubmitPost</code>，用于处理创建新待办事项的提交，如下所示:</p>
<pre class="language-go hljs">func (ro *Router) HandleCreateTodos(w http.ResponseWriter, r *http.Request) {
    var (
        todo = strings.TrimSpace(r.PostFormValue(("todo")))
    )
    if todo == "" {
        ro.rw.WriteHTMLError(w, r, cerrors.New(nil, "unable to create todos: todo cannot be empty", map[string]interface{}{
            "form": r.Form,
        }))
        return
    }
    newtodo := todos.Todo{Name: todo}
    err := ro.todos.SaveTodo(r.Context(), &amp;newtodo)
    if err != nil {
        ro.logger.Error("an error occured while saving todo", err)
        ro.rw.WriteHTMLError(w, r, cerrors.New(nil, "unable to create todos", map[string]interface{}{
            "form": r.Form,
        }))
        return
    }
    http.Redirect(w, r, "/todos", http.StatusSeeOther)
}
</pre>
<p>此功能创建一个新的待办事项。首先。我们从表单中获取待办事项值，并修剪用户可能添加的任何空白。然后，我们检查待办事项是否为空字符串，在这种情况下，我们会抛出一个错误。接下来，我们创建一个新的to-do对象，并调用<code>ro.todos.SaveTodo</code>函数将其保存到数据库中。如果在保存待办事项时出现错误，我们会抛出一个错误。最后，我们重定向到待办事项页面。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>用<code>HandleCreateTodos</code>更新<code>pkg/app/router.go</code>文件，如下所示:</p>
<pre class="language-go hljs">import (
    "strings"
    "github.com/gocopper/copper/cerrors"
    "github.com/gocopper/copper/chttp"
    "github.com/gocopper/copper/clogger"
    "net/http"
    "github.com/emmanuelhashy/todolist/pkg/todos"
)

type NewRouterParams struct {
    Todos  *todos.Queries
    RW     *chttp.ReaderWriter
    Logger clogger.Logger
}

func NewRouter(p NewRouterParams) *Router {
    return &amp;Router{
        rw:     p.RW,
        logger: p.Logger,
        todos:  p.Todos,
    }
}

type Router struct {
    rw     *chttp.ReaderWriter
    logger clogger.Logger
    todos  *todos.Queries
}

func (ro *Router) Routes() []chttp.Route {
    return []chttp.Route{
        {
            Path:    "/",
            Methods: []string{http.MethodGet},
            Handler: ro.HandleIndexPage,
        },
        {
            Path:    "/todos",
            Methods: []string{http.MethodGet},
            Handler: ro.HandleTodosPage,
        },
        {
            Path:    "/todos",
            Methods: []string{http.MethodPost},
            Handler: ro.HandleCreateTodos,
        },
    }
}
</pre>
<p>现在，我们的todo应用程序的创建功能应该工作了！我们可以在<code>todos</code>表中添加一个新的待办事项。</p>
<h3 id="add-a-read-feature-to-see-all-the-to-do-items">添加阅读功能以查看所有待办事项</h3>
<p>为了实现read特性，我们将创建一个新的SQL查询来返回数据库中存在的所有todos的列表，并从那里开始向上查找。</p>
<p>用以下方法更新<code>pkg/todos/queries.go</code>,列出所有待办事项:</p>
<pre class="language-go hljs">func (q *Queries) ListTodos(ctx context.Context) ([]Todo, error) {
    const query = "SELECT * FROM todos"
    var (
        todos []Todo
        err   = q.querier.Select(ctx, &amp;todos, query)
    )
    return todos, err
}
</pre>
<p>这里，我们使用一个SQL查询来获取存储在数据库中的所有待办事项。因为我们没有更新DB中的值，所以我们使用了与<code>q.querier.Exec</code>相反的<code>q.querier.Select</code>方法。</p>
<p>接下来，更新<code>pkg/app/router.go</code>中的<code>HandleTodosPage</code>方法，以查询所有todos并将其传递给HTML模板:</p>
<pre class="language-go hljs">func (ro *Router) HandleTodosPage(w http.ResponseWriter, r *http.Request) {
    todos, err := ro.todos.ListTodos(r.Context())
    if err != nil {
        ro.logger.Error("an error occured while fetching todos", err)
        ro.rw.WriteHTMLError(w, r, cerrors.New(nil, "unable to fetch todos", map[string]interface{}{
            "form": r.Form,
        }))
    }
    for i := range todos {
        todos[i].Rank = int64(i + 1)
    }
    ro.rw.WriteHTML(w, r, chttp.WriteHTMLParams{
        PageTemplate: "todos.html",
        Data:         todos,
    })
}
</pre>
<p>要使用数据并呈现所有待办事项列表，请按如下方式更新<code>web/src/pages/todos.html</code>:</p>
<pre class="language-xml hljs">{{ define "content"}}
&lt;div class="gr-container"&gt;
    &lt;h2 class="heading"&gt;Todo List&lt;/h2&gt;
    &lt;form class="add-todo" action="/todos" method="post"&gt;
        &lt;input type="text" name="todo"&gt;
        &lt;button type="submit"&gt;Add Todo&lt;/button&gt;
    &lt;/form&gt;
    &lt;div class="todo-list"&gt;
        {{ range . }}
        &lt;form class="todo-item" action="/{{.Name}}" method="post"&gt;
            {{.Rank}}.
            &lt;input type="text" name="todo" value="{{.Name}}"&gt;
            &lt;button class="update" type="submit"&gt;Update Todo&lt;/button&gt;
            &lt;button class="delete" type="button"&gt;Remove Todo&lt;/button&gt;
        &lt;/form&gt;

        {{ end }}
    &lt;/div&gt;
&lt;/div&gt;
{{ end }}
</pre>
<p>现在，您应该在待办事项页面中看到数据库中所有待办事项的列表。</p>
<p><img data-attachment-id="136627" data-permalink="https://blog.logrocket.com/build-web-app-go-copper/attachment/list-of-todos/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos.png" data-orig-size="730,358" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="List of todos" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos.png" decoding="async" class="aligncenter size-full wp-image-136627 jetpack-lazy-image" src="../Images/5d7851fef6a858140448c5fb892b726f.png" alt="List of Todos" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos-300x147.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="136627" data-permalink="https://blog.logrocket.com/build-web-app-go-copper/attachment/list-of-todos/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos.png" data-orig-size="730,358" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="List of todos" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos-300x147.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-136627" src="../Images/5d7851fef6a858140448c5fb892b726f.png" alt="List of Todos" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos-300x147.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/list-of-todos.png"/></noscript>
<h3 id="update-to-do-items">更新待办事项</h3>
<p>为了实现更新特性，我们将创建一个新的SQL查询来更新数据库中存在的待办事项。</p>
<p>用以下方法更新<code>pkg/todos/queries.go</code>:</p>
<pre class="language-go hljs">func (q *Queries) UpdateTodo(ctx context.Context, oldName string, todo *Todo) error {
    const query = `
    UPDATE todos SET name=(?) WHERE name=(?)`
    _, err := q.querier.Exec(ctx, query,
        todo.Name,
        oldName,
    )
    return err
}
</pre>
<p>这里，我们使用一个SQL查询来更新数据库中的一个待办事项值。我们将新值和旧值分别传递给SQL查询中的占位符。</p>
<p>接下来，我们将在<code>pkg/app/router.go</code>中创建一个<code>HandleUpdateTodos</code>方法来更新现有的todos:</p>
<pre class="language-go hljs">func (ro *Router) HandleUpdateTodos(w http.ResponseWriter, r *http.Request) {
    var (
        todo    = strings.TrimSpace(r.PostFormValue("todo"))
        oldName = chttp.URLParams(r)["todo"]
    )
    if todo == "" {
        ro.rw.WriteHTMLError(w, r, cerrors.New(nil, "unable to update todos: todo cannot be empty", map[string]interface{}{
            "form": r.Form,
        }))
        return
    }
    newtodo := todos.Todo{Name: todo}
    ro.logger.WithTags(map[string]interface{}{
        "oldname": oldName,
        "newname": newtodo.Name,
    }).Info("Todo updated")
    err := ro.todos.UpdateTodo(r.Context(), oldName, &amp;newtodo)
    if err != nil {
        ro.logger.Error("an error occured while saving todo", err)
        ro.rw.WriteHTMLError(w, r, cerrors.New(nil, "unable to update todos", map[string]interface{}{
            "form": r.Form,
        }))
        return
    }
    http.Redirect(w, r, "/todos", http.StatusSeeOther)
}
</pre>
<p>然后用<code>HandleUpdateTodos</code>方法更新<code>Routes</code>，如下所示:</p>
<pre class="language-go hljs">func (ro *Router) Routes() []chttp.Route {
    return []chttp.Route{
        ...
        {
            Path:    "/{todo}",
            Methods: []string{http.MethodPost},
            Handler: ro.HandleUpdateTodos,
        },
    }
}
</pre>
<h3 id="delete-to-dos">删除待办事项</h3>
<p>为了实现删除特性，我们将创建一个新的SQL查询来删除数据库中存在的待办事项。</p>
<p>用以下方法更新<code>pkg/todos/queries.go</code>:</p>
<pre class="language-go hljs">func (q *Queries) DeleteTodo(ctx context.Context, todo *Todo) error {
    const query = `
    DELETE from todos WHERE name=(?)`
    _, err := q.querier.Exec(ctx, query,
        todo.Name,
    )
    return err
}
</pre>
<p>接下来，我们将在<code>pkg/app/router.go</code>中创建<code>HandleDeleteTodos</code>方法来删除现有的待办事项:</p>
<pre class="language-go hljs">type error struct {
    error string
}

func (ro *Router) HandleDeleteTodos(w http.ResponseWriter, r *http.Request) {
    var (
        todo = strings.TrimSpace(chttp.URLParams(r)["todo"])
    )
    if todo == "" {
        deleteError := error{error: "Unable to delete todo"}
        ro.rw.WriteJSON(w, chttp.WriteJSONParams{StatusCode: 500, Data: deleteError})
        return
    }
    newtodo := todos.Todo{Name: todo}
    err := ro.todos.DeleteTodo(r.Context(), &amp;newtodo)
    if err != nil {
        ro.logger.Error("an error occured while deleting todo", err)
        deleteError := error{error: "Unable to delete todo"}
        ro.rw.WriteJSON(w, chttp.WriteJSONParams{StatusCode: 500, Data: deleteError})
        return
    }
    http.Redirect(w, r, "/todos", http.StatusSeeOther)
}
</pre>
<p>然后用<code>HandleDeleteTodos</code>方法更新<code>Routes</code>，如下所示:</p>
<pre class="language-go hljs">func (ro *Router) Routes() []chttp.Route {
    return []chttp.Route{
        ...
        {
            Path:    "/{todo}",
            Methods: []string{http.MethodDelete},
            Handler: ro.HandleDeleteTodos,
        },
    }
}
</pre>
<p>为了总结我们的待办事项应用程序的删除特性，我们将在<code>web/public</code>目录中创建一个<code>index.js</code>文件，并添加以下函数:</p>
<pre class="language-javascript hljs">function deleteTodo(name){
    fetch(`/${name}`, {method: "Delete"}).then(res =&gt;{
        if (res.status == 200){
            window.location.pathname = "/todos"
        }
    }).catch(err =&gt; {
        alert("An error occured while deleting the todo", err.message)
    })
}
</pre>
<p>然后，更新<code>pages/todos.html</code>中的删除待办事项按钮，如下所示:</p>
<pre class="language-xml hljs">&lt;button class="delete" type="button" onclick = "deleteTodo('{{.Name}}')" &gt;Remove Todo&lt;/button&gt;
</pre>
<p>我们已经使用gocopper在Go中成功构建了一个web app。</p>
<p>如果你正确地遵循了上面的教程，你的待办事项应用应该能够执行基本的创建、读取、更新和删除操作。</p>
<p>这里是最终的<a href="https://github.com/emmanuelhashy/gocopper-todoapp" target="_blank" rel="noopener">代码库</a>的链接。</p>
<h2 id="conclusion">结论</h2>
<p>本教程终于告一段落。我们研究了如何使用Copper在Go中创建一个web应用程序，并使用它成功地构建了一个待办事项应用程序。</p>
<p>Copper利用<code>google/wire</code>来支持动态依赖注入。它附带了<code>clogger</code>包，可以在开发和生产环境中实现结构化日志记录。此外，它与<code>cerrors</code>包紧密协作，帮助为您的错误添加结构和上下文，从而显著改进错误日志。</p>
<p>我迫不及待地想看看你下一步会做什么，因为有很多方法可以让它变得更好。你可以在Twitter上关注我@5x_dev。</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
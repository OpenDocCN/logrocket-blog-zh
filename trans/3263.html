<html>
<head>
<title>Using strict mode in React 18: A guide to its new behaviors - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在React 18中使用严格模式:新行为指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/using-strict-mode-react-18-guide-new-behaviors/#0001-01-01">https://blog.logrocket.com/using-strict-mode-react-18-guide-new-behaviors/#0001-01-01</a></blockquote><div><article class="article-post">
<p>React已经存在很长时间了。每个主要版本都向我们介绍了新的技术、工具和处理UI问题的方式。</p>
<p><a href="https://reactjs.org/blog/2022/03/29/react-v18.html" target="_blank" rel="noopener"> React于2022年3月</a>发布了v18，包括了一些架构上的变化。这个版本主要关注于并发模式、新的React挂钩以及React的严格模式API的行为变化。虽然严格模式已经成为React的一项功能有一段时间了，但v18使它在捕捉早期错误方面更加有效，从而使代码库更加可预测。</p>
<p>在本文中，您将了解严格模式以及最初引入它的原因。您将看到它的各种特性，以及v18版本如何改进其API并提供与钩子更好的兼容性。</p>
<p>严格模式试图通过React基于悬念的架构为未来做好准备，使其在反思UI问题方面更具弹性。我们开始吧！</p>

<h2 id="introduction-reacts-strict-mode">React的严格模式介绍</h2>
<p>严格模式可以被认为是<code><a href="https://www.w3schools.com/js/js_strict.asp" target="_blank" rel="noopener">"use strict"</a></code>符号。这是不久前在ECMAScript v5中引入的，确保了JavaScript的更严格版本。</p>
<pre class="language-javascript hljs">"use strict";
x = 3.1415;
</pre>
<p>上面的例子会抛出一个错误，因为没有定义<code>x</code>。请注意在文件顶部添加<code>"use strict"</code>是如何确保这一点的。在没有添加<code>"use strict"</code>的情况下，您甚至可能不会得到这个错误，因为如果没有严格的类型定义(如<code>"use strict"</code>、TypeScript、<a href="https://flow.org/" target="_blank" rel="noopener"> flow </a>等)，JavaScript往往会执行奇怪的行为。)</p>
<p>类似地，React中的严格模式是一个仅供开发使用的工具，它在您编写React代码时强制执行更严格的警告和检查。</p>
<p>您可以为任何组件启用<code>StrictMode</code>,只需将组件名称作为子属性包装在<code>StrictMode</code>中，如下所示:</p>
<pre class="language-javascript hljs">&lt;StrictMode&gt;
    &lt;Button /&gt;
&lt;/StrictMode&gt;
&lt;StrictMode&gt;
    &lt;Navbar /&gt;
&lt;/StrictMode&gt;
</pre>
<p>更推荐的方法是用<code>StrictMode</code>包装根<code>App</code>组件。注意<code>App</code>一般是create-react-app和Next.js中的根组件</p>
<pre class="language-javascript hljs">&lt;StrictMode&gt;
    &lt;App /&gt;
&lt;/StrictMode/&gt;
</pre>
<p>这将在整个React代码库中强制执行开发时间检查和警告。当然，确保像这样导入<code>StrictMode</code>:</p>
<pre class="language-javascript hljs">import { StrictMode } from 'react'
 &lt;StrictMode&gt;
   .....
 &lt;/StrictMode&gt;
</pre>
<p>或者像这样:</p>
<pre class="language-javascript hljs">import React from 'react'
 &lt;React.StrictMode&gt;
  .....
 &lt;/React.StrictMode&gt;
</pre>
<p>现在，我们将更深入地了解严格模式的各种含义，并帮助在开发的早期发现问题。</p>
<h2 id="warnings-use-unsafe-lifecycle-methods">关于使用不安全生命周期方法的警告</h2>
<p><a href="https://blog.logrocket.com/react-lifecycle-methods-tutorial-examples/" target="_blank" rel="noopener"> React基于类的生命周期方法</a>经历了一系列的API变化。许多曾经被广泛使用的方法现在已经被官方否决，并且不鼓励支持更现代的API。</p>
<p>React的严格模式现在会警告开发者他们是否在使用这些被弃用的API，比如<code>componentWillMount</code>、<code>componentWillReceiveProps</code>和<code>componentWillUpdate</code>。这些现在被认为是不安全的，以至于React在这些API名称前添加了一个<code>UNSAFE</code>前缀:</p>
<ul>
<li><code>UNSAFE_componentWillMount</code></li>
<li><code>UNSAFE_componentWillReceiveProps</code></li>
<li><code>UNSAFE_componentWillUpdate</code></li>
</ul>
<p>如果正在使用的任何第三方包包含这些被否决的API，严格模式甚至足够智能地警告开发人员。您可以自己修改这些包，也可以选择其他包。</p>
<h2 id="recommending-createref-api-over-legacy-string-ref">推荐使用<code>createRef</code> API而不是传统的字符串引用</h2>
<p>如果您在基于类的架构是创建组件的实际方式时使用过React，您可能会使用字符串引用API:</p>
<pre class="language-javascript hljs">class Form extends Component {
  render() {
    return &lt;input onClick={() =&gt; this.focus()} ref='input' /&gt;;
  }
  focus() {
    console.log(this.refs.input.value);
  }
}
</pre>
<p>尽管可读性强、使用方便，但由于以下几个原因，该API现在被认为是一种遗产，包括:</p>
<ul>
<li>包装的组件不能确定它的子组件是否已经有了一个引用。使用回调引用模式可以解决这个问题</li>
<li>string ref API可能很难阅读，也很难使用类型检查器进行静态分析</li>
</ul>
<p>React的严格模式警告开发者要么使用回调模式，要么使用更现代的<code>createRef</code> API。</p>
<h2 id="warnings-deprecated-finddomnode-usage">关于不推荐使用的<code>findDOMNode</code>的警告</h2>
<p>是一个基于类的API，用于定位DOM树中任何组件的深层元素。</p>
<pre class="language-javascript hljs">class Layout extends Component {


componentDidMount() {
  const nodeElement = ReactDOM.findDOMNode(this);
}


     render () {
     return &lt;Navigation&gt;{this.props.children}&lt;/Navigation&gt;;
     }
    }
</pre>
<p>这可能看起来很好，但它实际上导致了React抽象原则的问题。</p>
<p>父元素必须确保其子元素向下延伸并呈现正确的DOM节点。一个很大的缺点是，<code>findDOMNode</code>只是一个一次性的调用API，所以如果任何节点元素由于某种状态更新而改变，它将不会被<code>findDOMNode</code> API反映和更新。</p>
<p>考虑到所有这些缺点，严格模式警告您不要使用该API，并且它可能会在未来的React版本中被删除。</p>
<p>大多数时候，DOM元素现在可以使用<code>ref</code>作为目标。您可以简单地将一个<code>ref</code>引用附加到您需要定位的元素上。</p>
<pre class="language-javascript hljs">class Form extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();    
}

// handle textInput.current logic here //
  render() {
    return (
      &lt;input
          type="text"
          ref={this.textInput} 
   /&gt;       
    );
  }
}
</pre>
<h2 id="detecting-unexpected-side-effects">检测意外的副作用</h2>
<p>React的严格模式做了一些关于流行的内置钩子的有趣的事情，比如<code>useState</code>、<code>useMemo</code>和<code>useReducer</code>。具体来说，它在开发中调用这些函数两次，在生产模式中调用一次(如预期的那样)。</p>
<p>这可能会在调试代码时造成一些混乱，但是通过这样做，严格模式可以确保检查潜在的内存泄漏。这也有助于使代码在严格模式下更具确定性。</p>
<p>不仅仅局限于功能组件，同样的调用函数两次的行为也可以在基于类的架构中找到，比如<code>constructor</code>、<code>render</code>、<code>shouldComponentUpdate</code>等等。</p>
<p>如果您使用的是create-react-app，则整个应用程序默认为严格模式。在类组件中使用这些钩子或状态更新函数时，您甚至会看到控制台消息被记录两次。</p>
<p>在v18之前，React用于在函数被调用两次时立即使第二个<code>console.log</code>方法静默。但是，在v18中，React没有抑制任何日志，从而为开发人员提供了更多的透明度。现在，所有这些日志在任何函数、钩子等的双重调用中都会被调用两次。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<h2 id="warnings-legacy-context-api">旧上下文API上的警告</h2>
<p>类似于refs API，我们也有一个遗留的上下文API。严格模式警告不要使用遗留上下文API，因为它将从未来的版本中删除。相反，我们有一个使用提供者-消费者模式的更现代的上下文API。</p>
<pre class="language-javascript hljs">const ThemeContext = React.createContext('dark')

// consume it here
 &lt;ThemeContext.Provider value={data}&gt;
     {children}
&lt;/ThemeContext.Provider&gt;
</pre>
<p>现在，这是使用新的上下文API处理应用程序状态上下文的推荐方式。</p>
<h2 id="react-v18-unmounting-remounting-architecture">React v18卸载和重新安装架构</h2>
<p>React v18引入了关于卸载和重装的新的严格模式行为。现在，每个元素将被卸载并重新装载，其状态和效果与该元素第一次装载时相同。</p>
<p>典型的安装和重新安装周期如下所示:</p>
<ul>
<li>该元素第一次安装</li>
<li>副作用产生了</li>
<li>严格模式现在模仿效果的破坏</li>
<li>副作用将应用于已安装的组件</li>
</ul>
<p>这使得React代码更有弹性，并有助于保持UI的状态。例如，如果用户在第一个选项卡上，并立即在第一个和第二个选项卡之间来回切换，React需要确保安装和销毁正确的元素块，同时保留正确的UI状态和副作用。</p>
<p>从v18开始，严格模式增加了这一开发专用行为。</p>
<h2 id="conclusion">结论</h2>
<p>您现在已经涵盖了React v18的严格模式更新中的所有内容！</p>
<p>我们已经看到了严格模式如何影响开发模式工具。它有自己的一套规则和行为，确保对代码库进行严格的警告和检查。这不仅有助于开发人员使代码库为未来做好准备，也有助于重构。</p>
<p>React官方团队建议在应用范围内强制执行严格模式，以充分利用它。对于未来的React版本，预计严格模式将获得更多的特性，以帮助像我们这样的开发人员获得更好的工具支持。</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</h2><p>调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
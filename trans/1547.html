<html>
<head>
<title>Using Redis in AdonisJs for data caching - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>在 AdonisJs 中使用 Redis 进行数据缓存</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/redis-adonisjs-data-caching/#0001-01-01">https://blog.logrocket.com/redis-adonisjs-data-caching/#0001-01-01</a></blockquote><div><article class="article-post">
<p>AdonisJs 是专门为编写微服务而构建的 Node.js 框架。像 must 后端框架一样，AdonisJs 支持 Redis，这有助于加快应用程序中的请求/响应时间，使过程无缝和应用程序轻量级。Redis，代表<strong>Re</strong>mote<strong>Di</strong>rectory<strong>S</strong>server，是一个开源的、<a href="https://en.wikipedia.org/wiki/In-memory_database">内存</a>数据结构存储。</p>
<p>Redis 是一个磁盘持久的键值数据库，支持多种数据结构或数据类型，这意味着它支持基于映射键值的字符串来存储和检索数据(类似于传统数据库中支持的数据模型)，同时也支持其他复杂的数据结构，如列表、集合等。</p>
<p>接下来，我们将看看 Redis 支持的数据结构。简单地说，它缓存你的文件，这样你就不需要每次都请求数据库。</p>
<p>根据每月<a href="https://db-engines.com/en/ranking/key-value+store">的数据库引擎排名</a>，Redis 通常是最受欢迎的键值数据库，也是科技界十大最受欢迎的数据库之一。</p>
<blockquote><p><strong>注意</strong>，您需要在本地机器上安装 Redis，因为如果没有在本地安装，它将无法与 AdonisJs 一起工作。</p></blockquote>
<p>关于如何在您的开发机器上安装 Redis 的说明可以在下面找到:</p>

<p>在安装过程中，您的默认端口应该设置为<code>6379</code>。这是 Redis 的专用端口，尽管如果另一个端口正在使用，它也会使用端口<code>6380</code>。</p>
<h2>简介和先决条件</h2>
<p>在本教程中，我们将介绍如何:</p>
<ul>
<li>创建 AdonisJs 应用程序的新实例</li>
<li>安装 Redis 并在我们的应用程序上设置它</li>
<li>配置我们的数据库来发出请求</li>
<li>使用 Redis' <code>get</code>和<code>set</code>方法</li>
<li>展示使用 Redis 和从数据库直接调用时请求时间的差异</li>
<li>使用 Redis 的发布/订阅方法来发布和订阅请求</li>
</ul>
<p>要继续学习本教程，您应该具备 JavaScript、AdonisJs 和 SQL 数据库的基础知识，因为本教程不涉及基础知识。</p>
<h3>系统需求</h3>

<p>首先，我们需要在本地计算机上全局安装 Adonis CLI，以便我们可以使用 CLI 命令来创建和服务我们的应用程序:</p>
<pre>npm -g @adonisjs/cli</pre>
<p>接下来，我们可以创建一个新的 AdonisJs 应用程序，并使用以下代码运行它；这将创建 AdonisJs 的新实例。然后，我们进入应用程序文件夹并运行应用程序:</p>
<pre>adonis new adonis_redis

cd adonis_redis

adonis serve --dev</pre>
<h2>为 AdonisJs 应用程序配置 Redis</h2>
<p>现在我们已经启动并运行了我们的应用程序，我们将安装 Redis:</p>
<pre>npm install @adonisjs/redis</pre>
<p>这将创建一个名为<code>start/redis.js</code>的新文件，其中将包含我们的<code>subscribe</code>方法。我们将在教程的后面解决这个问题。</p>
<p>安装完成后，我们可以在<code>start/app.js</code>文件中注册 Redis 提供者:</p>
<pre>const providers = [
  '@adonisjs/redis/providers/RedisProvider'
]</pre>
<p>然后，我们将下面的代码添加到我们的<code>server.js</code>文件中，以在应用程序中启动 Redis。如果没有这个附加功能，Redis 将不会在应用程序每次运行时都运行。</p>
<pre>new Ignitor(require('@adonisjs/fold'))
  .preLoad('start/redis')
  .appRoot(__dirname)</pre>
<p>现在我们将把我们的<code>REDIS_CONNECTION</code>添加到<code>.env</code>文件中，它将指向<code>config/redis.js</code>文件中的<code>local</code>配置。</p>
<pre>REDIS_CONNECTION=local</pre>
<p>完成后，我们将继续创建控制器、路由和模型，以便从数据库中获取数据，并使用 Redis 缓存数据。然后我们将在 Postman 中从 Redis 获取数据，以查看响应时间的差异。</p>
<h2>设置数据库</h2>
<p>拥有一个数据库是本教程的基础，所以让我们继续设置一个数据库。为此，我们将使用下面的代码在应用程序中安装<code>@adonisjs/lucid</code>包。Lucid 是一个用于 Adonis 的 SQL ORM，它以一种<a href="https://en.wikipedia.org/wiki/Active_record_pattern">活动记录模式</a>存储数据:</p>
<pre>adonis install @adonisjs/lucid</pre>
<p>安装完成后，我们可以向我们的<code>start/app.js</code>文件添加一个 Lucid 提供程序，这将把 Lucid 包添加到应用程序的提供程序列表中:</p>
<pre>const providers = [
  '@adonisjs/lucid/providers/LucidProvider'
]

const aceProviders = [
  '@adonisjs/lucid/providers/MigrationsProvider'
]</pre>
<p>完成后，我们使用下面的代码将<code>mysql</code>安装到我们的应用程序中:</p>
<pre>npm install mysql</pre>
<p>然后我们配置我们的<code>.env</code>文件，使用<code>mysql</code>配置连接到我们的数据库。这很重要，因为默认情况下，AdonisJs 使用 SQLite 进行数据存储。</p>
<pre>DB_CONNECTION=mysql
DB_USER=root
DB_PASSWORD=
DB_DATABASE=adonis_redis</pre>
<p>现在将<code>config/database.js</code>中的连接更改为 MySQL 连接:</p>
<pre>connection: Env.get('DB_CONNECTION', 'mysql'),</pre>
<h2>创建控制器</h2>
<p>我们将创建一个<code>User</code>控制器，从我们的数据库中获取所有用户。为此，我们使用下面的代码生成一个新的控制器:</p>
<pre>adonis make:controller User --type http</pre>
<p>然后，我们将我们的<code>database</code>包导入到我们的<code>UserController.js</code>文件中，以连接和访问数据库:</p>
<pre>// app/Controllers/UserController.js

const Database = use('Database')</pre>
<p>接下来，我们添加一个<code>async</code>函数，该函数将调用数据库并获取所有用户，然后将其作为 JSON 返回:</p>
<pre>// app/Controllers/UserController.js

async index({ response }) {
  let users = await Database.table('users').select('*');
  return response.status(201).json({
      status: true,
      message: 'fetched all users',
      data: users
  });
}</pre>
<h2>创建<code>users</code>路线</h2>
<p>设置好控制器后，我们现在可以配置路由，这样我们就可以对应用程序进行 API 调用。转到<code>start/routes.js</code>并添加:</p>
<pre>// start/routes.js

Route.get('users', 'UserController.index');</pre>
<p>我们创建了一个<code>users</code>路由，它调用了<code>User</code>控制器中的<code>index</code>函数。现在我们可以使用我们在<a href="https://www.postman.com/">邮递员</a>中的路线来获取我们所有的用户。</p>
<p><img data-attachment-id="33871" data-permalink="https://blog.logrocket.com/redis-adonisjs-data-caching/response-time-postman/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman.png" data-orig-size="730,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Response time using Postman" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman.png" decoding="async" class="aligncenter size-full wp-image-33871 jetpack-lazy-image" src="../Images/3a4c977a4c4fa3d2c09366ae15da2c39.png" alt="Response Time Using Postman" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman-300x160.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="33871" data-permalink="https://blog.logrocket.com/redis-adonisjs-data-caching/response-time-postman/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman.png" data-orig-size="730,390" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Response time using Postman" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman-300x160.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-33871" src="../Images/3a4c977a4c4fa3d2c09366ae15da2c39.png" alt="Response Time Using Postman" srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman-300x160.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-postman.png"/></noscript>
<p>这里的响应时间是 2.07 秒，这对于一个低流量的 web 应用程序来说是可以的。但是，当您运行一个高流量应用程序，同时有许多请求发生时，这使得应用程序的加载时间非常慢。</p>
<p>现在我们已经测试了使用 Redis 缓存数据的应用程序，让我们继续使用 Redis 来查看响应时间的巨大减少，这是使应用程序更快、更用户友好的关键。</p>
<h2>使用<code>get</code> / <code>set</code>方法</h2>
<p><code>get</code>方法从 Redis 获取一个键值并返回一个字符串。<code>set</code>方法保存一个带有字符串值的键，如果键值已经包含了一个字符串，那么它会覆盖这个键值。我们可以在我们的<code>app/Controllers/Http/UserController.js</code>文件中使用这些方法来缓存数据库中的用户:</p>
<pre>// app/controllers/Http/UserController.js

async index() {
  const cachedUsers = await Redis.get('users')
        if (cachedUsers) {
          return JSON.parse(cachedUsers)
        }

        const users = await Database.table('users').select('*');
        await Redis.set('users', JSON.stringify(users))
        return users
      }
}</pre>
<p>上面，我们从键<code>users</code>中获取一个值，如果它不为空，我们将把它作为 JSON 文件返回。如果它是空的，我们从数据库中获取数据，然后用数据库中的数据设置一个新的键。</p>
<h2>设置发布/订阅</h2>
<p>发布/订阅实现了消息传递系统，其中发送者(Redis 中称为发布者)发送消息，而接收者(订阅者)接收消息。</p>
<p>为了设置我们的发布/订阅，我们将在<code>start/redis.js</code>中创建一个订阅。sub 将直接连接到数据库，并在每次启动发布序列时将数据保存在 JSON 中。</p>
<p>首先，在<code>start/redis.js</code>中导入数据库和 Redis:</p>
<pre>const Database = use('Database')
const Redis = use('Redis')</pre>
<p>然后创建一个新的<code>subscribe</code>方法，从数据库中获取所有用户。<code>set</code>创建一个新的键<code>users</code>，它包含 JSON 格式的所有用户的值，并将其存储在 Redis 中。</p>
<pre>// start/redis.js

Redis.subscribe('users', async () =&gt; {
    let users = await Database.table('users').select('*');
    await Redis.set('users', JSON.stringify(users));
})</pre>
<p>现在，在我们的<code>User</code>控制器中，我们导入 Redis，检查是否已经创建了一个<code>users</code> JSON 文件，并返回该文件；否则，我们将访问数据库，获取所有用户，并发布响应。</p>
<pre>// app/Controller/Http/UserController.js

const Database = use('Database')
const Redis = use('Redis')

async index({ response }) {
        let cachedUsers = await Redis.get('users');
        if(cachedUsers) {
            let users = JSON.parse(cachedUsers);
            return response.status(201).json({
                status: true,
                message: 'fetched all users',
                data: users
            });
        }else {
            let users = await Database.table('users').select('*');
            Redis.publish('users', '');
            return response.status(201).json({
                status: true,
                message: 'fetched all users',
                data: users
            });
        }
    }</pre>
<p>现在在邮递员上运行你的<code><a href="http://127.0.0.1:3333/users" rel="nofollow">http://127.0.0.1:3333/users</a></code>。请注意响应时间的差异:</p>
<p><img data-attachment-id="33872" data-permalink="https://blog.logrocket.com/redis-adonisjs-data-caching/response-time-redis/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis.png" data-orig-size="730,388" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Response time using Redis" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis.png" decoding="async" class="aligncenter size-full wp-image-33872 jetpack-lazy-image" src="../Images/4cc1f899245c009926565ee66c7f29fb.png" alt="Response Time Using Redis" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis-300x159.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="33872" data-permalink="https://blog.logrocket.com/redis-adonisjs-data-caching/response-time-redis/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis.png" data-orig-size="730,388" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Response time using Redis" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis-300x159.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-33872" src="../Images/4cc1f899245c009926565ee66c7f29fb.png" alt="Response Time Using Redis" srcset="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis.png 730w, https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis-300x159.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/02/response-time-redis.png"/></noscript>
<p><span>请求/响应时间大幅缩短，从无 Redis 时的 2.07 秒缩短到有 Redis 时的 33 毫秒！</span></p>
<h2>结论</h2>
<p>在本教程中，我们已经能够创建一个新的 AdonisJs 应用程序并在其中安装 Redis。然后，我们配置 Redis 来缓存数据，配置我们的数据库，使用 Redis <code>get</code>、<code>set</code>、publish 和 subscribe 方法，并减少应用程序中的请求/响应时间。</p>
<p>您可以继续将<a href="https://github.com/Kennethekandem/adonis_redis_caching.git">库</a>克隆到您的系统中，并根据您的喜好进行调整。你必须复制<code>.env.example</code>文件并粘贴到<code>.env</code>中，然后使用<code>adonis key:generate</code>创建一个新的密钥。希望这篇教程对你有帮助。✌️</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
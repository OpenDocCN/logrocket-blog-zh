<html>
<head>
<title>The ultimate guide to GetX state management in Flutter - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Flutter - LogRocket 博客中的 GetX 状态管理终极指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/ultimate-guide-getx-state-management-flutter/#0001-01-01">https://blog.logrocket.com/ultimate-guide-getx-state-management-flutter/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当你按下家里电话总机的按钮时会发生什么？</p>
<p>您基本上是在将按钮的状态从关闭更改为打开，反之亦然。这触发了电流，要么打开灯泡，要么关闭灯泡。</p>
<p><img data-attachment-id="86253" data-permalink="https://blog.logrocket.com/ultimate-guide-getx-state-management-flutter/lightbulb-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/lightbulb.gif" data-orig-size="88,80" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Lightbulb" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/lightbulb.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/lightbulb.gif" decoding="async" class="aligncenter size-full wp-image-86253 jetpack-lazy-image" src="../Images/2107fcd4d41511b1c0e93fd1559540e7.png" alt="Lightbulb" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/01/lightbulb.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/lightbulb.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="86253" data-permalink="https://blog.logrocket.com/ultimate-guide-getx-state-management-flutter/lightbulb-2/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/01/lightbulb.gif" data-orig-size="88,80" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Lightbulb" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/01/lightbulb.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/01/lightbulb.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-86253" src="../Images/2107fcd4d41511b1c0e93fd1559540e7.png" alt="Lightbulb" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/01/lightbulb.gif"/></noscript>
<p>来源:<a href="https://www.animatedimages.org/img-animated-light-bulb-image-0025-98965.htm" target="_blank" rel="noopener">动画 images.org</a></p>
<p>从软件开发人员的角度考虑。当灯泡打开时，灯泡的 UI 从不发光状态变为发光状态。虽然物理上我们看不到灯泡被重新创建或重建，但如果在具有反应式状态管理的移动软件上出现这种情况，UI 将从头开始构建。</p>
<p>如果您来自 Android 或 iOS 框架，您需要从一个全新的角度开始考虑移动应用程序开发。Android 和 iOS 是命令式框架。另一方面，Flutter 是一个声明性框架。这意味着可以从头开始构建 UI，而不是修改它的一小部分，因为当小部件改变其状态时，Flutter 在重建 UI 方面很有效。</p>
<p>UI 编程的声明式风格有它自己的好处；你写一遍任何 UI 的代码，描述它在任何状态下应该是什么样子，就这样！然而，随着您深入钻研 Flutter 编程，有时您需要在整个应用程序的屏幕之间共享数据和状态。这时，您将需要一个优秀的状态管理库来帮助您快速高效地构建应用程序。</p>
<p>在 Flutter 中，状态管理是一个复杂的讨论话题。然而，许多状态管理库，如<a href="https://blog.logrocket.com/quick-guide-provider-flutter-state-management/" target="_blank" rel="noopener"> Provider </a>是可用的，这是大多数开发人员推荐的。</p>
<p>但是…</p>
<p>今天，我们将讨论一个用于 Flutter 应用程序开发的简化状态管理解决方案，它的大多数特性都不需要上下文，称为 GetX。</p>

<h2 id="what-is-getx">GetX 是什么？</h2>
<p>GetX 不仅是一个状态管理库，相反，它是一个结合了路由管理和依赖注入的微框架。它旨在为 Flutter 提供一个超级轻量级但功能强大的解决方案，提供顶级的开发体验。GetX 基于三个基本原则:</p>
<ol>
<li>性能:关注最低的内存和资源消耗</li>
<li>生产力:直观高效的工具与简单明了的语法相结合，最终节省了开发时间</li>
<li>组织:将业务逻辑从视图和表示逻辑中分离出来是再好不过的了。您不需要上下文来导航路由，也不需要有状态的小部件</li>
</ol>
<h2 id="the-three-pillars-of-getx">GetX 的三大支柱</h2>
<ol>
<li>状态管理:GetX 有两个状态管理器。一个是与<code>GetBuilder</code>功能一起使用的简单状态管理器，另一个是与<code>Getx</code>或<code>Obx</code>一起使用的反应式状态管理器。我们将在下面详细讨论它</li>
<li>路线管理:无论是在屏幕之间导航，显示<code>SnackBars</code>，弹出对话框，还是在不使用<code>context</code>的情况下添加底部表单，GetX 都可以满足您。我不会写路由管理的细节，因为这超出了本文的范围，但确实有几个例子可以让你了解 GetX 语法的简单性是如何工作的</li>
<li>依赖关系管理:GetX 为使用控制器的依赖关系管理提供了一个简单而强大的解决方案。只需一行代码，就可以从视图中访问它，而无需使用继承的小部件或上下文。通常，您会在一个类中实例化一个类，但是使用 GetX，您是用<code>Get</code>实例来实例化的，它将在整个应用程序中可用</li>
</ol>
<h2 id="value-added-features-of-getx">GetX 的增值功能</h2>
<p>GetX 有一些现成的优秀特性，使得在 Flutter 中开发移动应用程序变得更加容易，而不需要任何样板代码:</p>
<ol>
<li>国际化:带有键值映射的翻译，各种语言支持，使用带有单数、复数和参数的翻译。在整个应用程序中只使用<code>Get</code>单词来更改应用程序的区域设置</li>
<li>验证:电子邮件和密码验证也包含在 GetX 中。现在，您不需要安装单独的验证包</li>
<li>存储:GetX 还为完全用 Dart 编写的数据提供了快速和额外的轻量级同步键值内存备份，可以轻松地与 GetX 核心包集成</li>
<li>主题:使用 GetX，明暗主题之间的切换变得很简单</li>
<li>响应式视图(Responsive view):如果你正在构建一个不同屏幕尺寸的应用，你只需要用<code>GetView</code>进行扩展，你就可以快速开发你的 UI，它将对桌面、平板、手机、手表都有响应</li>
</ol>
<h2 id="lets-get-going-with-getx-state-management">让我们开始 GetX 状态管理</h2>
<p>我会一步一步地做这件事，这是我一直喜欢做的，我会尽量描述性地尽可能详细地解释这个过程。</p>
<h3 id="step-1-create-a-new-application">步骤 1:创建新的应用程序</h3>
<p>在您喜欢的 IDE 中创建一个全新的应用程序。首先，通过选择<strong>编辑</strong>菜单中的查找和替换选项，删除所有的起始注释，并键入以下内容:<code>\/\/.*</code>。这将在起始代码中选择 Flutter 的注释，你可以点击删除按钮。</p>
<h3 id="step-2-add-required-dependencies">步骤 2:添加所需的依赖项</h3>
<p>将这些依赖项添加到您的<code>pubspec.yaml</code>文件中:</p>
<pre class="language-yaml hljs">get: ^4.6.1           //YAML
get_storage: ^2.0.3  //YAML</pre>
<p>运行以下命令:</p>
<pre class="language-yaml hljs">flutter pub get  //YAML</pre>
<p>在进行第 3 步之前，让我解释一下我们在这里做什么。我创建了一个演示 GetX 核心功能的小应用程序。该应用程序是一个商店，用户可以:</p>
<ol>
<li>更改商店的名称</li>
<li>添加关注者姓名</li>
<li>添加追随者计数</li>
<li>将商店的状态从打开更改为关闭，反之亦然</li>
<li>向商店添加评论</li>
<li>将商店的主题由亮变暗</li>
</ol>
<p>以上都将解释<a href="https://blog.logrocket.com/flutter-state-management-methods/" target="_blank" rel="noopener">状态管理</a>，依赖关系管理，路由管理，存储，以及主题。</p>
<p>这里我们更关注状态和依赖性管理。路线、存储和主题只是为了应用程序的美观。</p>
<p>您可以通过这个链接阅读并<a href="https://getx-store.web.app/#/" target="_blank" rel="noopener">测试应用程序。</a></p>

<p>添加完依赖项后，您需要做的第一件事是将<code>main.dart</code>文件中的<code>MaterialApp</code>小部件更改为<code>GetMaterialApp</code>。这使得可以访问应用程序中的所有 GetX 属性。</p>
<h3 id="step-4-add-getx-controller">步骤 4:添加 GetX 控制器</h3>
<p>我们已经确定 GetX 将 UI 从业务逻辑中分离出来。这就是 GetX 控制器发挥作用的地方。</p>
<p>您总是可以在应用程序中创建多个控制器。当您用它的<code>Observer</code>包装一个单独的小部件时，GetX 控制器类控制 UI 的状态，以便它只在特定小部件的状态发生变化时才重建。</p>
<p>我们正在添加一个新的 Dart 文件来创建我们的控制器类<code>StoreController</code>，它扩展了<code>GetxController</code>:</p>
<pre class="language-dart hljs">class StoreController extends GetxController {}</pre>
<p>接下来，我们添加一些变量并用默认值初始化它们。</p>
<p>通常我们会像下面这样添加这些变量:</p>
<pre class="language-dart hljs">final storeName = 'Thick Shake';</pre>
<p>但是，在使用 GetX 时，我们必须通过在值的末尾添加<strong> <code>obs</code> </strong>来使变量可观测。然后，当变量发生变化时，依赖于它的应用程序的其他部分会得到通知。所以现在，我们的初始化值看起来像这样:</p>
<pre class="language-dart hljs">final storeName = 'Thick Shake'.obs;</pre>
<p>其余变量如下所示:</p>
<pre class="language-dart hljs">// String for changing the Store Name
final storeName = 'Thick Shake'.obs;
// int for increasing the Follower count
final followerCount = 0.obs;
// bool for showing the status of the Store open or close
final storeStatus = true.obs;
// List for names of Store Followers
final followerList = [].obs;
// Map for Names and their Reviews for the Store
final reviews = &lt;StoreReviews&gt;[].obs;
// text editing controllers
final storeNameEditingController  = TextEditingController();
final reviewEditingController = TextEditingController();
final followerController = TextEditingController();
final reviewNameController = TextEditingController();</pre>
<p>接下来，我们创建三种方法来更改名称、增加关注者数量和更改商店状态:</p>
<pre class="language-dart hljs">updateStoreName(String name) {
 storeName(name);
}

updateFollowerCount() {
 followerCount(followerCount.value + 1);
}

void storeStatusOpen(bool isOpen) {
 storeStatus(isOpen);
}</pre>
<h3 id="step-5-dependency-injection">步骤 5:依赖注入</h3>
<p>通俗地说，就是把刚刚创建的<code>controller</code>类加入到我们的<code>view</code>类中。有三种方法可以实例化。</p>
<ol>
<li>用<code>GetView</code>扩展整个<code>view</code>类，并用它注入我们的<code>StoreController</code>:<pre>class Home extends GetView&lt;StoreController&gt;{}</pre></li>
<li>实例化<code>storeController</code>如下:<pre>final storeController = Get.put(StoreContoller())</pre></li>
<li>对于选项三，首先创建一个新的<code>StoreBinding</code>类并实现<code>Bindings</code>。在它的默认依赖项中，您需要通过使用<code>Get.lazyPut()</code>来<code>lazyPut</code>这个<code>StoreController</code>。其次，你需要在<code>GetMaterialWidget</code>中的<code>initialBinding</code>属性内添加绑定类。</li>
</ol>
<p>最后，代替上面提到的<code>Get.Put</code>,现在你可以使用<code>Get.find</code>,当你在你的任何类中实例化时，GetX 会为你找到你的控制器:</p>
<pre class="language-dart hljs">class StoreBinding implements Bindings {
// default dependency
 @override
 void dependencies() {
   Get.lazyPut(() =&gt; StoreController();
 }
}</pre>
<pre class="language-dart hljs">@override
Widget build(BuildContext context) {
 return GetMaterialApp(
   debugShowCheckedModeBanner: false,
   title: 'GetX Store',
   initialBinding: StoreBinding(),
}</pre>
<pre class="language-dart hljs">class UpdateStoreName extends StatelessWidget {
 UpdateStoreName({Key? key}) : super(key: key);
//Getx will find your controller.
 final storeController = Get.find&lt;StoreController&gt;();</pre>
<p>项目中有很多代码和 Dart 文件。我只写我上面提到的三种方法。其余的代码将在 Git 上提供。链接将在本文末尾提供。其次，你也可以<a href="https://getx-store.web.app/#/" target="_blank" rel="noopener">通过一个网页链接</a>来尝试应用。</p>
<h3 id="step-6-instantiate-controller">步骤 6:实例化控制器</h3>
<p>因为我们已经用<code>GetView</code>扩展了我们的<code>Home</code>视图，并且创建了一个绑定类来<code>lazyPut</code>我们在其中的控制器，我们现在将使用<code>Get.find</code>在我们的类中实例化我们的控制器。</p>
<p>首先，我们添加一个新的无状态小部件<code>UpdateStoreName</code>。像这样实例化我们的<code>controller</code>类:</p>
<pre class="language-dart hljs">final storeController = Get.find&lt;StoreController&gt;();</pre>
<pre class="language-dart hljs">RoundedInput(
 hintText: "Store Name",
 controller: storeController.storeNameEditingController,
),
const SizedBox(height: 20),
ElevatedButton(
 onPressed: () {
   storeController.updateStoreName(
       storeController.storeNameEditingController.text);
   Get.snackbar(
       'Updated',
       'Store name has been updated ton '
           '${storeController.storeNameEditingController.text}',
       snackPosition: SnackPosition.BOTTOM);
 },
 child: const Padding(
   padding: EdgeInsets.all(10.0),
   child: Text(
     'Update',
     style: TextStyle(fontSize: 20.0),
   ),
 ),
),</pre>
<p>我来解释一下上面的代码:<code>RoundedInput</code>只是一个自定义的<code>TextField</code>，我们正在使用我们的<code>storeController</code>为<code>TextField</code>添加一个<code>TextEditingController</code>。我们也在<code>ElevatedButton</code>的<code>onPressed</code>中以同样的方式调用<code>updateStoreName()</code>方法。然后我们显示一个<code>SnackBar</code>，确认商店名称已经更新。</p>
<p>下面是<code>AddFollowerCount</code>和<code>StoreStatus</code>的代码。同样，两者都是无状态小部件，实现<code>storeController</code>和调用我们的控制器的方法是相似的:</p>
<pre class="language-dart hljs">class AddFollowerCount extends StatelessWidget {
 AddFollowerCount({Key? key}) : super(key: key);
 final storeController = Get.find&lt;StoreController&gt;();

 @override
 Widget build(BuildContext context) {
   return Scaffold(
     appBar: AppBar(title: const Text("Add Follower Count")),
     floatingActionButton: FloatingActionButton(
       onPressed: () {storeController.updateFollowerCount();
       },
       child: const Icon(Icons.add),
     ),
     body: Container(
       padding: const EdgeInsets.all(24),
       child: Center(
         child: Column(
           mainAxisAlignment: MainAxisAlignment.center,
           children: [
             const Text(
               'You have add these many followers to your store',
               textAlign: TextAlign.center,
               style: TextStyle(fontSize: 28),
             ),
             const SizedBox(
               height: 40.0,
             ),
             Obx(
               () =&gt; Text(
                 storeController.followerCount.value.toString(),
                 style: const TextStyle(fontSize: 48),
               ),
             )
           ],
         ),
       ),
     ),
   );
 }
}</pre>
<pre class="language-dart hljs">class StoreStatus extends StatelessWidget {
 StoreStatus({Key? key}) : super(key: key);
 //final storeController = Get.put(StoreController());
 final storeController = Get.find&lt;StoreController&gt;();

 @override
 Widget build(BuildContext context) {
   return Scaffold(
     appBar: AppBar(title: const Text("Test Status Toggle")),
     body: Container(
       padding: const EdgeInsets.all(24),
       child: Center(
         child: Column(
           mainAxisAlignment: MainAxisAlignment.center,
           children: [
             const Text(
               "Is the Store open?",
               style: TextStyle(fontSize: 22),
             ),
             const SizedBox(height: 16),
             Obx(
               () =&gt; Switch(
                 onChanged: (value) =&gt; storeController.storeStatus(value),
                 activeColor: Colors.green,
                 value: storeController.storeStatus.value,
               ),
             )
           ],
         ),
       ),
     ),
   );
 }
}</pre>

<p>现在，让我们进入使用我们的<code>storeController</code>显示我们商店名称的输入值、增加的追随者计数和商店状态的部分。</p>
<p>我们的<code>Home</code>视图是用<code>GetView&lt;StoreController&gt;</code>扩展的，所以我们不需要在这里实例化我们的<code>storeController</code>。相反，我们可以只使用 GetX 的默认控制器。请查看下面给出的代码，以获得清晰的图片，并了解第 6 步和第 7 步的区别。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自 LogRocket 的精彩文章:</h3>

<hr/></div>
<p>您一定已经注意到了，<code>Flexible</code>小部件中的<code>Text</code>小部件被一个<code>Obx</code>小部件包裹着，我们也称之为<code>controller</code>。还记得我们如何将<code>(.obs)</code>添加到变量中吗？现在，当我们想要看到可观察变量的变化时，我们必须用<code>Obx</code>包装小部件，也称为<code>Observer</code>，类似于您在上面的代码中已经注意到的。</p>
<p>当状态改变时，用<code>Obx</code>包装小部件只会重新构建特定的小部件，而不是整个类。这是多么简单:</p>
<pre class="language-dart hljs">class Home extends GetView&lt;StoreController&gt; {
 Home({Key? key}) : super(key: key);
 
 @override
 Widget build(BuildContext context) {
   return Scaffold(
     backgroundColor: AppColors.spaceCadet,
     appBar: AppBar(
       title: const Text("GetX Store"),),
     drawer: const SideDrawer(),
     body: Container(
       padding: const EdgeInsets.all(10),
       child: SingleChildScrollView(
         child: Column(
           children: [
             MainCard(
               title: "Store Info",
               body: Column(
                 crossAxisAlignment: CrossAxisAlignment.stretch,
                 children: [
                   Row(
                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
                     children: [
                       const Flexible(
                         child: Text('Store Name:',
                           style: TextStyle(fontSize: 20),),
                         fit: FlexFit.tight,),
                       const SizedBox(width: 20.0),
                   // Wrapped with Obx to observe changes to the storeName
                   // variable when called using the StoreController.
                       Obx(
                         () =&gt; Flexible(
                           child: Text(
                             controller.storeName.value.toString(),
                             style: const TextStyle(
                             fontSize: 22, fontWeight: FontWeight.bold) ),
                           fit: FlexFit.tight,
                         ),),
                     ],),
                   const SizedBox(height: 20.0),
                   Row(
                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
                     children: [
                       const Flexible(
                         child: Text('Store Followers:',
                           style: TextStyle(fontSize: 20),),
                         fit: FlexFit.tight, ),
                       const SizedBox(width: 20.0),
               // Wrapped with Obx to observe changes to the followerCount
               // variable when called using the StoreController.
                       Obx(
                         () =&gt; Flexible(
                           child: Text(
                             controller.followerCount.value.toString(),
                             textAlign: TextAlign.start,
                             style: const TextStyle(
                             fontSize: 22, fontWeight: FontWeight.bold),
                           ),
                           fit: FlexFit.tight,),), ],
                   ),
                   const SizedBox(height: 20.0),
                   Row(
                     mainAxisAlignment: MainAxisAlignment.spaceBetween,
                     children: [
                       const Flexible(
                         child: Text('Status:',
                           style: TextStyle(fontSize: 20),),
                         fit: FlexFit.tight,),
                       const SizedBox(width: 20.0),
                 // Wrapped with Obx to observe changes to the storeStatus
                 // variable when called using the StoreController.
                       Obx(
                         () =&gt; Flexible(
                           child: Text(
                        controller.storeStatus.value ? 'Open' : 'Closed',
                             textAlign: TextAlign.start,
                             style: TextStyle(
                                 color: controller.storeStatus.value
                                     ? Colors.green.shade700
                                     : Colors.red,
                                 fontSize: 22,
                                 fontWeight: FontWeight.bold),),
                           fit: FlexFit.tight,
                         ),  ),  ], ), ], ), ),</pre>
<p>我特意强调了<code>controllers</code>和<code>Obx</code>，以理解 Flutter 提供的默认有状态小部件和使用 GetX 管理视图或整个应用程序的状态之间的区别。</p>
<p>如果我们使用有状态的小部件，那么每当我们想要看到变化时，我们就必须使用<code>setState()</code>方法。我们还必须手动处理<code>controllers</code>。因此，我们避免所有的样板代码，只用<code>Obx</code>包装我们的小部件，剩下的就交给我们了。</p>
<p>如果我们必须总结以上所有内容，只需两步:</p>
<ol>
<li>将<code>obs</code>添加到变量中</li>
<li>用<code>Obx</code>包装您的 widget</li>
</ol>
<h4 id="an-alternative-method">另一种方法</h4>
<p>这并不是唯一的方法。例如，如果你让你的变量是可观察的，你也可以直接用<code>GetX&lt;StoreController&gt;</code>而不是<code>Obx</code>来包装小部件。但是，功能保持不变。这样，在调用<code>storeController</code>之前，您不需要实例化它。请看下面的代码:</p>
<pre class="language-dart hljs">// Wrapped with GetX&lt;StoreController&gt; to observe changes to the
//storeStatus variable when called using the StoreController.
GetX&lt;StoreController&gt;(
 builder: (sController) =&gt; Flexible(
   child: Text(
     sController.storeStatus.value ? 'Open' : 'Closed',
     textAlign: TextAlign.start,
     style: TextStyle(
         color: sController.storeStatus.value
             ? Colors.green.shade700
             : Colors.red,
         fontSize: 22,
         fontWeight: FontWeight.bold), ),
   fit: FlexFit.tight, ),),</pre>
<p><em>注意，我已经将<code>storeStatus</code>从<code>Obx</code>更改为<code>GetX&lt;StoreController&gt;</code>，它正在使用<code>building</code>功能中的<code>sController</code>。</em></p>
<p>用<code>Obx</code>或<code>GetX</code>包装小部件被称为反应式状态管理。</p>
<h4 id="simple-state-management">简单的状态管理</h4>
<p>让我们看一个简单状态管理的例子。首先，使用简单状态管理的好处是您不需要将您的<code>MaterialWidget</code>更改为<code>GetMaterialWidget</code>。其次，您可以将其他状态管理库与简单的状态管理结合起来。</p>
<p><em>注意，如果您不将<code>MaterialWidget</code> </em> <em>更改为<code>GetMaterialWidget</code>，您将无法使用其他 GetX 功能，如路线管理。</em></p>
<p>对于简单的状态管理:</p>
<ol>
<li>你需要使用<code>GetBuilder</code>功能</li>
<li>你不需要<code>observable</code>变量</li>
<li>您必须在您的方法中调用<code>update()</code>函数</li>
</ol>
<p>我在我们的<code>StoreController</code>中创建了一个新变量。但是这一次，我没有在变量的末尾加上<code>(obs)</code>。这意味着现在它是不可见的。</p>
<p>但是当商店数量增加时，我仍然需要更新我的视图，所以我必须在我新创建的方法中调用<code>update()</code>函数。检查下面的代码:</p>
<pre class="language-dart hljs">// variable is not observable
int storeFollowerCount = 0;

void incrementStoreFollowers() {
 storeFollowerCount++;
//update function needs to be called
 update();
}</pre>
<p>现在，在我们的<strong>主页</strong>视图中，我已经将<code>Obx</code>更改为<code>GetBuilder</code>到<code>Text</code>小部件，它显示了关注者数量:</p>
<pre class="language-dart hljs">GetBuilder&lt;StoreController&gt;(
 builder: (newController) =&gt; Flexible(
   child: Text(
     newController.storeFollowerCount.toString(),
     textAlign: TextAlign.start,
     style: const TextStyle(
         fontSize: 22, fontWeight: FontWeight.bold),
   ),
   fit: FlexFit.tight, ),),</pre>
<p>由于我们在<strong>主页</strong>视图中用<code>GetBuilder</code>包装了我们的追随者计数，我们还必须对<code>AddFollowerCount</code> Dart 文件进行修改。</p>
<ol>
<li>在<code>Fab</code>按钮的<code>onPressed</code>功能中添加这个:<pre class="language-dart hljs">storeController.incrementStoreFollowers();</pre><ol>
<li>用<code>GetBuilder</code>包装<code>Text</code>小部件，以便它显示关注者计数:<pre class="language-dart hljs">GetBuilder&lt;StoreController&gt;(  builder: (newController) =&gt; Text(    'With GetBuilder: ${newController.storeFollowerCount.toString()}',    textAlign: TextAlign.start,    style: const TextStyle(        fontSize: 22, fontWeight: FontWeight.bold), ),),</pre></li>
</ol>
</li>
</ol>
<p>使用<code>Obx</code>或<code>GetX</code>和使用<code>GetBuilder</code>还有一个区别。当使用<code>Obx</code>或<code>GetX</code>时，您需要在使用<code>StoreController</code>调用您的方法后添加值。但是在使用<code>GetBuilder</code>的时候，不需要给它添加一个 value 参数。请看下面的区别:</p>
<pre class="language-dart hljs">// value parameter to be added with Obx or GetX
controller.storeName.value.toString(),

// value parameter is not needed with GetBuilder
newController.storeFollowerCount.toString(),</pre>
<p>这就是 GetX 提供的不同状态管理。此外，正如我所承诺的，我正在写一些关于 GetX 包的路由管理和其他特性的内容。因此，需要一篇全新的文章来详细描述这一切。</p>
<h2 id="other-getx-features">其他 GetX 特性</h2>
<h3 id="route-management">路线管理</h3>
<p>传统上，当用户想通过点击按钮从一个屏幕切换到另一个屏幕时，代码应该是这样的:</p>
<pre class="language-dart hljs">Navigator.push(context, 
    MaterialPageRoute(builder: (context)=&gt; Home()));</pre>
<p>但是，对于 GetX，实际上只有两个词:</p>
<pre class="language-dart hljs">Get.to(Home());</pre>
<p>当您想要导航回上一个屏幕时:</p>
<pre class="language-dart hljs">Navigator.pop(context);</pre>
<p>使用 GetX 时，绝对不需要上下文:</p>
<pre class="language-dart hljs">Get.back();</pre>
<p>如果您打开了一个对话框或一个抽屉，并且想要在关闭抽屉或对话框时导航到另一个屏幕，有两种方法可以通过默认的颤动导航来实现:</p>
<ol>
<li>关闭抽屉或对话框，然后像这样导航:<pre class="language-dart hljs">Navigator.pop(context); Navigator.push(context,      MaterialPageRoute(builder: (context)=&gt; SecondScreen()));</pre></li>
<li>如果已经生成了命名路线:<pre>Navigator.popAndPushNamed(context, '/second');</pre></li>
</ol>
<p>使用 GetX，在关闭任何打开的对话框或抽屉时，生成命名路线和在屏幕间导航变得简单多了:</p>
<pre class="language-dart hljs">// for named routes
Get.toNamed('/second'),
// to close, then navigate to named route
Get.offAndToNamed('/second'),</pre>
<h3 id="value-added-features">增值功能</h3>
<ol>
<li>小吃吧<pre class="language-dart hljs">Get.snackbar(    'title',    'message',    snackPosition: SnackPosition.BOTTOM, colorText: Colors.white, backgroundColor: Colors.black, borderColor: Colors.white);</pre></li>
<li>对话框<pre>Get.defaultDialog(    radius: 10.0,    contentPadding: const EdgeInsets.all(20.0),    title: 'title',    middleText: 'content',    textConfirm: 'Okay',    confirm: OutlinedButton.icon(      onPressed: () =&gt; Get.back(),      icon: const Icon(        Icons.check,        color: Colors.blue,     ),      label: const Text('Okay',        style: TextStyle(color: Colors.blue),      ),   ),  cancel: OutlinedButton.icon(      onPressed: (){},      icon: Icon(),      label: Text(),),);</pre></li>
<li>底部板材<pre>Get.bottomSheet(    Container(  height: 150,  color: AppColors.spaceBlue,  child: Center(      child: Text(    'Count has reached ${obxCount.value.toString()}',    style: const TextStyle(fontSize: 28.0, color: Colors.white),  )), ));</pre></li>
</ol>
<p>查看上面的代码，您可以很容易地理解显示和定制 snackbars、对话框和底部表单是多么简单。</p>
<p>这只是冰山一角。使用 GetX 库可以做更多的事情。在我结束我的文章之前，最后一个例子是在光明和黑暗主题之间切换。</p>
<h3 id="switching-from-light-to-dark-themes-and-vice-versa">从亮主题切换到暗主题，反之亦然</h3>
<p>首先，我创建了一个类似于我们的<code>StoreController</code>的<code>ThemeController</code>。在我的控制器中，我使用<code>GetStorage</code>功能来保存切换后的主题:</p>
<pre class="language-dart hljs">class ThemeController extends GetxController {
  final _box = GetStorage();
  final _key = 'isDarkMode';

  ThemeMode get theme =&gt; _loadTheme() ? ThemeMode.dark : ThemeMode.light;
  bool _loadTheme() =&gt; _box.read(_key) ?? false;

  void saveTheme(bool isDarkMode) =&gt; _box.write(_key, isDarkMode);
  void changeTheme(ThemeData theme) =&gt; Get.changeTheme(theme);
  void changeThemeMode(ThemeMode themeMode) =&gt; Get.changeThemeMode(themeMode);
}</pre>
<p>在<code>GetMaterialApp</code>小部件中，我已经为<code>theme</code>和<code>darkTheme</code>添加了属性，并且初始化了<code>themeController </code>并将其添加到了<code>themeMode</code>属性中:</p>
<pre class="language-dart hljs">class MyApp extends StatelessWidget {
  MyApp({Key? key}) : super(key: key);
  final themeController = Get.put(ThemeController());

  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'GetX Store',
      initialBinding: StoreBinding(),
      theme: Themes.lightTheme,
      darkTheme: Themes.darkTheme,
      themeMode: themeController.theme,
}
}</pre>
<p>接下来，在我们的<strong>主页<code>appBar</code>的</strong>屏幕上，我添加了一个图标，可以在明暗之间切换主题。看看下面的代码就知道了:</p>
<pre class="language-dart hljs">class Home extends GetView&lt;StoreController&gt; {
 Home({Key? key}) : super(key: key);
 final themeController = Get.find&lt;ThemeController&gt;();

 @override
 Widget build(BuildContext context) {
   return Scaffold(backgroundColor: AppColors.spaceCadet,
     appBar: AppBar(title: const Text("GetX Store"),
       actions: [IconButton(
           onPressed: () {
             if (Get.isDarkMode) {
               themeController.changeTheme(Themes.lightTheme);
               themeController.saveTheme(false);
             } else {
               themeController.changeTheme(Themes.darkTheme);
               themeController.saveTheme(true); }},
           icon: Get.isDarkMode
               ? const Icon(Icons.light_mode_outlined)
               : const Icon(Icons.dark_mode_outlined),),], ),</pre>
<p>仅此而已。现在，您可以轻松地在亮暗主题之间切换。</p>
<h2 id="conclusion">结论</h2>
<p>看完整篇文章，你是否想知道这个库的创建者为什么给它起名叫 GetX？依我拙见，人们经常会下命令说:“把它做完！”或者“让我们完成它！”</p>
<p>然而，x 是一个未知变量，但在这种情况下，它真的是任何东西。</p>
<p>使用 GetX，您可以完成所有工作。</p>
<p>就这些了，谢谢你的阅读。如果您有任何建议、更正或反馈，请在下面留下评论。</p>
<p>我在下面留下了我在本文中解释过的应用程序源代码的链接，以及一个额外的基础计数器应用程序。您可以随意克隆 Git 存储库并自己试验代码。也有到 PWAs 的链接，可以在没有任何安装的情况下试用这个应用程序。</p>
<h3 id="links-to-the-source-code-on-github">GitHub 上的源代码链接</h3>
<p>GetX 商店链接:<a href="https://github.com/timelessfusionapps/getx_store" target="_blank" rel="noopener">https://github.com/timelessfusionapps/getx_store</a></p>
<p>GetX 专柜链接:<a href="https://github.com/timelessfusionapps/getx_counter" target="_blank" rel="noopener">https://github.com/timelessfusionapps/getx_counter</a></p>
<h3 id="links-to-the-web-app">web 应用程序的链接</h3>
<p>GetX 商店链接:<a href="https://getx-store.web.app/#/" target="_blank" rel="noopener">https://getx-store.web.app/#/</a></p>
<p>GetX 专柜 app:<a href="https://getx-counter.web.app/#/" target="_blank" rel="noopener">https://getx-counter.web.app/#/</a></p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>CI/CD pipelines using React, GitHub Actions, and Heroku - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>使用 React、GitHub 操作和 Heroku - LogRocket 博客的 CI/CD 管道</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/ci-cd-pipelines-react-github-actions-heroku/#0001-01-01">https://blog.logrocket.com/ci-cd-pipelines-react-github-actions-heroku/#0001-01-01</a></blockquote><div><article class="article-post">
<p>技术行业的创新速度很快，要求开发人员在快速交付产品和服务的同时，仍然优先考虑高质量。集成和交付曾经是一个手动过程，但自动化使它变得更快、更可靠。</p>
<p>在本文中，我们将探索持续集成和持续交付或部署。CI/CD 自动交付我们的产品和功能，使其更快，并帮助我们保持高质量。有几个工具可以用来设置 CI/CD 管道，但是，在本文中，我们将设置 GitHub 操作，使用 Heroku 作为我们的云托管服务，使用 GitHub 托管我们的存储库。</p>
<p>在本教程中，我们将使用以下工具:Git、GitHub、GitHub Actions、Heroku、React、<a href="https://app.diagrams.net/" target="_blank" rel="noopener"> Draw.io </a>和<a href="https://swimlanes.io/" target="_blank" rel="noopener"> Swimlanes.io </a>。你可以在我的<a href="https://github.com/zafar-saleem/github-actions-heroku" target="_blank" rel="noopener"> GitHub 档案</a>上访问这个项目的资源库。我们开始吧！</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/32c24d10fae12c8f08ca7f3522280b8c.png" alt="CID Pipeline Github Action Heroku" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/ci-cd-pipeline-github-action-heroku.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/ci-cd-pipeline-github-action-heroku.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/32c24d10fae12c8f08ca7f3522280b8c.png" alt="CID Pipeline Github Action Heroku" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/ci-cd-pipeline-github-action-heroku.png"/></noscript><figcaption class="wp-caption-text">CI/CD Pipeline using Github Actions and Heroku.</figcaption></figure>
<p><strong> <em> CI/CD 管道使用 Github 动作和 Heroku</em>T3】</strong></p>
<p>目录</p>

<h1 id="fundamentals-cicd">CI/CD 基础</h1>
<p>CI/CD 有三个重要的术语，我们需要在进入代码之前理解它们。</p>
<h2 id="continuous-integration">连续累计</h2>
<p>持续集成是工程师和开发人员的自动化过程，允许我们测试代码中的新功能，确保它们按预期工作。</p>
<h2 id="continuous-delivery">连续交货</h2>
<p>接下来是连续交付，确保新的变更经过良好的测试，没有错误，并准备好部署到生产环境中。</p>
<h2 id="continuous-deployment">持续部署</h2>
<p>在持续部署阶段，对应用程序的更改通过合并到特定的分支(如<code>main</code>)来部署到生产环境中。</p>
<p>下面的示例图详细描述了 CI/CD 流程:</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/64988006fc73255fc14aecfd133c8a13.png" alt="CICD Process Flow Diagram" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/ci-cd-process-flow-diagram.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/ci-cd-process-flow-diagram.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/64988006fc73255fc14aecfd133c8a13.png" alt="CICD Process Flow Diagram" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/ci-cd-process-flow-diagram.png"/></noscript><figcaption class="wp-caption-text">CI/CD.</figcaption></figure>
<h1 id="git-and-cicd-strategy">Git 和 CI/CD 战略</h1>
<p>让我们为我们的示例应用程序设置 CI/CD 策略。我们将有一个 GitHub 存储库，它有两个分支，<code>main</code>和<code>develop</code>。我们还将从<code>develop</code>分支创建一个新的<code>feature</code>分支，在那里我们将开发一个新的特性，并将这些变化推送到它自己的特性中。然后，我们将针对 GitHub 上的<code>develop</code>分支创建一个拉请求。</p>
<p>我们还将有两个 CI/CD <code>yml</code>文件用于配置，<code>development</code>和<code>production</code>。当我们成功地将一个拉请求合并到<code>develop</code>分支时，设置<code>development</code>文件来触发 CI/CD 管道，并将我们的更改部署到 Heroku 开发环境中。</p>
<p>当我们从<code>develop</code>分支提取最新的变更，将<code>develop</code>合并到<code>main</code>，并最终将这些变更推送到远程<code>main</code>分支时，<code>production.yml</code>文件被设置为触发 Heroku 上生产环境的 CI/CD 管道。</p>
<p>下图详细描述了这一策略:</p>
<figure class="wp-caption aligncenter"><img decoding="async" src="../Images/475ced93cde89779b0e3bf24c59f550c.png" alt="Github Actions CICD Diagram" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/github-actions-ci-cd-diagram.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" class=" jetpack-lazy-image" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/github-actions-ci-cd-diagram.png"/><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" src="../Images/475ced93cde89779b0e3bf24c59f550c.png" alt="Github Actions CICD Diagram" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/github-actions-ci-cd-diagram.png"/></noscript><figcaption class="wp-caption-text">Git and CI/CD Strategy.</figcaption></figure>
<h2 id="create-new-react-project">创建新的 React 项目</h2>
<p>首先，我们必须建立一个简单的 React 项目。运行下面的命令，在您的<code>projects</code>文件夹中创建一个 React 项目:</p>
<pre class="language-bash hljs">npx create-react-app github-actions-heroku
</pre>
<p>上面的命令将生成一个 React 项目并安装所有需要的依赖项。下面是我们将使用的一些依赖项及其在撰写本文时的当前版本:</p>
<pre class="language-text hljs">react 17.0.2
react-dom 17.0.2
react-scripts 5.0.0
node 17.2.0
</pre>
<h2 id="set-up-heroku">建立 Heroku</h2>
<p>我们将建立两个环境，一个用于开发，另一个作为生产环境。继续在<a href="https://www.heroku.com/" target="_blank" rel="noopener">Heroku.com</a>登录您的 Heroku 账户。我在这篇博文中使用了我的免费帐户:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/d4260df4a5210857c3800d04cef9809d.png" alt="Heroku Account Setup" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-account-setup.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-account-setup.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/d4260df4a5210857c3800d04cef9809d.png" alt="Heroku Account Setup" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-account-setup.png"/></noscript>
<p>登录后，只需点击<strong>新</strong>按钮，如下所示:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/b5f6c4c0adc4edc8c836d6ce98a6d4b7.png" alt="Heroku New Project Button" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-new-project-button.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-new-project-button.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/b5f6c4c0adc4edc8c836d6ce98a6d4b7.png" alt="Heroku New Project Button" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-new-project-button.png"/></noscript>
<p>然后，点击下拉菜单中的<strong>创建新应用</strong>。继续给你的应用命名。我在调用我的<code>github-actions-heroku-develop</code>，如下图。</p>
<p>因为我已经用这个名称创建了一个项目，所以它在我的帐户上显示为不可用。但是，您应该继续操作，点击<strong>创建应用</strong>，将会为您创建一个开发环境:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/953bbcbea60cc174144ebc578b1ec08e.png" alt="Name New Project Heroku" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/name-new-project-heroku.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/name-new-project-heroku.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/953bbcbea60cc174144ebc578b1ec08e.png" alt="Name New Project Heroku" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/name-new-project-heroku.png"/></noscript>
<p>我们将把一个拉请求合并到<code>develop</code>分支，然后我们的应用程序将被部署到这个环境中。</p>
<p>现在，让我们重复相同的过程来创建一个新的应用程序，我们将其命名为<code>github-actions-heroku-prod</code>。当我们将<code>develop</code>分支合并到<code>main</code>中，并将这些变更推送到远程<code>main</code>分支时，这些变更将被部署到这个环境中。</p>
<p>设置好 Heroku 环境后，我们应该继续点击 Heroku 仪表盘上的<strong>个人资料图片</strong> <strong>图标</strong>，然后点击<strong>账户</strong> <strong>设置</strong>，如下所示:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/05517abab65ddb37e75764d8798bda79.png" alt="Heroku Account Settings" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-account-settings.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-account-settings.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/05517abab65ddb37e75764d8798bda79.png" alt="Heroku Account Settings" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-account-settings.png"/></noscript>
<p>现在，向下滚动到<strong> API 密钥</strong>部分以显示 API 密钥。将它复制并粘贴到某个安全的地方，因为我们在建立 GitHub 存储库时会用到它:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/31742b64674f87138aeb660de3032825.png" alt="Heroku API Key" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-api-key.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-api-key.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/31742b64674f87138aeb660de3032825.png" alt="Heroku API Key" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/heroku-api-key.png"/></noscript>
<h2 id="browserless-heroku-cli-authorization">无浏览器 Heroku CLI 授权</h2>
<p>您还可以使用 Heroku CLI 直接从命令行生成新的授权密钥。为此，请确保您的本地机器上安装了<a href="https://devcenter.heroku.com/articles/heroku-cli#install-the-heroku-cli" target="_blank" rel="noopener"> heroku-cli </a>。另外，如果您还没有这样做，请在 heroku-cli 上验证您的 Heroku 帐户。首先，登录，像这样:</p>
<pre>heroku login -i
</pre>
<p>输入您的凭据并成功登录后，您可以使用以下命令生成新令牌:</p>
<pre>heroku authorizations:create
</pre>
<p>这将立即建立一个新的 OAuth 通道和一个 OAuth 令牌，我们可以用它来代替我们之前从 Heroku 帐户中复制的令牌。</p>
<p>现在我们已经完成了 Heroku 的设置，让我们继续设置 GitHub repo。</p>
<h2 id="set-up-github-repository">设置 GitHub 存储库</h2>
<p>继续登录您的 GitHub 帐户。点击右上角的<strong> +符号</strong> <strong>，然后点击<strong>新增</strong> <strong>储存库</strong>:</strong></p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/d24fa53433ae65a58231537638eabfde.png" alt="New GitHub Repository" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/new-github-repository.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/new-github-repository.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/d24fa53433ae65a58231537638eabfde.png" alt="New GitHub Repository" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/new-github-repository.png"/></noscript>
<p>按如下方式填写表格:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/f2b5dbd158c71ce2249d0d8ee52278b0.png" alt="Register New GitHub Repository Form" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/register-new-github-repository-form.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/register-new-github-repository-form.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/f2b5dbd158c71ce2249d0d8ee52278b0.png" alt="Register New GitHub Repository Form" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/register-new-github-repository-form.png"/></noscript>
<p>在上面的截图中，项目名称<code>github-actions-heroku</code>不可用，因为我已经为本文构建了一个同名的项目。因此，我将使用我已经创建的那个。但是，您应该继续创建项目。</p>
<p>一旦你在 GitHub 上创建了一个项目，你会看到如下所示的屏幕:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/8a049d19be5104f928f816e0997a5c68.png" alt="New GitHub Project Output" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/new-github-project-output.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/new-github-project-output.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/8a049d19be5104f928f816e0997a5c68.png" alt="New GitHub Project Output" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/new-github-project-output.png"/></noscript>
<p>现在，您可以保留这个屏幕。我们一会儿将回到这个话题。回到您的本地环境终端，进入您之前创建的本地项目:</p>
<pre>cd github-actions-heroku
</pre>
<p>首先，从项目中删除<code>.git</code>文件夹，如下所示:</p>
<pre>rm -rf .git
</pre>
<p>然后，将这个 repo 初始化为一个 Git 项目:</p>
<pre>git init
</pre>
<p>上面的命令会自动创建一个<code>main</code>分支。接下来，用下面的命令创建一个名为<code>develop</code>的新分支:</p>
<pre>git checkout -b develop
</pre>
<p>现在，回到<code>main</code>分支:</p>
<pre>git checkout main
</pre>
<p>使用以下命令将 GitHub repo 添加到本地 repo 中:</p>
<pre>git remote add origin <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1a7d736e5a7d736e726f7834797577">[email protected]</a>:zafar-saleem/github-actions-heroku.git
</pre>
<p>下一阶段，提交您的更改，并将其推送到远程<code>main</code>分支:</p>
<pre>git add -A
git commit -m "Initial commit"
git push origin main
</pre>
<p>现在，我们来看看<code>develop</code>分支:</p>
<pre>git checkout develop
</pre>
<p>最后，我们将把更改推送到远程<code>develop</code>分支:</p>
<p>现在，让我们回到我们在<code>github-actions-heroku</code>上的项目，点击<strong>设置</strong> &gt; <strong>秘密</strong> &gt; <strong>新存储库秘密</strong>，如下所示:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/836b32aef1132dff1e10f272c95a5ff8.png" alt="New Github Repository Secret" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/new-github-repository-secret.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/new-github-repository-secret.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/836b32aef1132dff1e10f272c95a5ff8.png" alt="New Github Repository Secret" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/new-github-repository-secret.png"/></noscript>
<p>一旦您点击<strong>新存储库密码</strong>，您将看到以下屏幕:</p>
<p><img decoding="async" class="aligncenter jetpack-lazy-image" src="../Images/2b6209da191182229d665a54e18c1b46.png" alt="GitHub New Repository Secret Screen" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/02/github-new-repository-secret-screen.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/github-new-repository-secret-screen.png"/></p><noscript><img data-lazy-fallback="1" decoding="async" loading="lazy" class="aligncenter" src="../Images/2b6209da191182229d665a54e18c1b46.png" alt="GitHub New Repository Secret Screen" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/02/github-new-repository-secret-screen.png"/></noscript>
<p>如上所示，相应地命名您的秘密，并粘贴您之前复制的 Heroku API 密钥。然后，点击<strong>添加秘密</strong>。现在，我们已经完成了 GitHub 和本地回购。</p>
<h2 id="set-up-github-actions">设置 GitHub 操作</h2>
<p>现在，在你喜欢的编辑器中打开<code>github-actions-heroku</code>；我用的是崇高的文字。在项目的根目录下创建一个名为<code>.github</code>的文件夹。在<code>.github</code>中，创建一个名为<code>workflows</code>的新文件夹。</p>
<p>在<code>workflows</code>文件夹中，创建一个名为<code>development.yml</code>的文件，并将下面的代码粘贴到其中:</p>
<pre>name: Development workflow

on:
  push:
    branches:
      - develop

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Development Code
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="16757e73757d796362566024">[email protected]</a>
      - name: Use Node.js 17.x
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3043554445401d5e5f5455704601">[email protected]</a>
        with:
          node-version: 17.x
      - run: npm install
      - run: npm run build --if-present
      - name: Deploy to Heroku
        uses: akhileshns/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c9a1acbba6a2bce4adacb9a5a6b089bffae7f8fbe7f8fb">[email protected]</a>
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: 'github-actions-heroku-develop'
          heroku_email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="add7cccbccdfdeccc1c8c8c09eedcac0ccc4c183cec2c0">[email protected]</a>'
</pre>
<p>这个文件的顶部是一个开发工作流。每当我们向<code>develop</code>分支推送任何更改或合并一个拉取请求时，线路<code>6</code>上的管道将被自动触发。我们用的是<code>latest ubuntu</code>机器。</p>
<p>在第<code>25</code>行，我们使用的是来自 GitHub secrets 的<code>heroku_api_key</code>，这是我们之前设置的。第<code>26</code>行的 Heroku 应用程序名称应该与我们之前设置的 Heroku 环境相同。</p>
<p>现在，我们完成了<code>development.yml</code>。让我们在<code>workflows</code>文件夹中创建一个名为<code>production.yml</code>的新文件，并将以下内容粘贴到其中:</p>
<pre>name: Production workflow

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e5868d80868e8a9091a593d7">[email protected]</a>
      - name: Use Node.js 17.x
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4a392f3e3f3a6724252e2f0a3c7b">[email protected]</a>
        with:
          node-version: 17.x
      - run: npm install
      - run: npm run build --if-present
      - name: Deploy to Heroku
        uses: akhileshns/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cba3aeb9a4a0bee6afaebba7a4b28bbdf8e5faf9e5faf9">[email protected]</a>
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: 'github-actions-heroku-prod'
          heroku_email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e3998285829190828f86868ed0a3848e828a8fcd808c8e">[email protected]</a>'
</pre>
<p>上面的代码是用于生产的，每当我们对主回购进行新的更改时就会被触发。</p>
<h2 id="testing">测试</h2>
<p>为了测试我们的工作流是否如预期的那样工作，我们将首先确保我们在本地项目的<code>develop</code>分支上:</p>
<pre>git checkout -b feature/branch // creates a feature branch from develop branch
// make changes to App.js file.
git commit -am "minor changes"
git push origin feature/branch
</pre>
<p>在 GitHub 上，针对<code>develop</code>分支创建一个 pull 请求。合并这个 pull 请求，它应该会触发 GitHub 项目的<code>Actions</code>选项卡中的开发管道。让它结束，然后按照下面的步骤:</p>
<pre>git checkout develop
git pull origin develop
git checkout main
git merge develop
git push origin main
</pre>
<p>要查看被触发的<code>production</code>管道，请转到您的 GitHub 项目并点击<strong>动作</strong>选项卡。一旦两者都成功完成并部署，您就可以继续前进到 Heroku 并测试部署的最新变更。</p>
<h2 id="alternate-deployment-via-dockerfile">通过 Dockerfile 进行备用部署</h2>
<p>我们还能够通过 Docker 容器进行部署，这个过程非常简单。为此，我们需要在 docker 文件的末尾添加一个新的<code>CMD</code>命令。Heroku 将使用这个命令在容器中启动一个 web 服务器。然后，我们将把<code>usedocker</code>作为新的先决条件添加到 GitHub 工作流文件中。</p>
<p>有了这个新增加的内容，我们的<code>production.yml</code>文件看起来会像这样:</p>
<pre>name: Production workflow
on:
  push:
    branches:
      - main
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7f1c171a1c14100a0b3f094d">[email protected]</a>
      - name: Use Node.js 17.x
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1063756465603d7e7f7475506621">[email protected]</a>
        with:
          node-version: 17.x
      - run: npm install
      - run: npm run build --if-present
      - name: Deploy to Heroku
        uses: akhileshns/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="412924332e2a346c2524312d2e380137726f70736f7073">[email protected]</a>
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: 'github-actions-heroku-prod'
          heroku_email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="83f9e2e5e2f1f0e2efe6e6eeb0c3e4eee2eaefade0ecee">[email protected]</a>'
          usedocker: true
</pre>
<p>在部署之前，仔细检查一下<code>usedocker</code>指令是否已经附加到了<code>development.yml</code>文件中。</p>
<p>此外，如果您想向 Docker 构建指令传递额外的参数，您可以提供一个从环境中自动提取的<code>arg</code>名称列表:</p>
<pre>name: Production workflow
on:
  push:
    branches:
      - main
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="74171c11171f1b0100340246">[email protected]</a>
      - name: Use Node.js 17.x
        uses: actions/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="abd8cedfdedb86c5c4cfceebdd9a">[email protected]</a>
        with:
          node-version: 17.x
      - run: npm install
      - run: npm run build --if-present
      - name: Deploy to Heroku
        uses: akhileshns/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b8d0ddcad7d3cd95dcddc8d4d7c1f8ce8b96898a96898a">[email protected]</a>
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: 'github-actions-heroku-prod'
          heroku_email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="512b3037302322303d34343c6211363c30383d7f323e3c">[email protected]</a>'
          usedocker: true
          docker_build_args: |
            SECRET_KEY
            FOO
        env:
          SECRET_KEY: ${{ secrets.MY_SECRET_KEY }}
          FOO: ${{ secrets.BAR }}
</pre>
<p>一切都应该按预期运行！</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们用 React、GitHub actions 和 Heroku 介绍了 CI/CD。我们还回顾了使用 Dockerfile 文件的替代部署。通过自动化集成和交付，我们可以提高将应用程序部署到生产环境的速度和准确性。我希望你喜欢这篇文章。编码快乐！</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720"><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产 React 应用</h2><p>调试 React 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪 Redux 状态、自动显示 JavaScript 错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>. </p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的 web 和移动产品体验。这对你来说意味着什么？</p>
<p>LogRocket 不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p vwo-el-id="28675660750">LogRocket Redux 中间件包为您的用户会话增加了一层额外的可见性。LogRocket 记录 Redux 存储中的所有操作和状态。</p>
<p vwo-el-id="28675661060">现代化您调试 React 应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
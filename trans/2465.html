<html>
<head>
<title>Configuring the Go HTTP client - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>配置 Go HTTP 客户端- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/configuring-the-go-http-client/#0001-01-01">https://blog.logrocket.com/configuring-the-go-http-client/#0001-01-01</a></blockquote><div><article class="article-post">
<p>当构建与外部服务/产品通信的应用程序时，我们需要一种通用的方法来在两端建立可理解的连接。我们使用 API 来简化和建立客户机和服务器之间的通信。</p>
<p>在本教程中，我们将向您展示如何配置和建立客户端与服务器之间的连接，并向其他项目公开的端点发出 HTTP 请求，以便为我们的应用程序提供资源。向 API 发出请求调用意味着根据 API 的精确文档向 web 服务器发出 HTTP(s)请求。</p>
<p>客户端是通过 HTTP 协议以 URL 的形式向 web 服务器请求特定服务或数据并接收响应的主机(例如，浏览器)。服务器是一台远程计算机，它接受和处理请求，并使用 HTTP/HTTPS 协议发送适当的响应数据。</p>
<h2 id="golanghttpclient">Golang HTTP 客户端</h2>
<p>Go 标准库在<a href="https://pkg.go.dev/net/http" target="_blank" rel="noopener"> <code>net/http</code> </a>包中为 HTTP 客户端提供了出色的支持。在本指南中，我们将探索 Go 程序向外部资源发出 HTTP/HTTPS 请求所需的所有配置。</p>
<p>我们将使用来自<code>net/http</code>库的标准 Go 客户端，通过简单地创建一个类型为<code>http.Client</code>的变量来初始化一个 HTTP 客户端。</p>
<pre class="language-go hljs">// go/src/http-client/main.go
package main
import (
  "fmt"
  "io/ioutil"
  "net/http"
  "time"
)
func main() {
    c := http.Client{Timeout: time.Duration(1) * time.Second}
    resp, err := c.Get("https://go.dev/")
    if err != nil {
        fmt.Printf("Error %s", err)
        return
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)

    if err != nil {
      fmt.Printf("Error %s", err)
      return
    }

    fmt.Printf("Body : %s", body)
}
</pre>
<p>创建 HTTP 客户端时，我们可以指定并传递某些字段来配置客户端-服务器连接。</p>
<p>在上面的代码片段中，我们指定了一个类型为<code>time.Duration</code>的<code>Timeout</code>字段。当客户端通过 HTTP 打开与服务器的连接时，服务器可能需要一些时间来响应请求。此字段使我们能够指定从服务器获得响应的最长等待时间。</p>
<p>我们可以在<code>http.Client</code>中指定其他字段:</p>
<ul>
<li><code>Transport</code> (type <code>http.RoundTripper</code> ) —这定制了在我们的程序中处理和执行 HTTP 请求的过程</li>
<li><code>CheckedRedirect</code> (type <code>func(req *Request, via []*Request)</code> ) —在请求重定向的情况下，我们可以使用该字段在程序中定义一个函数来处理请求重定向的情况</li>
<li><code>Jar</code>(类型<code>CookieJar</code> ) —我们可以使用这个字段向 HTTP 请求添加 cookies</li>
</ul>
<p>在上面的代码中，我们用<code>DefaultTransport</code>定义了 HTTP 客户端，没有<code>CheckRedirect</code>函数，没有 cookies，超时设置为一秒。</p>
<h2 id="getandpostrequests">获取和发布请求</h2>
<p>在前面的代码块中，我们定义了一个对 URL<code><a href="https://go.dev/" rel="nofollow">https://go.dev/</a></code>的 GET 请求。我们向 web 服务器发出一个请求，并将响应和一个可能的错误值分别赋给变量<code>resp</code>和<code>err</code>。</p>
<pre class="language-go hljs">...
  resp, err := c.Get("https://go.dev/")

  if err != nil {
    fmt.Printf("Error %s", err)
    return
  }
...
</pre>
<p>上面的代码片段类似于向 URL 发出 POST 请求的代码。但是在这种情况下，我们需要在发送给 web 服务器的请求体中，将发送的数据与 POST 请求一起附加。</p>
<pre class="language-go hljs">...
  postData := bytes.NewBuffer([]byte(`{"post":"boom boom library"}`))
  resp, err := c.Post("https://go.dev/", "application/json", postData)

  if err != nil {
    fmt.Printf("Error %s", err)
    return
  }
...
</pre>
<p>在上面的代码片段中，我们创建了一个新变量，<code>postData</code> (type <code>*bytes.Buffer</code>)来保存我们希望随请求一起发送的数据。然后，在<code>c.Post</code>函数中，我们将<code>postData</code>作为参数与数据的 URL 和内容类型一起传递。</p>
<p>为什么不简单地放一个 JSON 字符串作为<code>postData</code>？那是因为这个参数必须实现接口<code>io.Reader</code>。</p>
<p>现在我们已经看到了如何发出 GET 或 POST 请求，让我们快速地看看如何从<code>resp</code>中检索响应:</p>
<pre class="language-go hljs">...
  defer resp.Body.Close()
  body, err := ioutil.ReadAll(resp.Body)

  if err != nil {
    fmt.Printf("Error %s", err)
    return
  }

  fmt.Printf("Body : %s", body)
...
</pre>
<p>使用<code>defer</code>关键字，我们安排了一个对<code>resp.Body.Close</code>的函数调用来关闭<code>resp.Body</code>，这是函数返回时从请求返回的数据流。这是程序的必要部分，以避免潜在的与服务器的持久连接。</p>

<p>让我们为我们希望向服务器发出的每种类型的请求构建方法。这可能会涉及更多的代码，但它给了我们拥有自己代码的灵活性。然后，我们可以轻松地在请求旁边附加我们想要的头。</p>
<pre class="language-go hljs">// go/src/http-client/main.go
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "time"
)

func main() {

  c := http.Client{Timeout: time.Duration(1) * time.Second}
  req, err := http.NewRequest("GET", "https://go.dev/", nil)
  if err != nil {
    fmt.Printf("error %s", err)
    return
  }
  req.Header.Add("Accept", `application/json`)

  resp, err := c.Do(req)
  if err != nil {
    fmt.Printf("Error %s", err)
    return
  }

  defer resp.Body.Close()
  body, err := ioutil.ReadAll(resp.Body)
  if err != nil {
    fmt.Printf("Error %s", err)
    return
  }

  fmt.Printf("Body : %s", body)
}
</pre>
<p>在上面的代码中，我们创建了一个客户端，然后使用<code>http.NewRequest</code>方法定义了一个新的请求。通过参数，我们指定了我们想要的请求类型。</p>
<p><code>http.Request</code>有一个如下所示的函数签名:</p>
<pre class="language-go hljs">(method, url string, body io.Reader) (*Request, error)
</pre>
<p>使用第一个参数，我们指定请求的方法。然后，我们在第二个参数中指定 URL 和保存数据的<code>body</code>——或者在 GET 请求的情况下指定<code>nil</code>,因为我们没有要发送的主体。</p>
<p>接下来，我们定义希望追加到请求的<code>Header</code>，如下所示:</p>
<pre class="language-go hljs">req.Header.Add("Accept", `application/json`)
</pre>
<p>我们使用<code>Header</code>字段向服务器添加和传输关于请求的附加信息层。HTTP 1/1 的规范提供了几个<code>Header</code>字段:</p>
<ul>
<li><code>Content-Length</code>是发送的消息的大小(以字节为单位)。如果未指定，默认值为<code>2</code></li>
<li><code>User-Agent</code>是发送请求的程序的名称和版本。例如，<code>curl/7.16.3</code>如果我们使用 curl 来发出请求。如果未指定，默认值为<code>Go-http-client/1.1</code></li>
<li><code>Authorization</code>提供成功请求所需的凭证。凭证可以包括 API 密钥、用户名/密码、JWT 等</li>
<li><code>Accept-Encoding</code>指定响应中可接受的编码类型。如果未指定，默认值为<code>gzip</code></li>
<li><code>Content-Type</code>告诉服务器在请求中将传输什么类型的媒体。如果未指定，默认值为<code>application/json</code></li>
<li><code>Accept</code>指定响应可接受的媒体类型。</li>
</ul>
<p>请求的<code>Header</code>字段实现了类型<code>map\[string\][]string</code>，其中键是字符串，值是字符串的片段。</p>
<h2 id="authorizingyourrequests">授权您的请求</h2>
<p>HTTP <code>Authorization</code>请求头可以提供服务器用来认证用户的凭证，从而允许访问受保护的资源。</p>
<pre class="language-go hljs">...
req, err = http.NewRequest("GET", "https://www.xxxx.xxx", nil)
req.Header.Add("Accept", `application/json`)
req.Header.Add("Authorization", fmt.Sprintf("token %s", os.Getenv("TOKEN"))
...
</pre>
<p>在上面的代码片段中，我们使用程序中的<code>os</code>包检索了访问令牌。这比直接访问令牌要好。<code>Getenv</code>方法检索名为<code>TOKEN</code>的环境变量并解析它。</p>
<p>我们还可以在我们的<code>go</code>命令前面加上<code>GITHUB_TOKEN=XXX</code>，以便在运行程序之前将一个环境变量传递给程序，如下所示:</p>
<pre class="language-go hljs">$ GITHUB_TOKEN=xxxxx go run main.go
</pre>
<h2 id="conclusion">结论</h2>
<p>在本教程中，我们通过一个简单的过程来配置您的 HTTP 客户端。现在，您可以开始从应用程序向外部资源发出 API 请求。</p>
<p>可以用更多的方法修改<code>http.NewRequest</code>，比如<code>HEAD</code>、<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>等。，然后在必要时向函数传递一个主体参数，或者在不需要主体时传递<code>nil</code>。一旦响应被我们的程序检索到/可用，我们就可以根据用例在我们的项目中使用它。</p><div class="code-block code-block-1">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket 会告诉您应用程序中实际影响用户的最具影响力的 bug 和 UX 问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket 自动聚合客户端错误、JS 异常、前端性能指标和用户交互。然后 LogRocket 使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的 bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试 LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>What is the virtual DOM in React? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>React中的虚拟DOM是什么？- LogRocket博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/virtual-dom-react/#0001-01-01">https://blog.logrocket.com/virtual-dom-react/#0001-01-01</a></blockquote><div><article class="article-post">
<p>虚拟DOM是一个基本的React概念；如果您在过去几年中编写过React代码，您可能听说过它。但是，您可能不理解它是如何工作的以及React为什么使用它。</p>
<p>在本文中，我们将介绍什么是虚拟DOM，探索它在React中的好处，并回顾一个实际例子。我们开始吧！</p>
<p><em>向前跳转:</em></p>

<h2 id="concept-review-what-is-dom">什么是反作用？</h2>
<p>为了理解虚拟DOM并了解React实现它的原因，让我们首先回顾一下什么是实际的浏览器DOM。</p>
<p>通常，每当用户请求网页时，浏览器都会从服务器接收该页面的HTML文档。然后，浏览器从HTML构建一个逻辑的树状结构，在客户端向用户显示所请求的页面。</p>
<p>这种树状结构被称为文档对象模型，也称为DOM。它是web文档作为节点和对象的结构化表示，在本例中是HTML文档。</p>
<p>DOM充当web文档的接口，因此JavaScript和其他脚本语言可以访问、操作文档内容，并以编程方式与之交互。例如，开发人员可以使用DOM APIs来添加或删除元素，修改它们的外观，以及在web元素上执行用户操作。</p>
<h2 id="how-re-rendering-impacts-performance">重新渲染如何影响性能</h2>
<p>DOM操作速度非常快，是轻型操作。然而，当应用程序数据发生变化并触发更新时，重新渲染可能会非常昂贵。</p>
<p>让我们用下面的JavaScript代码模拟重新呈现一个页面:</p>
<pre class="language-javascript hljs">const update = () =&gt; {
 const element = `
  &lt;h3&gt;JavaScript:&lt;/h3&gt;
  &lt;form&gt;
   &lt;input type="text"/&gt;
  &lt;/form&gt;
  &lt;span&gt;Time: ${new Date().toLocaleTimeString()}&lt;/span&gt;
 `;

 document.getElementById("root1").innerHTML = element;
};

setInterval(update, 1000);
</pre>
<p>你可以在CodeSandbox 上找到完整的代码<a href="https://codesandbox.io/s/goofy-darwin-4g25ce?file=/src/index.js">。表示文档的DOM树如下所示:</a></p>
<p><img data-attachment-id="156336" data-permalink="https://blog.logrocket.com/1-dom-tree-representing-example-document/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document-.png" data-orig-size="730,374" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dom-tree-representing-example-document" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document--300x154.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document-.png" decoding="async" class="aligncenter wp-image-156336 size-full jetpack-lazy-image" src="../Images/7fd589e640ff1d39d358cc701a77c1be.png" alt="Dom Tree Representing Example Document" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document-.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document--300x154.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document-.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document-.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156336" data-permalink="https://blog.logrocket.com/1-dom-tree-representing-example-document/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document-.png" data-orig-size="730,374" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="dom-tree-representing-example-document" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document--300x154.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document-.png" decoding="async" loading="lazy" class="aligncenter wp-image-156336 size-full" src="../Images/7fd589e640ff1d39d358cc701a77c1be.png" alt="Dom Tree Representing Example Document" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document-.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document--300x154.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/1-dom-tree-representing-example-document-.png"/></noscript>
<p>代码中的<code>setInterval()</code>回调让我们每秒钟触发一次UI的模拟重新呈现。如下面的GIF所示，文档DOM元素在每次更新时都被重新构建和重新绘制。由于这种重新呈现，UI中的文本输入也会丢失其状态:</p>
<p><img data-attachment-id="156339" data-permalink="https://blog.logrocket.com/2-node-lighting-up-full-page-re-render/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-node-lighting-up-full-page-re-render.gif" data-orig-size="730,259" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="node-lighting-up-full-page-re-render" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-node-lighting-up-full-page-re-render-300x106.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-node-lighting-up-full-page-re-render.gif" decoding="async" class="aligncenter wp-image-156339 size-full jetpack-lazy-image" src="../Images/1da3f871274ff47775c4f657423d25c7.png" alt="Node Lighting Up Full Page Rerender" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/2-node-lighting-up-full-page-re-render.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/2-node-lighting-up-full-page-re-render.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156339" data-permalink="https://blog.logrocket.com/2-node-lighting-up-full-page-re-render/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-node-lighting-up-full-page-re-render.gif" data-orig-size="730,259" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="node-lighting-up-full-page-re-render" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-node-lighting-up-full-page-re-render-300x106.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/2-node-lighting-up-full-page-re-render.gif" decoding="async" loading="lazy" class="aligncenter wp-image-156339 size-full" src="../Images/1da3f871274ff47775c4f657423d25c7.png" alt="Node Lighting Up Full Page Rerender" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/2-node-lighting-up-full-page-re-render.gif"/></noscript>
<p>如上所述，当UI中发生更新时，文本字段会丢失输入值，这需要优化。</p>
<p>不同的JavaScript框架提供不同的解决方案和策略来优化重新渲染。然而，React实现了虚拟DOM的概念。</p>
<h2 id="exploring-virtual-dom-react">探索React虚拟DOM</h2>
<p>顾名思义，虚拟DOM是对象形式的实际DOM的一个轻量级副本。虚拟DOM可以保存在浏览器内存中，不会直接改变用户浏览器上显示的内容。React由其他几个前端框架实现，如Vue，它的声明性方法是独一无二的。</p>
<h3 id="how-virtual-dom-different-real-dom">虚拟的DOM和真实的DOM有什么不同？</h3>
<p>一个常见的误解是，虚拟DOM比实际的DOM更快或更强，然而，这是不正确的。事实上，虚拟DOM的操作支持并补充了实际DOM的操作。实质上，虚拟DOM提供了一种机制，允许实际DOM在重新呈现UI时计算最少的DOM操作。</p>
<p>例如，当真实DOM中的元素发生变化时，DOM将重新呈现该元素及其所有子元素。当构建具有大量交互性和状态变化的复杂web应用程序时，这种方法既慢又低效。</p>
<p>相反，在呈现过程中，React使用虚拟DOM的概念，这符合其声明性方法。因此，我们可以指定我们希望UI处于什么状态，在这之后React使它发生。</p>
<p>虚拟DOM更新后，React将其与更新前拍摄的虚拟DOM的快照进行比较，确定哪个元素发生了更改，然后只更新真实DOM上的那个元素。这是虚拟DOM用来优化性能的一种方法。我们稍后会详细讨论。</p>
<p>虚拟DOM将手动DOM操作从开发人员手中抽象出来，帮助我们编写更可预测和更轻松的代码，以便我们可以专注于创建组件。</p>
<p>多亏了虚拟DOM，您不必担心状态转换。一旦更新了状态，React就会确保DOM与该状态相匹配。例如，在我们的最后一个例子中，React确保每次重新渲染时，只有<code>Time</code>在实际的DOM中得到更新。因此，当UI更新发生时，我们不会丢失输入字段的值。</p>
<h3 id="virtual-dom-object">虚拟DOM对象</h3>
<p>让我们考虑下面的渲染代码，它代表了我们之前的JavaScript示例的React版本:</p>
<pre class="language-javascript hljs">// ...
const update = () =&gt; {
 const element = (
  &lt;&gt;
   &lt;h3&gt;React:&lt;/h3&gt;
   &lt;form&gt;
    &lt;input type="text" /&gt;
   &lt;/form&gt;
   &lt;span&gt;Time: {new Date().toLocaleTimeString()}&lt;/span&gt;
  &lt;/&gt;
 );
 root.render(element);
};
</pre>
<p>为了简洁起见，我们删除了一些代码。你可以在CodeSandbox 上看到完整的代码。我们也可以用简单的React编写JSX代码，如下所示:</p>
<pre>const element = React.createElement(
 React.Fragment,
 null,
 React.createElement("h3", null, "React:"),
 React.createElement(
  "form",
  null,
  React.createElement("input", {
   type: "text"
  })
 ),
 React.createElement("span", null, "Time: ", new Date().toLocaleTimeString())
);
</pre>
<p>请记住，您可以通过在一个<a href="https://babeljs.io/repl">巴别塔REPL编辑器</a>中粘贴JSX元素来获得JSX代码的React等价物。</p>
<p>现在，如果我们在控制台中记录React元素，我们将得到如下图所示的结果:</p>
<pre> const element = (
  &lt;&gt;
   &lt;h3&gt;React:&lt;/h3&gt;
   &lt;form&gt;
    &lt;input type="text" /&gt;
   &lt;/form&gt;
   &lt;span&gt;Time: {new Date().toLocaleTimeString()}&lt;/span&gt;
  &lt;/&gt;
 );
 console.log(element)
</pre>
<p><img data-attachment-id="156341" data-permalink="https://blog.logrocket.com/3-react-virtual-dom-representing-ui/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui.png" data-orig-size="730,270" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-virtual-dom-representing-ui" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui-300x111.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui.png" decoding="async" class="aligncenter wp-image-156341 size-full jetpack-lazy-image" src="../Images/4e2d7c4fd24a236dbb1f1ad8ee48d62e.png" alt="React Virtual Dom Representing UI" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui-300x111.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156341" data-permalink="https://blog.logrocket.com/3-react-virtual-dom-representing-ui/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui.png" data-orig-size="730,270" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-virtual-dom-representing-ui" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui-300x111.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui.png" decoding="async" loading="lazy" class="aligncenter wp-image-156341 size-full" src="../Images/4e2d7c4fd24a236dbb1f1ad8ee48d62e.png" alt="React Virtual Dom Representing UI" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui-300x111.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/3-react-virtual-dom-representing-ui.png"/></noscript>
<p>如上所述，对象是虚拟DOM。它代表用户界面。</p>
<h3 id="how-react-implements-virtual-dom">React如何实现虚拟DOM</h3>
<p>为了理解虚拟DOM策略，我们需要理解其中涉及的两个主要阶段，渲染和协调。</p>
<p>当我们呈现一个应用程序用户界面时，React会创建一个表示该用户界面的虚拟DOM树，并将其存储在内存中。在下一次更新时，或者换句话说，当呈现应用程序的数据发生变化时，React将自动为更新创建一个新的虚拟DOM树。</p>
<p>为了进一步解释这一点，我们可以直观地将虚拟DOM表示如下:</p>
<p><img data-attachment-id="156343" data-permalink="https://blog.logrocket.com/4-react-virtual-dom-implementation-rendering-reconciliation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation.png" data-orig-size="730,479" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-virtual-dom-implementation-rendering-reconciliation" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation-300x197.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation.png" decoding="async" class="aligncenter wp-image-156343 size-full jetpack-lazy-image" src="../Images/f23e280eab4a585399cb6625ba0c9240.png" alt="React Virtual DOM Implementation Rendering Reconciliation" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation-300x197.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156343" data-permalink="https://blog.logrocket.com/4-react-virtual-dom-implementation-rendering-reconciliation/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation.png" data-orig-size="730,479" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-virtual-dom-implementation-rendering-reconciliation" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation-300x197.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation.png" decoding="async" loading="lazy" class="aligncenter wp-image-156343 size-full" src="../Images/f23e280eab4a585399cb6625ba0c9240.png" alt="React Virtual DOM Implementation Rendering Reconciliation" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation-300x197.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/4-react-virtual-dom-implementation-rendering-reconciliation.png"/></noscript>
<p>左边的图像是初始渲染。随着<code>Time</code>的改变，React用更新的节点创建一个新的树，如右侧所示。</p>
<p>记住，虚拟DOM只是一个表示UI的对象，所以屏幕上不会绘制任何东西。</p>
<p>React创建了新的虚拟DOM树后，它使用一种叫做reconciliation】的差分算法将它与之前的快照<a href="https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm">进行比较，以确定需要进行哪些更改。</a></p>
<p>在协调过程之后，React使用像ReactDOM 这样的渲染器库<a href="https://blog.logrocket.com/managing-dom-components-reactdom/">，它利用不同的信息来更新渲染的应用程序。这个库确保实际的DOM只接收和重画更新的节点:</a></p>
<p><img data-attachment-id="156347" data-permalink="https://blog.logrocket.com/5-react-actual-dom-update-repaint/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint.png" data-orig-size="730,378" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-actual-dom-update-repaint" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint-300x155.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint.png" decoding="async" class="aligncenter wp-image-156347 size-full jetpack-lazy-image" src="../Images/c78616d145891dd1d1e791d8f82edb3a.png" alt="React Actual DOM Update Repaint" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint-300x155.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156347" data-permalink="https://blog.logrocket.com/5-react-actual-dom-update-repaint/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint.png" data-orig-size="730,378" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="react-actual-dom-update-repaint" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint-300x155.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint.png" decoding="async" loading="lazy" class="aligncenter wp-image-156347 size-full" src="../Images/c78616d145891dd1d1e791d8f82edb3a.png" alt="React Actual DOM Update Repaint" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint-300x155.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/5-react-actual-dom-update-repaint.png"/></noscript>
<p>如上图所示，在实际的DOM中，只有数据发生变化的节点被重新绘制。下面的GIF进一步证明了这个说法:</p>
<p><img data-attachment-id="156350" data-permalink="https://blog.logrocket.com/6-node-changed-data-rapainted-actual-dom/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-node-changed-data-rapainted-actual-dom.gif" data-orig-size="730,239" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="node-changed-data-repainted-actual-dom" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-node-changed-data-rapainted-actual-dom-300x98.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-node-changed-data-rapainted-actual-dom.gif" decoding="async" class="aligncenter wp-image-156350 size-full jetpack-lazy-image" src="../Images/6b0124f571a00ff5faa81bb76a4841e4.png" alt="Node Changed Data repainted Actual Dom" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/6-node-changed-data-rapainted-actual-dom.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/6-node-changed-data-rapainted-actual-dom.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156350" data-permalink="https://blog.logrocket.com/6-node-changed-data-rapainted-actual-dom/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-node-changed-data-rapainted-actual-dom.gif" data-orig-size="730,239" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="node-changed-data-repainted-actual-dom" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-node-changed-data-rapainted-actual-dom-300x98.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/6-node-changed-data-rapainted-actual-dom.gif" decoding="async" loading="lazy" class="aligncenter wp-image-156350 size-full" src="../Images/6b0124f571a00ff5faa81bb76a4841e4.png" alt="Node Changed Data repainted Actual Dom" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/6-node-changed-data-rapainted-actual-dom.gif"/></noscript>
<p>当UI中发生状态变化时，我们不会丢失输入值。</p>
<p>总之，在每次渲染时，React都会将虚拟DOM树与以前的版本进行比较，以确定哪个节点得到了更新，从而确保更新后的节点与实际的DOM相匹配。</p>
<h3 id="diffing-process">反应扩散过程</h3>
<p>当React区分两个虚拟DOM树时，它首先比较两个快照是否具有相同的根元素。如果它们有相同的元素，就像在我们的例子中，更新的节点是相同的<code>span</code>元素类型，那么React继续移动并在属性上递归。</p>
<p>在这两个快照中，<code>span</code>元素上没有出现或更新任何属性。React然后在孩子们身上重复这个过程。一旦看到<code>Time</code>文本节点已经改变，React将只更新真实DOM中的实际节点。</p>
<p>另一方面，如果两个快照有不同的元素类型，这在大多数更新中很少见，React将销毁旧的DOM节点并构建一个新的。例如，从<code>span</code>到<code>div</code>，如下面相应的代码片段所示:</p>
<pre>&lt;span&gt;Time: 04:36:35&lt;/span&gt; 
</pre>
<pre>&lt;div&gt;Time: 04:36:38&lt;/div&gt;
</pre>
<p>在下面的示例中，我们呈现了一个简单的React组件，该组件在单击按钮后更新组件状态:</p>
<pre>import { useState } from "react";

const App = () =&gt; {
 const [open, setOpen] = useState(false);

 return (
  &lt;div className="App"&gt;
   &lt;button onClick={() =&gt; setOpen((prev) =&gt; !prev)}&gt;toggle&lt;/button&gt;
   &lt;div className={open ? "open" : "close"}&gt;
    I'm {open ? "opened" : "closed"}
   &lt;/div&gt;
  &lt;/div&gt;
 );
};
export default App;
</pre>
<p>更新组件状态会重新呈现组件。然而，如下所示，在每次重新渲染时，React只知道更新类名和更改的文本。此更新不会伤害渲染中未受影响的元素:</p>
<p><img data-attachment-id="156359" data-permalink="https://blog.logrocket.com/7-result-update-component-state-dom-changed-text/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-result-update-component-state-dom-changed-text.gif" data-orig-size="730,259" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="result-update-component-state-dom-changed-text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-result-update-component-state-dom-changed-text-300x106.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-result-update-component-state-dom-changed-text.gif" decoding="async" class="aligncenter wp-image-156359 size-full jetpack-lazy-image" src="../Images/52f71329515c65376ddd7059d2202b09.png" alt="Result Update Component State Dom Changed Text" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/7-result-update-component-state-dom-changed-text.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/7-result-update-component-state-dom-changed-text.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156359" data-permalink="https://blog.logrocket.com/7-result-update-component-state-dom-changed-text/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-result-update-component-state-dom-changed-text.gif" data-orig-size="730,259" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="result-update-component-state-dom-changed-text" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-result-update-component-state-dom-changed-text-300x106.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/7-result-update-component-state-dom-changed-text.gif" decoding="async" loading="lazy" class="aligncenter wp-image-156359 size-full" src="../Images/52f71329515c65376ddd7059d2202b09.png" alt="Result Update Component State Dom Changed Text" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/7-result-update-component-state-dom-changed-text.gif"/></noscript>
<p>参见CodeSandbox 上的<a href="https://codesandbox.io/s/stupefied-sanderson-dgq4t9?file=/src/App.js">代码和演示。</a></p>
<h3 id="react-diffs-lists">如何应对不同的列表</h3>
<p>当我们修改一个条目列表时，React如何改变列表取决于条目是添加在列表的开头还是末尾。考虑以下列表:</p>
<pre>&lt;ul&gt; 
  &lt;li&gt;item 3&lt;/li&gt;
  &lt;li&gt;item 4&lt;/li&gt;
  &lt;li&gt;item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>在下一次更新时，让我们在末尾添加一个<code>item 6</code>，就像这样:</p>
<pre>&lt;ul&gt; 
  &lt;li&gt;item 3&lt;/li&gt;
  &lt;li&gt;item 4&lt;/li&gt;
  &lt;li&gt;item 5&lt;/li&gt;
  &lt;li&gt;item 6&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>React从顶部开始比较项目。它匹配第一、第二和第三项，并且只知道插入最后一项。这种计算对于React来说很简单。</p>
<p>但是，让我们在开头插入<code>item 2</code>，如下:</p>
<pre>&lt;ul&gt; 
  &lt;li&gt;item 2&lt;/li&gt;
  &lt;li&gt;item 3&lt;/li&gt;
  &lt;li&gt;item 4&lt;/li&gt;
  &lt;li&gt;item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>同样，React从顶部开始比较，立刻意识到<code>item 3</code>与更新树的<code>item 2</code>不匹配。因此，它认为这是一个全新的名单，需要重建。</p>
<p>我们不需要重建整个列表，而是希望DOM只通过添加<code>item 2</code>来计算最少的操作。React让我们给<a href="https://reactjs.org/docs/reconciliation.html#keys">添加一个<code>key</code>道具，唯一地标识物品</a>，如下所示:</p>
<pre>&lt;ul&gt; 
  &lt;li key="3"&gt;item 3&lt;/li&gt;
  &lt;li key="4"&gt;item 4&lt;/li&gt;
  &lt;li key="5"&gt;item 5&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt; 
  &lt;li key="2"&gt;item 2&lt;/li&gt;
  &lt;li key="3"&gt;item 3&lt;/li&gt;
  &lt;li key="4"&gt;item 4&lt;/li&gt;
  &lt;li key="5"&gt;item 5&lt;/li&gt;
  &lt;li key="6"&gt;item 6&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>有了上面的实现，React就会知道我们已经预先考虑了<code>item 2</code>并附加了<code>item 6</code>。因此，它可以保留已经可用的项目，只在DOM中添加新的项目。</p>
<p>如果我们在映射渲染项目列表时省略了<code>key</code>属性，React会在浏览器控制台中提醒我们。</p>
<h2 id="how-virtual-dom-different-shadow-dom">虚拟DOM和阴影DOM有什么不同？</h2>
<p>在我们结束之前，这里有一个经常出现的问题。影子DOM和虚拟DOM一样吗？简而言之，他们的行为是不同的。</p>
<p>影子DOM是一个实现web组件的工具。以HTML <code>input</code>元素<code>range</code>为例:</p>
<pre>&lt;input type="range" /&gt;
</pre>
<p>这给了我们以下结果:</p>
<p><img data-attachment-id="156357" data-permalink="https://blog.logrocket.com/8-blue-grey-slider-dom-setting-indicator/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator.png" data-orig-size="365,74" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="blue-grey-slider-dom-setting-indicator" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator-300x61.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator.png" decoding="async" class="aligncenter wp-image-156357 size-full jetpack-lazy-image" src="../Images/2b78d1280547d7784028185ef1d73123.png" alt="Blue Grey Slider Dom Setting Indicator" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator.png 365w, https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator-300x61.png 300w" data-lazy-sizes="(max-width: 365px) 100vw, 365px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156357" data-permalink="https://blog.logrocket.com/8-blue-grey-slider-dom-setting-indicator/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator.png" data-orig-size="365,74" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="blue-grey-slider-dom-setting-indicator" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator-300x61.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator.png" decoding="async" loading="lazy" class="aligncenter wp-image-156357 size-full" src="../Images/2b78d1280547d7784028185ef1d73123.png" alt="Blue Grey Slider Dom Setting Indicator" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator.png 365w, https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator-300x61.png 300w" sizes="(max-width: 365px) 100vw, 365px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/8-blue-grey-slider-dom-setting-indicator.png"/></noscript>
<p>如果我们使用浏览器的开发工具来检查元素，我们只会看到一个简单的<code>input</code>元素。然而，在内部，浏览器封装并隐藏了组成输入滑块的其他元素和样式。</p>
<p>使用Chrome DevTools，我们可以从<code>Settings</code>启用<code>Show user agent shadow DOM</code>选项来查看阴影DOM:</p>
<p><img data-attachment-id="156355" data-permalink="https://blog.logrocket.com/9-chrome-dev-tools-dark-mode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode.png" data-orig-size="730,201" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="chrome-dev-tools-dark-mode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode-300x83.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode.png" decoding="async" class="aligncenter wp-image-156355 size-full jetpack-lazy-image" src="../Images/5ace904bad3b8234bfe4a37dfc694195.png" alt="Chrome Dev Tools Dark Mode" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode-300x83.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="156355" data-permalink="https://blog.logrocket.com/9-chrome-dev-tools-dark-mode/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode.png" data-orig-size="730,201" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="chrome-dev-tools-dark-mode" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode-300x83.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode.png" decoding="async" loading="lazy" class="aligncenter wp-image-156355 size-full" src="../Images/5ace904bad3b8234bfe4a37dfc694195.png" alt="Chrome Dev Tools Dark Mode" srcset="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode.png 730w, https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode-300x83.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2023/01/9-chrome-dev-tools-dark-mode.png"/></noscript>
<p>在上图中，<code>input</code>元素中的<code>#shadow-root</code>元素的结构化树被称为阴影DOM树。它提供了一种将组件(包括样式)从实际的DOM中分离出来的方法。</p>
<p>因此，我们确信一个小部件或组件的风格，就像上面的<code>input</code>范围，无论在哪里呈现都会被保留。换句话说，它们的行为或外观永远不会受到真实DOM中其他元素样式的影响。</p>
<h2 id="comparison-chart-real-virtual-shadow-dom">对比图:真实DOM vs .虚拟DOM vs .影子DOM</h2>
<p>下表总结了真实DOM、虚拟DOM和影子DOM之间的差异:</p>
<table class="tg">
<thead>
<tr>
<th class="tg-0lax">真正的DOM</th>
<th class="tg-0lax">虚拟DOM</th>
<th class="tg-0lax">阴影DOM</th>
<th class="tg-0lax">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tg-0lax">网络文档的接口；允许脚本与文档交互</td>
<td class="tg-0lax">实际DOM的内存副本</td>
<td class="tg-0lax">一个实现web组件的工具，或者一个实际DOM中的隔离DOM树，用于确定作用域</td>
<td class="tg-0lax">与开发者的相关性</td>
</tr>
<tr>
<td class="tg-0lax">开发人员手动执行DOM操作来操纵DOM</td>
<td class="tg-0lax">开发人员不必担心状态转换；虚拟DOM将DOM操作从开发人员手中抽象出来。</td>
<td class="tg-0lax">开发人员可以创建可重用的web组件，而不用担心宿主文档的样式冲突</td>
<td class="tg-0lax">谁使用它们</td>
</tr>
<tr>
<td class="tg-0lax">在浏览器中实现</td>
<td class="tg-0lax">由React、Vue等库和框架使用。</td>
<td class="tg-0lax">由web组件使用</td>
<td class="tg-0lax">项目复杂性</td>
</tr>
<tr>
<td class="tg-0lax">适合没有复杂交互的简单的中小型项目</td>
<td class="tg-0lax">适合具有高度交互性的复杂项目</td>
<td class="tg-0lax">适合简单到中等规模的项目，交互性不太复杂</td>
<td class="tg-0lax">CPU和内存使用情况</td>
</tr>
<tr>
<td class="tg-0lax">与虚拟DOM更新相比，真实DOM使用更少的CPU和内存</td>
<td class="tg-0lax">与真实的DOM更新相比，虚拟DOM使用更多的CPU和内存</td>
<td class="tg-0lax">与虚拟DOM更新相比，影子DOM使用更少的CPU和内存</td>
<td class="tg-0lax">包装</td>
</tr>
<tr>
<td class="tg-0lax">不支持封装，因为组件可以在其范围之外进行修改</td>
<td class="tg-0lax">支持封装，因为组件不能在其范围之外被修改</td>
<td class="tg-0lax">支持封装，因为组件不能在其范围之外被修改</td>
<td class="tg-0lax">结论</td>
</tr>
</tbody>
</table>
<h2 id="conclusion">React使用虚拟DOM作为策略，在重新呈现UI时计算最少的DOM操作。它不与真正的DOM竞争或比它更快。</h2>
<p>虚拟DOM提供了一种机制，将手动DOM操作从开发人员手中抽象出来，帮助我们编写更可预测的代码。它通过比较两个渲染树来确定到底发生了什么变化，只更新实际DOM中必要的内容。</p>
<p>和React一样，<a href="https://blog.logrocket.com/how-the-virtual-dom-works-in-vue-js/"> Vue也采用了这个策略</a>。然而，<a href="https://blog.logrocket.com/how-to-build-simple-svelte-js-app/"> Svelte提出了另一种方法</a>来确保应用程序得到优化，将所有组件编译成独立的微型JavaScript模块，使脚本运行起来非常轻便快捷。</p>
<p>我希望你喜欢阅读这篇文章。如果你有问题或贡献，请务必在评论区分享你的想法。</p>
<p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener"> LogRocket </a>:全面了解您的生产React应用</p><div class="code-block code-block-17">
<div class="blog-plug inline-plug react-plug" vwo-el-id="26283398190">
<h2 vwo-el-id="41600691720">调试React应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监视和跟踪Redux状态、自动显示JavaScript错误以及跟踪缓慢的网络请求和组件加载时间感兴趣，</h2><p>. </p><a href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" vwo-el-id="19356441070">try LogRocket</a><p>LogRocket 结合了会话回放、产品分析和错误跟踪，使软件团队能够创建理想的web和移动产品体验。这对你来说意味着什么？</p><a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441380">
<img class="first-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/f300c244a1a1cf916df8b4cb02bec6c6.png" vwo-el-id="18272717540" data-lazy-loaded="1" data-original-src="https://files.readme.io/27c94e7-Image_2017-06-05_at_9.46.04_PM.png"/>
</a>
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="19356441690">
<img class="second-react-image alignnone size-full wp-image-46 jetpack-lazy-image jetpack-lazy-image--handled" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" vwo-el-id="30720362350" data-lazy-loaded="1" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/>
</a>
<p vwo-el-id="28675660440" class="">LogRocket不是猜测错误发生的原因，也不是要求用户提供截图和日志转储，而是让您回放问题，就像它们发生在您自己的浏览器中一样，以快速了解哪里出错了。</p>
<p>不再有嘈杂的警报。智能错误跟踪允许您对问题进行分类，然后从中学习。获得有影响的用户问题的通知，而不是误报。警报越少，有用的信号越多。</p>
<p>LogRocket Redux中间件包为您的用户会话增加了一层额外的可见性。LogRocket记录Redux存储中的所有操作和状态。</p>
<p vwo-el-id="28675660750">现代化您调试React应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">开始免费监控</a>。</p>
<p vwo-el-id="28675661060">Modernize how you debug your React apps —
<a class="signup" href="https://lp.logrocket.com/blg/react-signup-general" target="_blank" rel="noopener noreferrer" vwo-el-id="40093418840">start monitoring for free</a>.
</p>
</div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
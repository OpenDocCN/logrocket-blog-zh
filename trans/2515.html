<html>
<head>
<title>PurgeCSS: Remove unused CSS code - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>清除未使用的 CSS 代码</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/purgecss-remove-unused-css-code/#0001-01-01">https://blog.logrocket.com/purgecss-remove-unused-css-code/#0001-01-01</a></blockquote><div><article class="article-post">
<p>CSS 框架是预先准备好并随时可以使用的样式表的集合。开发人员选择 CSS 框架，以更直观、更高效、更符合标准的方式交付数字体验。</p>
<p>然而，<a href="https://blog.logrocket.com/top-utility-first-css-frameworks/"> CSS 框架也会带来问题</a>。你不太可能使用 CSS 框架中提供的每一个特性，这意味着未使用的代码将会在你的最终应用程序中留下。未使用的代码会导致更大的文件大小，损害性能，很容易丢失对每个项目的跟踪，并导致优化问题。</p>
<p>删除不必要的代码将使你的网站加载更快，因为浏览器将要求和解析更少的代码。在本教程中，我们将探索<a href="https://purgecss.com/"> PurgeCSS </a>，一个用于移除未使用的 CSS 代码的工具。将 PurgeCSS 作为我们开发工作流程的一部分，我们可以轻松地删除未使用的 CSS，从而产生更小的 CSS 文件，并从整体上改善我们的应用程序。我们开始吧！</p>
<h2>为什么应该使用 PurgeCSS？</h2>
<p>虽然 PurgeCSS 不是删除未使用的 CSS 的唯一工具，但由于其模块化、易用性和广泛的定制选项，它脱颖而出。</p>
<h3>模块性</h3>
<p>模块化使开发人员能够为特定的用例及框架创建模块提取器。提取器是一个函数，它读取文件的内容并提取所使用的 CSS 选择器列表。</p>
<p>PurgeCSS 提供了一个非常可靠的默认提取器，可以处理多种文件类型。然而，默认情况下，PurgeCSS 忽略包含特殊字符的未使用的 CSS 代码，如<code>@</code>、<code>:</code>和<code>/</code>。因此，PurgeCSS 可能不适合您正在使用的确切文件类型或 CSS 框架。</p>
<h3>广泛的定制选项</h3>
<p>PurgeCSS 有一个<a href="https://purgecss.com/configuration.html#options">广泛的选项，允许你根据自己的需要定制</a>它的行为。例如，PurgeCSS 包括<code>fontFace</code>、<code>keyframes</code>、<code>extractors</code>、<code>css</code>等选项。定制可以提高采购的性能和效率。</p>
<h3>使用方便</h3>
<p>PurgeCSS 非常容易上手，并且包含完整的文档。在撰写本文时，PurgeCSS 凭借在 npm 和<a href="https://github.com/FullHuman/purgecss"> 6.5k GitHub stars 上</a><a href="https://www.npmjs.com/package/purgecss">190 万的周下载量受到开发者的喜爱。</a></p>
<h2>入门指南</h2>
<p>首先，打开您的终端并运行以下命令，使用 create-react-app 安装 React:</p>
<pre class="language-shell hljs">npx create-react-app purgecss-tutorial
</pre>
<p>接下来，进入我们刚刚创建的<code>purgecss-tutorial</code>目录:</p>
<pre class="language-react hljs">cd purgecss-tutorial
</pre>
<p>现在，继续安装 PurgeCSS 及其依赖项:</p>
<pre class="language-shell hljs">npm i --save-dev @fullhuman/postcss-purgecss glob-all purgecss-webpack-plugin
</pre>
<p>打开您的<code>App.js</code>文件并粘贴以下代码:</p>
<pre class="language-react hljs">import React from 'react';
import "./App.css";

function App() {
  return &lt;div className="App"&gt;&lt;/div&gt;;
}

export default App;
</pre>
<p>在上面的代码中，我们创建了一个名为<code>App</code>的功能组件，并返回一个带有<code>App</code>的<code>classname</code>的<code>div</code>。</p>
<p>我们的<code>App.css</code>保持不变，因此它包含以下未使用的 CSS 代码:</p>
<pre class="language-css hljs">.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
</pre>
<p>打开您的<code>package.json</code>文件，并在脚本下添加下面一行:</p>
<pre class="language-css hljs">"postbuild": "purgecss --css build/static/css/*.css --content build/index.html build/static/js/*.js --output build/static/css"
</pre>
<p><code>post</code>是一个前缀，可以添加到任何 npm 脚本中，并在您运行主脚本时自动运行。在我们的例子中，<code>postbuild</code>在<code>build</code>脚本执行之后运行。</p>
<p>由<code>postbuild</code>执行的命令包含三个选项。选项指定 PurgeCSS 应该处理哪些 CSS 文件。它可以是文件名数组或<a href="https://github.com/isaacs/node-glob/blob/master/README.md#glob-primer"> globs </a>。<code>--content</code>选项类似于<code>--css</code>选项，指定 PurgeCSS 应该分析什么内容。<code>--output</code>选项指定了你应该将净化后的 CSS 文件写入哪个目录。默认情况下，它将结果放在控制台中。</p>
<p>本质上，由<code>postbuild</code>执行的命令做了以下事情:</p>
<ol>
<li>检查<code>build/static/css</code>中的每个 CSS 文件</li>
<li>匹配文件中使用的选择器并移除任何未使用的 CSS</li>
<li>在<code>build/static/css</code>中输出新的 CSS 文件</li>
</ol>
<p>最后，弹出 Create React 应用程序以公开由原始 Create React 应用程序提供的 webpack 配置。弹出之后，我们将通过添加以下代码以及其余的导入来修改<code>config/webpack.prod.conf.js</code>文件:</p>
<pre class="language-javascript hljs">// import PurgeCSS webpack plugin and glob-all
const PurgecssPlugin = require('purgecss-webpack-plugin')
const glob = require('glob-all')
</pre>
<p>在插件列表中的<code>new ManifestPlugin(...)</code>之前，添加以下代码:</p>
<pre class="language-javascript hljs">    new PurgecssPlugin({
      paths: [paths.appHtml, ...glob.sync(`${paths.appSrc}/**/*`, { nodir: true })]
    }),
</pre>
<p>webpack 插件用一个路径数组指定 PurgeCSS 应该分析的内容。</p>
<p>要确认是否成功，请打开<code>build/static/css</code>中的 CSS 文件。输出看起来像下面的代码，只包含使用的 CSS:</p>
<pre>body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.App{text-align:center}@keyframes App-logo-spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}
</pre>
<h2>采购须知</h2>
<p>PurgeCSS，以及其他一些 CSS 优化工具，如 PostCSS 和 cssnano，可以从 CSS 文件中去除注释。您可以指出在最终的 CSS 中保留哪些选择器是安全的。</p>
<p>有两种方法可以实现这一点，PurgeCSS 选项<code>safelist</code>或特殊的 CSS 特殊注释。</p>
<p>在我们的例子中，我们将直接在 CSS 文件中添加一个特殊的 CSS 注释。PurgeCSS 使用<code>/* purgecss start ignore */</code>和<code>/* purgecss end ignore */</code>来安全列出一系列规则。为了防止我们的评论被删除，我们添加了一个感叹号来告诉 PurgeCSS 这很重要。请参见下面的示例:</p>
<pre class="language-css hljs">/*! purgecss start ignore */
h1 {
  color: pink;
  font-size: 2rem;
}
/*! purgecss end ignore */
</pre>
<p>在 PurgeCSS v2.0 之前，默认情况下会删除未使用的字体和关键帧代码。然而，当这些特性使用不当时，代码就会崩溃。默认情况下，未使用的字体和关键帧代码现在保持不变。您可以通过将<code>keyframes</code>和<code>font-faces</code>选项设置为<code>true</code>来改变这种默认行为。</p>
<h2>结论</h2>
<p>在本文中，我们探讨了 PurgeCSS，这是一个从代码中删除未使用的 CSS 的工具，从而减少文件大小并提高优化。我们讨论了 PurgeCSS 的主要产品，包括它的模块化、定制选项和易用性。然后，我们回顾了开始使用 PurgeCSS 所需的步骤以及需要考虑的一些注意事项。</p>
<p>即使你决定使用像 TailwindCSS、Bootstrap、MaterializeCSS 或 Foundation 这样的 CSS 框架，PurgeCSS 也应该可以完美地工作。我希望你喜欢这篇文章！</p>
<p> </p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的 CPU？</h2><p>随着 web 前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端 CPU 使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
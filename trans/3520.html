<html>
<head>
<title>Flutter logging best practices </title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>颤振日志记录最佳实践</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/flutter-logging-best-practices/#0001-01-01">https://blog.logrocket.com/flutter-logging-best-practices/#0001-01-01</a></blockquote><div><article class="article-post">
<p>开发一个大规模的应用程序并不容易。它通常涉及多个模块协同工作，并且通常由不同的开发人员编写。因此，当开发中出现问题时，一个人必须检查由多个开发人员创建的应用流程，以确定根本原因。错误地识别哪里出了问题或者添加临时修复可能会破坏代码的其他部分，从长远来看会导致更多的问题。</p>
<p>如果你想加速创建一个应用程序，你可以在你的代码中使用这些:</p>
<pre class="language-dart hljs">print('reached here');

// Some code

print('now here');

// Some other code

print('method called');</pre>
<p><code>print()</code>或<code>debugPrint()</code>语句是将错误记录到控制台或检查代码位置的便捷方式。最初，围绕应用程序的一些打印声明并不令人担忧。然而，从长远来看，这不是一种可持续的开发应用的方式。</p>
<p>确保项目的所有模块和功能顺利运行的一个好方法是使用日志记录。定义良好的日志记录系统有助于减少构建应用程序时的麻烦，并在应用程序运行时为用户和开发人员提供简明的信息。</p>
<p>本文将探索如何使用<a href="https://pub.dev/packages/logger">日志包</a>来创建易于解释的<a href="https://blog.logrocket.com/tag/flutter/"> Flutter </a>日志，考虑日志级别，并介绍如何使用<a href="https://firebase.google.com/products/crashlytics"> Crashlytics </a>来获取正在进行的日志。</p>
<p><em>向前跳转:</em></p>

<h2 id="what-good-flutter-logging-system">一个好的颤振测井系统是什么样的？</h2>
<p>在我们讨论在Flutter中登录的最佳实践之前，让我们看看日志本身。</p>
<p>具有不均匀结构和消息传递的日志很难破译内容。例如，HTTP请求可以包含几个参数，或者有需要检查的重要结果。当日志结构不良时，这样做既困难又耗时。</p>
<p>让我们想想你需要什么来构建一个app。首先，您必须确保对服务器的所有调用都成功通过。稍后，您将需要检查UI的某些部分是否正确构建，并且您将需要关于数据库的详细信息。</p>
<p>当您监视重大错误并修复它们时，具有均匀结构和消息传递的日志记录系统将使您免于毁了您的周末。日志系统必须适合开发者的需求，而不是一成不变的。</p>
<p>现在，让我们看看日志记录级别。</p>
<h2 id="logging-levels-flutter-projects">颤振项目中测井水平的重要性</h2>
<p>Flutter项目可以有许多日志，包括网络、数据库和错误。通常，开发人员只需要适量的日志，可以安全地忽略那些更详细的日志。但是，如果事情不顺利，您可能需要检查更详细的事件。</p>
<p>当一个应用程序发布时，您可能只需要记录错误和其他重要事件。在每个日志中设置级别对于记录这些错误至关重要，因为级别为每个日志指定了重要性或类型。</p>
<p>您可能会发现诸如<code>verbose</code>、<code>warning</code>和<code>error</code>这样的日志类型，它们会过滤掉不必要的日志。既然我们已经了解了可靠的日志记录系统的重要性，并且设置了日志的日志级别，那么让我们看看如何将它们添加到应用程序中。</p>
<h2 id="best-practices-adding-logs-flutter-projects">向Flutter项目添加日志的最佳实践</h2>
<p>这里，我们将讨论向项目添加日志的基本规则。通过遵循这些最佳实践，你可以更好地理解你的应用程序的流程，并比没有一致的日志系统的应用程序更快地处理任何意外问题。</p>
<h3 id="log-appropriate-information">1)记录适当的信息</h3>
<p>当试图解决一个错误时，记录太多的信息是压倒性的，而拥有太少的信息并不能提供足够的信息来处理错误。如同任何误差一样，误差可以追溯到颤振本身的基础。如果将整个堆栈轨道提供给开发人员，这就像大海捞针，而不是有用的信息。为了避免这种情况，请记录适当的信息以确定开发人员代码中错误的根本原因，而不要将相同的链向下扩展到基本Dart错误。</p>
<h3 id="make-sure-all-events-covered">2)确保涵盖所有活动</h3>
<p>当一个应用程序运行时，几个系统协同工作，包括UI、网络调用、数据库等等。这么多系统同时工作，很容易忽略对关键事件的报道。这些丢失的日志掩盖了流程的内部工作和错误的原因。为了避免麻烦，请确保所有事件都被报道。</p>
<h3 id="do-not-use-logs-tests">3)不要使用日志作为测试</h3>
<p>日志经常被用来代替测试，以确保到达代码的特定部分。虽然在代码的这些部分有日志并不总是一个坏主意，但是避免测试可能是有害的。</p>
<h3 id="log-uniformly">4)统一记录</h3>
<p>需要检查每个记录的事件的重要性，因此为每种类型的事件分配一个级别。例如，您可以将所有网络调用设置为详细。这使得开发人员可以有效地分离日志，以避免在更高的日志级别处理大量日志。</p>
<h3 id="switch-off-unnecessary-logs">5)不需要日志时将其关闭</h3>
<p>在开发过程中，您将需要检查比生产中更多的日志——所以不要在生产中记录不必要的信息。生产应用可能比调试应用运行在更多的设备上。记录这些应用程序运行的所有事件会增加不必要的运营成本；因此，生产日志通常仅限于警告和错误。</p><div class="code-block code-block-54">
<hr/>
<h3>更多来自LogRocket的精彩文章:</h3>

<hr/></div>
<p>既然已经设置了最佳实践，那么让我们来看一个可以为我们实现日志记录各个方面的包。</p>
<h2 id="using-logger-package-log-flutter">使用日志包登录Flutter</h2>
<p>虽然为内部登录创建不同的组件是可能的，但这非常耗时，而且几乎没有什么好处，因为跨应用程序的登录系统很少是定制的或不同的。有几个日志包，比如<a href="https://pub.dev/packages/f_logs"> FLogs </a>、<a href="https://pub.dev/packages/loggy"> loggy </a>、<a href="https://pub.dev/packages/simple_logger"> simple_logger </a>。</p>
<p>在本文中，我们将探索<a href="https://pub.dev/packages/logger">记录器</a>包。它是最受欢迎的Flutter日志记录解决方案之一，因为它支持开箱即用的日志记录，并创建简洁格式的日志。你可以在这里找到整个GitHub库<a href="https://github.com/leisim/logger"/>。</p>
<h3 id="creating-basic-logs">创建基本日志</h3>
<p>要开始日志记录，使用<code>log()</code>方法创建一个<code>Logger</code>类实例。</p>
<p>接下来，使用下面的命令提供级别和消息:</p>
<pre class="language-dart hljs">var logger = Logger();

logger.log(Level.verbose, "Demo log");</pre>
<p>您可以提供一个与特定日志相关联的<code>error</code>和一个<code>stackTrace</code>:</p>
<pre class="language-dart hljs">class StringStackTrace implements StackTrace {

 final String _stackTrace;

 const StringStackTrace(this._stackTrace);

 String toString() =&gt; _stackTrace;

}

var logger = Logger();

logger.log(Level.verbose, "Demo log", "An error", StringStackTrace("Your stacktrace here"));</pre>
<p>错误可以是除了<code>String</code>之外的任何对象。因此，您可以将您的<code>error</code>与日志一起提供，如下所示:</p>
<pre class="language-dart hljs">var error = Error();

var logger = Logger();

logger.log(Level.verbose, "Demo log", error, error.stackTrace);
</pre>
<p>在示例中，我们可以在记录时传递错误的<code>error</code>和<code>stackTrace</code>。这允许用户从日志中快速提取更多细节并处理错误。</p>
<h3 id="using-Logger-class-log-levels">使用<code>Logger</code>类来记录级别</h3>
<p>现在我们已经创建了基本日志，是时候记录级别了。幸运的是，<code>Logger</code>有几个级别可以用来记录事件，如下所示:</p>
<pre class="language-dart hljs">enum Level {
 verbose,
 debug,
 info,
 warning,
 error,
 wtf,
 nothing,
}</pre>
<p>为了记录而不必每次都描述级别，<code>Logger</code>提供了多种方法来记录不同的级别:</p>
<pre class="language-dart hljs">var logger = Logger();

logger.log(Level.verbose, "Demo log", error, error.stackTrace);

//OR

logger.v("Demo log", error, error.stackTrace);

// SIMILARLY

logger.w("Demo log", error, error.stackTrace);

logger.i("Demo log", error, error.stackTrace);

// AND MORE...</pre>
<h3 id="building-log-filter">构建日志过滤器</h3>
<p>日志过滤器有助于确定哪些事件应该记录，哪些不应该记录。这在决定需要在发布模式下显示何种日志时非常有用。</p>
<p>要创建一个<code>LogFilter</code>，扩展<code>LogFilter</code>类，并实现<code>shouldLog()</code>。接下来，在实例化<code>Logger</code>时传入过滤器:</p>
<pre class="language-dart hljs">class DemoFilter extends LogFilter {
 @override
 bool shouldLog(LogEvent event) {

   if(event.level == Level.error || event.level == Level.warning) {
     return true;
   }

   return false;
 }
}

var logger = Logger(filter: DemoFilter());

logger.w("This will be accepted", error, error.stackTrace);

logger.v("This will not", error, error.stackTrace);</pre>
<p><code>LogFilter</code>让您决定是否应该记录或忽略收到的事件。例如，根据日志的严重程度，可以有不同的过滤器。</p>
<h3 id="designing-log-printers">设计日志打印机</h3>
<p>Logger包支持打印结构良好且美观的日志。默认情况下，它们以标准方式打印，带有一个<code>stackTrace</code>和一条类似如下的消息:</p>
<p><img data-attachment-id="139033" data-permalink="https://blog.logrocket.com/flutter-logging-best-practices/attachment/flutter-log-printer/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer.png" data-orig-size="730,292" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flutter logging with Logger package printer" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer-300x120.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer.png" decoding="async" class="aligncenter size-full wp-image-139033 jetpack-lazy-image" src="../Images/8130a7e02460b441db7a371bb63ac7d2.png" alt="Flutter Logging With Logger Package" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer-300x120.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="139033" data-permalink="https://blog.logrocket.com/flutter-logging-best-practices/attachment/flutter-log-printer/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer.png" data-orig-size="730,292" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flutter logging with Logger package printer" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer-300x120.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-139033" src="../Images/8130a7e02460b441db7a371bb63ac7d2.png" alt="Flutter Logging With Logger Package" srcset="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer-300x120.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/10/flutter-log-printer.png"/></noscript>
<p>但是，您可以使用内置的<code>PrettyPrinter</code>类，使用下面的命令为您的日志添加更多的特色:</p>
<pre class="language-dart hljs">var logger = Logger(
 printer: PrettyPrinter(),
);
</pre>
<p>要制作你的打印机，你可以用这个来扩展<code>LogPrinter</code>:</p>
<pre class="language-dart hljs">class DemoPrinter extends LogPrinter {
 @override
 List&lt;String&gt; log(LogEvent event) {
   switch(event.level) {
     case Level.verbose:
       break;
     case Level.debug:
       break;
     case Level.info:
       break;
     case Level.warning:
       break;
     case Level.error:
       break;
     case Level.wtf:
       break;
     case Level.nothing:
       break;
   }
 }
}</pre>
<p>现在，您可以为每个日志级别打印定制格式的消息。</p>
<h2 id="connecting-crashlytics">连接到Crashlytics</h2>
<p>Firebase的Crashlytics服务允许开发者分析应用程序中的崩溃和特殊事件。虽然崩溃是极端事件，但Crashlytics也支持将应用程序中的自定义日志发送到Firebase Crashlytics控制台。这有助于Crashlytics成为一个通用的日志工具，而不仅仅是在应用程序出错时提供帮助。</p>
<p>首先，使用以下步骤将Firebase Crashlytics添加到您的应用程序中:</p>
<h3>1.添加<code>firebase_crashlytics</code>依赖项</h3>
<p>运行此命令将依赖项添加到项目中:</p>
<pre class="language-gradle hljs">flutter pub add firebase_crashlytics</pre>
<h3>2.为Android添加配置</h3>
<p>将这些行添加到您的<code>android/build.gradle</code>文件中:</p>
<pre class="language-gradle hljs">dependencies {
 // ... 
 classpath 'com.google.firebase:firebase-crashlytics-gradle:2.7.1'
}</pre>
<p>此外，将这些添加到<code>android/app/build.gradle</code>:</p>
<pre class="language-gradle hljs">android {
 // ... your android config
}


dependencies {
 // ... your dependencies
}


// This must appear at the bottom of the file
apply plugin: 'com.google.firebase.crashlytics'</pre>
<p>要获得有关Crashlytics集成的更多信息，请在此处找到文档<a href="https://firebase.flutter.dev/docs/crashlytics/overview">。</a></p>
<p>要在应用程序中记录错误，请使用Crashlytics提供的<code>recordError()</code>方法:</p>
<pre class="language-dart hljs">FirebaseCrashlytics.instance.recordError(
 error,
 stackTrace,
 reason: 'Your error reason',
 fatal: true
);</pre>
<p>如果没有错误，并且您想查看日志，请使用<code>log()</code>方法:</p>
<pre class="language-dart hljs">FirebaseCrashlytics.instance.log("Your log event");</pre>
<p>此外，还有颤振特有的误差函数，如<code>recordFlutterError()</code>:</p>
<pre class="language-dart hljs">FirebaseCrashlytics.instance.recordFlutterError(
 FlutterErrorDetails(
   exception: YourException(),
   stack: stackTrace,
 ),
 fatal: false,
);</pre>
<p><code>exception</code>值的类型是<code>Object</code>，所以这个值可以是您想要传递的任何值。</p>
<h2>结论</h2>
<p>本文讨论了在Flutter项目中记录日志的最佳实践。我们还学习了如何使用一个包来创建易于解释的日志，考虑了日志级别，并介绍了如何使用Crashlytics和类似的工具来获取正在进行的日志。</p>
<p>虽然这是对Flutter登录的总结，但是您的实现可能每次都有所不同，这取决于您正在开发的项目。</p><div class="code-block code-block-4">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
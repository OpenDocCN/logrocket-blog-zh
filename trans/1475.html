<html>
<head>
<title>What are container queries in CSS? - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>CSS 中的容器查询是什么？- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/what-are-container-queries-in-css/#0001-01-01">https://blog.logrocket.com/what-are-container-queries-in-css/#0001-01-01</a></blockquote><div><article class="article-post">
<p>容器查询是 CSS 中谈论最多和被请求最多的特性之一。以至于它已经成为开发人员社区的陈词滥调。但是什么是真正的容器查询呢？</p>
<p><a href="https://blog.logrocket.com/cascade-layers-subgrid-container-queries-whats-new-css/" target="_blank" rel="noopener">容器查询是帮助我们根据其属性</a>如宽度和高度来设计容器内容样式的查询。这采用了不同于媒体查询的方法，媒体查询帮助我们基于视口的变化来设计网页/网站的样式。</p>
<p>在本文中，我们将研究一些调整，以便在 CSS 代码中实现类似容器查询的行为。具体来说，我们将探讨以下内容:</p>

<h2 id="container-queries-flexbox">使用 flexbox 的容器查询</h2>
<p>Flexbox 是一个单向布局模型，它允许我们创建一个响应速度更快的网站。</p>
<p>在本文中，我们将使用源于 flexbox 并由 Heldon Pickering 创建的技术来模拟容器查询。我们的目标是用 flexbox 创建三列，并将它们全部移动到某个容器宽度的行中。</p>
<p>在您的首选目录中创建一个名为<code>container_query</code>的文件夹，然后在代码编辑器中打开它。接下来，让我们在<code>container_query</code>文件夹中创建两个文件，分别命名为<code>index.html</code>和<code>style.css</code>。</p>
<p>继续将以下代码粘贴到您的<code>index.html</code>文件中:</p>
<pre class="language-xml hljs">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;container queries&lt;/title&gt;
&lt;/head&gt; 
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="child child1"&gt;
           Lorem ipsum dolor sit amet consectetur adipisicing elit. Ex, enim!
        &lt;/div&gt;
        &lt;div class="child child2"&gt;
            Lorem ipsum Lorem ipsum dolor sit amet consectetur, adipisicing elit. Laudantium aliquid esse fugiat!
        &lt;/div&gt;
        &lt;div class="child child3"&gt;
             consectetur adipisicing elit. Tempora totam, eos rerum ipsum consequuntur suscipit?
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>在上面的 HTML 代码中，我们用另外两个<code>div</code>容器创建了一个<code>div</code>容器作为它的内容。</p>
<p>接下来，让我们添加一些基本的 CSS 样式来赋予它形状。</p>
<p>将以下代码添加到您的<code>style.css</code>文件中:</p>
<pre class="language-css hljs">.child{
    background: rgb(231, 227, 227);
    padding:1em;
    font-size: 18px;
}
</pre>
<p>现在，让我们开始应用赫尔顿的方法。我们将添加所有的 CSS 代码，然后一个接一个地解释它们。让我们用下面的文件更新我们的 CSS 文件:</p>
<pre class="language-css hljs">.container{
    display:flex;
    flex-wrap:wrap;
    gap:1em;

}
.child{
    flex-basis: calc( calc(500px - 100%) * 999);;
    flex-grow: 1;
    background: rgb(231, 227, 227);
    padding:1em;
    font-size: 18px;
}
</pre>
<p>我们给了具有<code>.container</code>类的容器一个<code>flex</code>和<code>wrap</code>的<code>flex-wrap</code>的显示。这是必要的，因为它有助于我们的子元素在必要时伸缩和突破。</p>
<p>主容器的所有子容器都被赋予一个<code>1</code>的<code>flex-grow</code>。这允许元素增长到超出其原始宽度，并填充剩余的空间。</p>
<p>属性帮助我们设置所有子元素的理想宽度。注意，flexbox 并没有严格遵循这一点，它会在必要的时候做出调整。</p>
<p>较大的负值<code>flex-basis</code>将导致子元素最终从初始列位置占据行位置。</p>
<p>我们在上面的<code>flex-basis</code>属性中所做的是，我们利用<code>calc()</code>来设置<code>flex-basis</code>属性，这样它会给我们一个低于 500px 值的负值。这将导致所有子元素从列位置占据行位置。</p>
<p><img data-attachment-id="32196" data-permalink="https://blog.logrocket.com/what-are-container-queries-in-css/attachment/flex-basis-property-in-action/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-in-action.gif" data-orig-size="730,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flex-basis property in action" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-in-action-300x218.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-in-action.gif" decoding="async" class="aligncenter size-full wp-image-32196 jetpack-lazy-image" src="../Images/9fe53dbc3dba2fe1d6c0c705f6685ef4.png" alt="Flex-basis Property in Action" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-in-action.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-in-action.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="32196" data-permalink="https://blog.logrocket.com/what-are-container-queries-in-css/attachment/flex-basis-property-in-action/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-in-action.gif" data-orig-size="730,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flex-basis property in action" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-in-action-300x218.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-in-action.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32196" src="../Images/9fe53dbc3dba2fe1d6c0c705f6685ef4.png" alt="Flex-basis Property in Action" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-in-action.gif"/></noscript>
<p>我们可以采用与上面相同的方法，在第一个子元素中创建两个<code>p</code>标记，随着父元素宽度的减少，这两个标记将从一列移动到另一行。</p>
<p>让我们用下面的代码更新<code>index.html</code>文件中第一个子元素的内容:</p>
<pre class="language-xml hljs">&lt;p&gt;
    Lorem ipsum, dolor sit amet consectetur adipisicing elit. Ducimus, perferendis!
&lt;/p&gt;
&lt;p&gt;
    Lorem ipsum dolor sit amet consectetur adipisicing elit. Nostrum, soluta.
&lt;/p&gt;
</pre>
<p>将以下附加代码添加到我们的<code>style.css</code>文件中:</p>
<pre class="language-css hljs">.child1{
    display:flex;
    flex-wrap:wrap;
}
</pre>
<pre class="language-xml hljs">.child1 p{
    flex-basis: calc( calc(400px - 100%) * 999);
    flex-grow: 1;
}
</pre>
<p>就像在第一个例子中一样，我们利用<code>flex-basis</code>属性来设置一个理想的宽度，然后允许带有<code>p</code>标签的元素在值变为负值时占据行位置。</p>
<p>下面是生成的代码:</p>
<p><img data-attachment-id="32197" data-permalink="https://blog.logrocket.com/what-are-container-queries-in-css/attachment/flex-basis-property-with-p-tags/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-with-p-tags.gif" data-orig-size="730,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flex-basis property with p tags" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-with-p-tags-300x218.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-with-p-tags.gif" decoding="async" class="aligncenter size-full wp-image-32197 jetpack-lazy-image" src="../Images/376134e37d4004baab65a55b5967f68d.png" alt="Flex-basis Property With P Tags" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-with-p-tags.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-with-p-tags.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="32197" data-permalink="https://blog.logrocket.com/what-are-container-queries-in-css/attachment/flex-basis-property-with-p-tags/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-with-p-tags.gif" data-orig-size="730,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Flex-basis property with p tags" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-with-p-tags-300x218.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-with-p-tags.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32197" src="../Images/376134e37d4004baab65a55b5967f68d.png" alt="Flex-basis Property With P Tags" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/flex-basis-property-with-p-tags.gif"/></noscript>
<h2 id="container-queries-css-grid">使用 CSS 网格的容器查询</h2>
<p>就像使用 flexbox 一样，我们可以借助 CSS grid 及其属性实现有条件的容器样式。</p>
<p>我们将使用我们在上面的例子中使用的相同的 HTML 代码，所以从你的新索引文件上面的例子中复制 HTML 代码。</p>
<p>现在，让我们把下面的代码复制到新的 CSS 文件中。我将解释每一个添加。</p>
<pre class="language-css hljs">.container{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    grid-gap:1em;

}
.child{

    background: rgb(231, 227, 227);
    padding:1em;
    font-size: 18px;
}
</pre>
<p>我们首先将显示设置为 grid，然后给子容器一个 1em 的<code>grid-gap</code>。在这种情况下，<code>grid-template-columns</code>属性发挥了所有的作用。我们正在利用<code>repeat()</code>创建一个网格，最小宽度为 300 像素，最大宽度为 1fr，限制为<code>auto-fit<code>. This allows the grid to fill out the whole viewport.</code> </code></p>
<p>结果是一个三列布局，当父容器低于 300px 时切换到行:</p>
<p><img data-attachment-id="32198" data-permalink="https://blog.logrocket.com/what-are-container-queries-in-css/attachment/three-column-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/three-column-layout.gif" data-orig-size="730,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Three column layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/three-column-layout-300x218.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/three-column-layout.gif" decoding="async" class="aligncenter size-full wp-image-32198 jetpack-lazy-image" src="../Images/f2f0ec8b4ffdc103122a047c10f1351c.png" alt="Three Column Layout" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2021/01/three-column-layout.gif?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/three-column-layout.gif"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="32198" data-permalink="https://blog.logrocket.com/what-are-container-queries-in-css/attachment/three-column-layout/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2021/01/three-column-layout.gif" data-orig-size="730,530" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Three column layout" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2021/01/three-column-layout-300x218.gif" data-large-file="https://blog.logrocket.com/wp-content/uploads/2021/01/three-column-layout.gif" decoding="async" loading="lazy" class="aligncenter size-full wp-image-32198" src="../Images/f2f0ec8b4ffdc103122a047c10f1351c.png" alt="Three Column Layout" data-original-src="https://blog.logrocket.com/wp-content/uploads/2021/01/three-column-layout.gif"/></noscript>
<h2 id="watched-box">监视框</h2>
<p>创建监视框的唯一目的是解决无容器查询问题。为了使用它，我们可以在安装后将它导入到我们的代码中，如下所示:</p>
<pre class="language-bash hljs">import WatchedBox from './path/to/watched-box.min.js';
</pre>
<p>然后，我们可以通过将它包装在我们的 HTML 代码中来使用它:</p>
<pre class="language-xml hljs">&lt;watched-box widthBreaks="70ch, 900px" heightBreaks="50vh, 60em"&gt;
&lt;!-- HTML and text stuff here --&gt;
  &lt;/watched-box&gt;
</pre>
<p>我们分别用“widthBreaks”和“heightBreaks”设置宽度和高度断点。</p>
<p>最后，您可以将以下代码添加到您的 CSS 文件中:</p>
<pre class="language-css hljs">watched-box {
    display: block;
  }
</pre>
<p>通过访问官方 Github 知识库<a href="https://www.google.com/url?q=https://www.google.com/url?q%3Dhttps://github.com/Heydon/watched-box%26amp;sa%3DD%26amp;ust%3D1607897668185000%26amp;usg%3DAOvVaw1IAGYQ7xoma_hQ5n3rWE-h&amp;sa=D&amp;ust=1607897668198000&amp;usg=AOvVaw2tmdym3gDKrxos51Yixfuw" target="_blank" rel="noopener">了解更多关于 watched box 的信息。</a></p>
<h2>结论</h2>
<p>虽然容器查询还不是 CSS 的正式添加，但是我们总是可以用上面的任何方法绕过没有容器查询的限制。Bootstrap 提供了与上述类似的解决方案，但有一些限制，你可以在这里阅读更多关于 bootstrap 的内容。</p><div class="code-block code-block-25">
<div class="blog-plug inline-plug css-plug"><h2>你的前端是否占用了用户的 CPU？</h2><p>随着 web 前端变得越来越复杂，资源贪婪的特性对浏览器的要求越来越高。如果您对监控和跟踪生产环境中所有用户的客户端 CPU 使用、内存使用等感兴趣，</p><a target="_blank" href="https://lp.logrocket.com/blg/css-signup">try LogRocket</a><p>.</p><a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/dacb06c713aec161ffeaffae5bd048cd.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2019/12/cpu-memory-usage.png"/></noscript></a><a href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">https://logrocket.com/signup/</a><p>LogRocket 就像是网络和移动应用的 DVR，记录你的网络应用或网站上发生的一切。您可以汇总和报告关键的前端性能指标，重放用户会话和应用程序状态，记录网络请求，并自动显示所有错误，而不是猜测问题发生的原因。</p><p>现代化您调试 web 和移动应用的方式— <a class="signup" href="https://lp.logrocket.com/blg/css-signup" target="_blank" rel="noopener noreferrer">开始免费监控</a>。</p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
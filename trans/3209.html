<html>
<head>
<title>Linting Go programs: A guide to improving code quality - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>林挺围棋程序:提高代码质量指南</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/linting-go-programs-improving-code-quality/#0001-01-01">https://blog.logrocket.com/linting-go-programs-improving-code-quality/#0001-01-01</a></blockquote><div><article class="article-post">
<p>使用linters通过在问题执行之前突出问题来提高可读性，并且有助于代码库的标准化。一个好的linter有配置设置来帮助减少你不关心的规则的警告，使代码更容易理解、修改和维护。</p>
<p>在本文中，我们将通过以下主题了解更多关于林挺的信息:</p>

<p>golint是多年来使用最广泛的棉绒。不幸的是，它现在已被官方弃用并存档。<a href="https://github.com/golang/lint" target="_blank" rel="noopener"> golint </a>的问题是它不提供任何配置选项，总是应用所有规则，这导致对您不关心的规则的警告。在这篇文章中，我们将使用复活包，以及探索替代去林挺包。</p>
<p>相反，<a href="https://github.com/mgechev/revive" target="_blank" rel="noopener"> revive </a>是一个快速的、可配置的、可扩展的、适应性强的、漂亮的linter。它是golint的替代产品。</p>
<p>以下是revive与golint的不同之处:</p>
<ul>
<li>允许我们使用配置文件启用或禁用规则</li>
<li>允许我们用TOML文件配置林挺规则</li>
<li>运行同样的规则比golint快两倍</li>
<li>提供禁用特定规则或文件或一系列行的整个linter的功能(golint只允许对生成的文件禁用此功能)</li>
<li>可选类型检查。golint中的大多数规则不需要类型检查。如果在配置文件中禁用它们，revive的运行速度将比golint快六倍以上</li>
<li>提供多个格式化程序，让我们定制输出</li>
<li>允许我们为整个linter定制返回代码，或者只基于某些规则的失败</li>
<li>每个人都可以使用自定义规则或格式化程序轻松扩展它</li>
<li>与golint相比，revive提供了更多规则</li>
</ul>
<h2 id="setting-up-a-project-with-revive">使用“恢复”设置项目</h2>
<p>打开终端并创建项目文件夹。导航到项目文件夹，运行以下命令启动一个新项目:</p>
<pre>go mod init project
</pre>
<p>导航到您的Go项目，并运行以下命令来安装复活linter包:</p>
<pre>go install github.com/mgechev/<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="61130417081704210d0015041215">[email protected]</a>
</pre>
<p>创建一个<code>main.go</code>文件，并将以下代码片段添加到<code>main.go</code>文件中:</p>
<pre class="language-go hljs">package main
import (
    "fmt"
)
func main() {
    PrintName("Emmanuel")
    PrintAge(23)
}
func PrintName(name string) {
    fmt.Println(name)
}
func PrintAge(age int) {
    fmt.Println(age)
}
</pre>
<p>现在，在项目终端上运行<code>revive</code>命令，您应该会得到以下报告:</p>
<pre>main.go:11:1: exported function PrintName should have comment or be unexported
main.go:15:1: exported function PrintAge should have comment or be unexported
</pre>
<p>在Go中，导出函数的首字母通常是大写的。正确记录的代码库要求对导出的函数进行注释，并简要概述该函数的用途，这样每个人都可以理解它的作用。现在我们可以看到revive包是如何帮助我们编写文档良好的代码的。</p>
<p>现在，让我们给这些函数添加一些注释:</p>
<pre class="language-go hljs">...
// This function uses the fmt.Println function to print a string.
func PrintName(name string) {
    fmt.Println(name)
}
// This function uses the fmt.Println function to print a number.
func PrintAge(age int) {
    fmt.Println(age)
}
</pre>
<p>执行恢复命令，您应该得到以下报告:</p>
<pre class="language-go hljs">main.go:12:1: comment on exported function PrintName should 
be of the form "PrintName ..."
main.go:17:1: comment on exported function PrintAge should be of the form "PrintAge ..." 
</pre>
<p>Revive告诉我们，对于正确记录的代码库，我们的注释应该以导出函数的名称开始。</p>
<p>让我们将我们的意见修改如下:</p>
<pre class="language-go hljs">...
// PrintName uses the fmt.Println function to print a string.
func PrintName(name string) {
    fmt.Println(name)
}
// PrintAge uses the fmt.Println function to print a number.
func PrintAge(age int) {
    fmt.Println(age)
}
</pre>
<p>这样，执行恢复命令，您应该没有报告。</p>
<h2 id="suppressing-linting-errors-with-revive">用恢复抑制林挺错误</h2>
<p>有时，有必要禁用文件或包中出现的特定林挺问题。配置文件中的注释和排除规则都可以用来做到这一点。让我们依次检查每个策略。</p>
<p>当您希望禁用某一部分代码的警告，但仍然希望将规则应用到项目的其他部分时，注释策略就很方便了。</p>
<p>以下是如何使用注释禁用特定的林挺问题:</p>
<pre class="language-go hljs">package main
import (
    "fmt"
)
func main() {
    PrintName("Emmanuel")
}
// revive:disable:exported
func PrintName(name string) {
    fmt.Println(name)
}
</pre>
<p>其语法是<code>revive</code>，后跟一个冒号，然后是<code>disable</code>。如果需要，添加另一个冒号，后跟一个linter规则的名称。</p>
<h2 id="setting-up-configurations-for-linters">为棉绒机设置配置</h2>
<p>这是复兴棉绒包的一个惊人的特点，它解决了流行的<code>golint</code>棉绒包的主要挑战。</p>
<p>让我们看看如何配置复活linter包来禁用一些林挺规则，以减少不必要的警告。</p>
<p>使用默认的<code><a href="https://github.com/mgechev/revive#recommended-configuration" target="_blank" rel="noopener">revive</a></code> <a href="https://github.com/mgechev/revive#recommended-configuration" target="_blank" rel="noopener">配置</a>将名为<code>revive.toml</code>的文件添加到项目文件夹中:</p>
<pre class="language-ini hljs">ignoreGeneratedHeader = false
severity = "warning"
confidence = 0.8
errorCode = 0
warningCode = 0

[rule.blank-imports]
[rule.context-as-argument]
[rule.context-keys-type]
[rule.dot-imports]
[rule.error-return]
[rule.error-strings]
[rule.error-naming]
[rule.exported]
[rule.if-return]
[rule.increment-decrement]
[rule.var-naming]
[rule.var-declaration]
[rule.package-comments]
[rule.range]
[rule.receiver-naming]
[rule.time-naming]
[rule.unexported-return]
[rule.indent-error-flow]
[rule.errorf]
[rule.empty-block]
[rule.superfluous-else]
[rule.unused-parameter]
[rule.unreachable-code]
[rule.redefines-builtin-id]
</pre>
<p>现在，删除所有注释并运行以下命令，将linter与配置文件一起使用:</p>
<pre>revive -config revive.toml
</pre>
<p>要禁用这些规则，您可以删除它们或在指定规则前添加<code>#</code>,如下所示:</p>
<pre>#[rule.exported]
</pre>
<h2 id="setting-up-linting-in-code-editors">在代码编辑器中设置林挺</h2>
<p>一些代码编辑器自动支持林挺代码；Visual Studio代码就是其中之一。</p>
<p>让我们看看如何在Visual Studio代码中设置复活linter。</p>
<p>打开VS代码，安装VS代码的<code>go</code>扩展。然后，选择<strong>文件</strong>选项卡&gt; <strong>首选项</strong> &gt; <strong>设置</strong>并将<code>go.lint</code>添加到搜索栏，并在<strong> Go: Lint Tool </strong>部分选择<strong>revival</strong>。</p>
<p><img data-attachment-id="126171" data-permalink="https://blog.logrocket.com/linting-go-programs-improving-code-quality/attachment/go-lint-in-search-field/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field.png" data-orig-size="730,282" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Go lint in search field" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field-300x116.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field.png" decoding="async" class="aligncenter size-full wp-image-126171 jetpack-lazy-image" src="../Images/0e9d040bcef59bfbe3916e00c7efc345.png" alt="Go Lint in Search Field" data-lazy-srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field-300x116.png 300w" data-lazy-sizes="(max-width: 730px) 100vw, 730px" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field.png"/></p><noscript><img data-lazy-fallback="1" data-attachment-id="126171" data-permalink="https://blog.logrocket.com/linting-go-programs-improving-code-quality/attachment/go-lint-in-search-field/" data-orig-file="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field.png" data-orig-size="730,282" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Go lint in search field" data-image-description="" data-image-caption="" data-medium-file="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field-300x116.png" data-large-file="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field.png" decoding="async" loading="lazy" class="aligncenter size-full wp-image-126171" src="../Images/0e9d040bcef59bfbe3916e00c7efc345.png" alt="Go Lint in Search Field" srcset="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field.png 730w, https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field-300x116.png 300w" sizes="(max-width: 730px) 100vw, 730px" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/08/go-lint-in-search-field.png"/></noscript>
<p>Visual Studio代码的默认Go linter是<code>staticcheck</code>。</p>
<h2 id="exploring-the-go-vet-command">探索<code>go vet</code>命令</h2>
<p>与linters相反，go vet命令可以识别编译过但可能无法按预期执行的代码。</p>
<p>让我们考虑一下Golang代码中常见的自我赋值错误。按如下方式更新<code>main.go</code>文件:</p>
<pre class="language-go hljs">package main
import (
    "fmt"
)
func main() {
    PrintName("Emmanuel")
}
// revive:disable:exported
func PrintName(name string) {
    name = name
    fmt.Println(name)
}
</pre>
<p>即使有这个bug，上面的代码也能编译。执行复活linter命令不会报告任何关于这个bug的问题。这就是<code>go vet</code>命令派上用场的地方。</p>
<p>运行<code>go vet</code>命令，您应该得到以下结果:</p>
<pre class="language-bash hljs">$ go vet
# sample
.\main.go:10:2: self-assignment of name to name
</pre>
<h2 id="alternative-packages-for-linting-in-go">Go中林挺的替代包</h2>
<p>如果revive不是你的首选，这里有一个由社区建立和维护的Go linters列表。</p>
<h3>戈朗契功能区</h3>
<p><code><a href="https://golangci-lint.run/" target="_blank" rel="noopener">golangci-lint</a></code>跑得很快。它与每一个主要的IDE集成，采用缓存，支持YAML配置，并行执行linter，并带有大量的linter。</p>
<h3>静态检查</h3>
<p><code><a href="https://staticcheck.io/" target="_blank" rel="noopener">staticcheck</a></code>是一种前沿的围棋编程语言linter。它采用静态分析来识别bug和性能问题，提供简化，并实施风格指南。</p>
<h2 id="conclusion">结论</h2>
<p>Go非常重视文档，因为开发人员越容易制作出好的文档，对每个人都越好。</p>
<p>在这篇文章中，我们探讨了林挺在Golang，我的首选林挺包，以及林挺在Go的替代包。我希望你会喜欢和revive一起工作！</p><div class="code-block code-block-2">
<div class="blog-plug base-cta"><h2>使用<a class="signup" href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>消除传统错误报告的干扰</h2>
<a href="https://lp.logrocket.com/blg/signup" class="signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/d6f5a5dd739296c1dd7aab3d5e77eeb9.png" alt="LogRocket Dashboard Free Trial Banner" data-original-src="https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png"/></noscript></a>
<p><a href="https://lp.logrocket.com/blg/signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一个数字体验分析解决方案，它可以保护您免受数百个假阳性错误警报的影响，只针对几个真正重要的项目。LogRocket会告诉您应用程序中实际影响用户的最具影响力的bug和UX问题。</p>
<p>然后，使用具有深层技术遥测的会话重放来确切地查看用户看到了什么以及是什么导致了问题，就像你在他们身后看一样。</p>
<p>LogRocket自动聚合客户端错误、JS异常、前端性能指标和用户交互。然后LogRocket使用机器学习来告诉你哪些问题正在影响大多数用户，并提供你需要修复它的上下文。</p>
<p>关注重要的bug—<a class="signup" href="https://lp.logrocket.com/blg/signup-issue-free" target="_blank" rel="noopener noreferrer">今天就试试LogRocket】。</a></p></div></div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>
<html>
<head>
<title>Comparing Kotlin scope functions - LogRocket Blog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>比较 Kotlin 范围函数- LogRocket 博客</h1>
<blockquote>原文：<a href="https://blog.logrocket.com/comparing-kotlin-scope-functions/#0001-01-01">https://blog.logrocket.com/comparing-kotlin-scope-functions/#0001-01-01</a></blockquote><div><article class="article-post">
<p>Kotlin 编程语言是为 Java 虚拟机(JVM)设计的，它结合了面向对象和函数式编程特性，以及其他编程范例。在 Android 开发中，Kotlin 提供了一个独特的功能，称为范围函数，然而，许多开发人员在处理这些函数时会遇到一些困难。</p>
<p>作为一名 Android 移动开发人员，充分掌握这一概念非常重要，这是应用程序开发中至关重要的一部分。Kotlin 的魅力来自于独特的特性，这些特性使它适合前端和后端开发。在本教程中，我们将涵盖以下内容:</p>

<p>要跟随本教程，您需要以下内容:</p>

<p>我们开始吧！</p>
<h2 id="what-scope-functions">什么是范围函数？</h2>
<p>在 Kotlin 中，作用域函数用于执行对象作用域内的代码块。通常，您可以使用作用域函数包装一个变量或一组逻辑，并返回一个对象文本作为结果。因此，我们可以不用这些对象的名字来访问它们。科特林中有<a href="https://kotlinlang.org/docs/scope-functions.html">五种作用域函数:<code>let</code>、<code>with</code>、<code>run</code>、<code>apply</code>、<code>also</code>。让我们考虑一下这些例子及其独特的用例。</a></p>
<p>基于它们相似的操作，这五个作用域函数之间有许多相似之处，然而，它们在返回 lambda 结果还是上下文对象上有所不同。它们也因您是使用<code>this</code>还是<code>it</code>关键字引用上下文对象而有所不同。</p>
<h2 id="let-function"><code>let</code>功能</h2>
<p><code>let</code>函数有许多应用，但它通常用于防止<code>NullPointerException</code>发生。<code>let</code>函数返回 lambda 结果，上下文对象是<code>it</code>标识符。让我们考虑下面的例子:</p>
<pre class="&quot;language-kotlin">fun main (){
val name: String? = null

println(name!!.reversed)
println(name.length)
}
</pre>
<p>在上面的代码片段中，我们给<code>name</code>变量分配了一个<code>null</code>值。然后，我们通过包含一个<code>NotNull</code>断言操作符<code>(!!)</code>来输出字符串的<code>reverse</code>和<code>length</code>，以断言值不是<code>null</code>，因为我们有一个可空的字符串名称。因为我们是在一个<code>null</code>值上调用函数，这导致了一个<code>NullPointerException</code>。然而，我们可以通过使用带有以下代码的<code>let</code>函数来防止这种情况:</p>
<pre class="&quot;language-kotlin">fun main (){

val name: String? = null

name?.let{
println(it.reversed)
println(it.length)
}
}
</pre>
<p>我们将代码放在<code>let</code>函数的 lambda 表达式中，并用<code>it</code>标识符替换上下文对象名。为了防止<code>NullPointerException</code>，我们把一个<code>safe call operator</code>、<code>( ?.)</code>，就放在我们的<code>name</code>对象之后。</p>
<p>只有当<code>name</code>对象是<code>NotNull</code>时，<code>safe call operator</code>才会设置一个条件并指示我们的程序执行代码。在这个例子中，我们不需要使用<code>NotNull</code>断言<code>(!!)</code>。</p>
<p>接下来，我们将为变量<code>name</code>分配一个字符串值<code>“I love Kotlin”</code>。然后，我们通过将 lambda 值保存在一个名为<code>lengthOfString</code>的变量中来返回这个字符串值:</p>
<pre class="&quot;language-kotlin">fun main (){

val name: String? = "I love Kotlin!!"

val lengthOfString = name?.let{
println(it.reversed)
println(it.length)
}
println(lengthOfString)
}
</pre>
<h2 id="with-function"><code>with</code>功能</h2>
<p><code>with</code>函数有一个<code>return type</code>作为 lambda 结果，上下文对象是<code>this</code>关键字，它指的是对象本身。让我们考虑下面代码片段中的例子:</p>
<pre class="&quot;language-kotlin">class Person{
   var firstName: String = "Elena Wilson"
   var age: Int = 28
}
fun main() {
  val person = Person()
  println(person.firstName)
  println(person.age)
}
</pre>
<p>在上面的代码片段中，我们创建了一个<code>Person</code>类，并分配了一些属性<code>firstName</code>和<code>age</code>。接下来，在我们的主函数中，我们使用用于<code>cli</code>输出的<code>println</code>打印出值。</p>
<p>假设我们在<code>Person</code>类中有超过二十个属性，这会导致多次代码重复。我们可以通过使用<code>with</code>函数并使用<code>this</code>关键字在 lambda 表达式中传递<code>person</code>对象来纠正这个问题:</p>
<pre class="&quot;language-kotlin">n){
 println(this.firstName)
 println(this.age)
}
</pre>
<p>这里的上下文对象指的是执行操作的<code>person</code>对象。<code>with</code>函数的返回值是一个 lambda 结果。假设我们决定给<code>age</code>加 10 年，并将该值存储在一个名为<code>personInfo</code>的变量中，变量的类型为<code>integer</code>:</p>
<pre class="&quot;language-kotlin">val person = Person()
val personInfo : String = with (person){
 println(this.firstName)
 println(this.age)
 age + 10
"I love the game of football"
}
println(personInfo)
}
</pre>
<p>产生的值是<code>“I love the game of football”</code>。总之，<code>with</code>函数返回一个 lambda 函数，并使用<code>this</code>关键字作为上下文对象。</p>
<h2 id="run-function"><code>run</code>功能</h2>
<p><code>run</code>函数返回 lambda 结果，我们通过使用<code>this</code>关键字来引用上下文对象。<code>run</code>功能是<code>with</code>和<code>let</code>功能的组合。让我们考虑下面代码片段中的例子:</p>
<pre class="&quot;language-kotlin">fun main {

val person: Person? = Person()
val bio = person?.run {
 println(name)
 println(age)
"LogRocket rocks!!!"
   }
println(bio)
}
</pre>
<p>假设我们决定给<code>person</code>对象赋一个空值，我们必须防止<code>NullPointerException</code>发生。我们可以通过用<code>person</code>对象调用<code>run</code>函数来实现这一点。接下来，我们将返回 lambda 函数<code>bio</code>。</p>
<h2 id="apply-function"><code>apply</code>功能</h2>
<p><code>apply</code>是高阶函数。<code>apply</code>函数返回一个上下文对象，上下文对象返回<code>this</code>。让我们考虑下面的例子:</p>
<pre class="&quot;language-kotlin">val car = Car()
  var carName: String = ""
  var carColor: String = ""

fun main {

 val car = Car().apply {
 carName = "Lamborghini"
 carColor = "Navy blue"
   }
}
 with(car){
 println(carName)
 println(carColor)
  }
</pre>
<h2 id="also-function"><code>also</code>功能</h2>
<p><code>also</code>函数类似于前面的函数，用于在初始化后对特定对象执行操作。<code>also</code>函数返回上下文对象，使用<code>it</code>标识符可以引用上下文对象。让我们参考下面的代码片段了解更多细节:</p>
<pre class="&quot;language-kotlin">fun main(){

val numberList: mutableList&lt;Int&gt; = mutableListOf(1,2,4,5)
    numberList.also{
println("The list of items are: $numberList")

numberList.add(6)
println("The list of items after adding an element are: $numberList")
numberList.remove(4)

println("The list of items after removing an element are: $numberList")
    }
}
</pre>
<p>从上面的代码中，我们创建了一个具有五个整数值的<code>numbersList</code>对象，并在<code>numbersList</code>对象下执行了一些操作。然后我们利用了<code>also</code>函数。注意，在<code>also</code>函数中，我们可以通过使用<code>it</code>标识符来引用<code>numberList</code>，如下面的代码片段所示:</p>
<pre class="“language-javascript">fun main(){

val numberList: mutableList&lt;Int&gt; = mutableListOf(1,2,4,5)
     val multipleNumbers = numberList.also {
println("The list of items are: $it")

it.add(6)
println("The list of items after adding an element are: $it")

it.remove(4)
println("The list of items after removing an element are: $it")
    }
println("The original numbers are: $numberList")
println("The multipleNumbers are: $multipleNumbers)
}
</pre>
<p>实现<code>also</code>功能的另一种方式是使用<code>it</code>和<code>also</code>关键字，如下面的代码片段所示。我们使用<code>also</code>函数通过给<code>Eden Peter</code>赋值来修改<code>firstName</code>变量的值:</p>
<pre class="“language-javascript">fun main {

 val person = Person().apply {
 firstName = "Eden Elenwoke"
 age = 22
   }
 with(person){
 println(firstName)
 println(age)
  }

person.also{
 it.firstName = "Eden Peter"
println("My new name is: + ${it.firstName}")
 }
}
</pre>
<h2 id="when-how-kotlin-scope-functions">何时以及如何使用 Kotlin 范围函数</h2>
<p>起初，在正确的地方使用范围函数可能看起来有点棘手，但这很大程度上取决于我们想要用 project 实现什么。让我们参考下面的总结作为指导，告诉我们对于每个独特的用例使用哪个范围函数:</p>
<ul>
<li><code>apply</code>:您想要配置或初始化一个对象</li>
<li><code>with</code>:你想对一个非空对象进行操作</li>
<li><code>let</code>:你想在一个可空的对象上执行一个 lambda 函数并避免<code>NullPointException</code></li>
<li><code>run</code>:你想对一个可空的对象进行操作，执行一个 lambda 表达式，避免<code>NullPointerException</code>。这是<code>with</code>和<code>let</code>功能特性的组合</li>
<li><code>also</code>:您想要执行一些额外的对象操作和配置</li>
</ul>
<h2 id="comparing-kotlin-scoping-functions">Kotlin 范围函数与普通函数的比较</h2>
<p>让我们用几个例子来比较一下作用域函数和普通函数。让我们考虑一个普通的函数，使用一个名为<code>Student</code>的<code>class</code>，它有三个属性:<code>studentName</code>、<code>studentNumber</code>和<code>studentAge</code>，如下所示:</p>
<pre class="&quot;language-kotlin">Class Student {
   var studentName : String? = null
   var studentNumber : String? = null
   var studentAge : Int? = null
}
</pre>
<p>通过下面的代码片段，我们实例化了我们的类并为其赋值:</p>
<pre class="&quot;language-kotlin">val student = Student ()
student.studentName = "Peter Aideloje"
student.studentNumber = 08012345678
student.studentAge = 28
</pre>
<p>使用一个<code>scope function</code>可以帮助我们用更少的代码以更简单、更干净的方式获得与上面相同的结果。让我们将上面的表达式与下面代码片段中的<code>scope</code>函数进行比较:</p>
<pre class="&quot;language-kotlin">val person = Student().apply{
    studentName = "Peter Aideloje"
    studentNumber = 08012345678
    studentAge = 28
}
</pre>
<p>在上面的代码片段中，我们实例化了<code>Student</code>对象并调用了<code>apply</code>函数。然后，我们在 lambda 表达式中指定<code>studentName</code>、<code>studentNumber</code>和<code>studentAge</code>属性。</p>
<p>当我们在上面的例子中比较 scope 函数和 normal 函数时，我们注意到我们成功地消除了代码重复，其中<code>student</code>对象名重复了多次。使用范围函数使我们的代码更加简洁易读，我们初始化属性时没有使用<code>student</code>对象名。</p>
<h2 id="benefits-using-scoping-functions">使用范围函数的好处</h2>
<p>从上面函数比较部分的例子中，我们已经认识到使用范围函数的一些好处:</p>
<ul>
<li>简化样板代码</li>
<li>更简洁和精确的代码</li>
<li>减少代码重复</li>
<li>增强的代码可读性</li>
</ul>
<p>为了进一步阅读，你也可以查阅官方的 Kotlin 文档。</p>
<h2 id="conclusion">结论</h2>
<p>在本文中，我们介绍了 Kotlin 中的五个范围函数。我们还考虑了一些独特的用例，回顾了何时使用每个范围函数。我们比较了作用域函数和普通函数，最后回顾了使用作用域函数的好处。</p>
<p>随着市场上越来越多的 Android 设备，Android 开发越来越受欢迎，Kotlin 编程语言的知识将变得更加重要。我希望这篇文章是有帮助的，如果你有任何问题，请随时留下评论。编码快乐！</p><div class="code-block code-block-32">
<div class="blog-plug inline-plug kotlin-plug"><h2>LogRocket :即时重现你的安卓应用中的问题。</h2><a class="signup" href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"><img class="alignnone size-full wp-image-46 jetpack-lazy-image" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-lazy-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png?is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/><noscript><img data-lazy-fallback="1" class="alignnone size-full wp-image-46" src="../Images/b5ae4bd0ecde7aa9d5288746416d5e18.png" data-original-src="https://blog.logrocket.com/wp-content/uploads/2022/11/react-native-plug_android-1.png"/></noscript></a><p><a href="https://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer"> LogRocket </a>是一款 Android 监控解决方案，可以帮助您即时重现问题，确定 bug 的优先级，并了解您的 Android 应用程序的性能。</p><p>LogRocket 还可以向你展示用户是如何与你的应用程序互动的，从而帮助你提高转化率和产品使用率。LogRocket 的产品分析功能揭示了用户不完成特定流程或不采用新功能的原因。</p><p>开始主动监控您的 Android 应用程序— <a class="signup" href="hhttps://lp.logrocket.com/blg/kotlin-signup" target="_blank" rel="noopener noreferrer">免费试用 LogRocket】。</a></p></div>
</div>

<p class="clearfix"/>
<p class="clearfix"/>
</article>

</div>    
</body>
</html>